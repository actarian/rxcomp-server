{"version":3,"sources":["test/js/main.server.ts","../node_modules/node-fetch/lib/index.mjs","../src/cache/cache.service.ts","../node_modules/cross-fetch/dist/node-ponyfill.js","../node_modules/cross-fetch/dist/node-polyfill.js","../src/nodes/nodes.ts","../test/js/http/http-event.ts","../test/js/vars.ts","../src/platform/server.ts","../test/js/http/http-headers.ts","../test/js/http/http-error-response.ts","../test/js/http/http-response.ts","../test/js/http/http-fetch.handler.ts","../test/js/http/http-interceptor.ts","../test/js/http/http-params.ts","../test/js/http/http-request.ts","../test/js/http/http-client.ts","../test/js/app.component.ts","../test/js/app.module.ts","../test/js/main.server.ts"],"names":["g","f","exports","module","require","define","amd","globalThis","self","main","server","umd","Stream","http","Url","https","zlib","rxjs","operators","htmlparser2","rxcomp","this","Object","prototype","hasOwnProperty","call","commonjsGlobal","window","global","Readable","BUFFER","Symbol","TYPE","Blob","[object Object]","blobParts","arguments","options","buffers","size","a","length","Number","i","element","buffer","Buffer","ArrayBuffer","isView","from","byteOffset","byteLength","String","push","concat","type","undefined","toLowerCase","test","Promise","resolve","toString","buf","ab","slice","readable","_read","start","end","relativeStart","relativeEnd","Math","max","min","span","slicedBuffer","blob","FetchError","message","systemError","Error","code","errno","captureStackTrace","constructor","convert","defineProperties","enumerable","defineProperty","toStringTag","value","writable","configurable","create","name","e","INTERNALS","PassThrough","Body","body","_this","_ref","_ref$size","_ref$timeout","timeout","isURLSearchParams","isBlob","isBuffer","disturbed","error","on","err","url","consumeBody","_this4","reject","TypeError","alloc","stream","accum","accumBytes","abort","resTimeout","setTimeout","chunk","clearTimeout","obj","append","delete","get","getAll","has","set","sort","arrayBuffer","clone","instance","p1","p2","bodyUsed","getBoundary","pipe","extractContentType","getTotalBytes","getLengthSync","_lengthRetrievers","hasKnownLength","then","ct","headers","assign","_this2","JSON","parse","_this3","res","str","charset","exec","pop","convertBody","json","text","mixIn","proto","getOwnPropertyNames","desc","getOwnPropertyDescriptor","invalidTokenRegex","invalidHeaderCharRegex","validateName","validateValue","find","map","key","MAP","Headers","init","rawHeaders","raw","headerNames","keys","headerName","method","iterator","pairs","pair","Array","join","callback","thisArg","getHeaders","_pairs$i","createHeadersIterator","kind","k","entries","forEach","values","INTERNAL","target","HeadersIteratorPrototype","index","setPrototypeOf","getPrototypeOf","_INTERNAL","done","exportNodeCompatibleHeaders","__proto__","hostHeaderKey","INTERNALS$1","STATUS_CODES","Response","opts","status","contentType","statusText","counter","ok","redirected","INTERNALS$2","parse_url","format_url","format","streamDestructionSupported","isRequest","input","Request","parsedURL","href","toUpperCase","inputBody","signal","isAbortSignal","redirect","follow","compress","agent","AbortError","PassThrough$1","resolve_url","fetch","request","protocol","hostname","contentLengthValue","totalBytes","getNodeRequestOptions","send","response","destroy","emit","aborted","abortAndFinalize","finalize","req","reqTimeout","removeEventListener","addEventListener","once","socket","isArray","val","createHeadersLenient","isRedirect","statusCode","location","locationURL","requestOpts","response_options","statusMessage","codings","zlibOptions","flush","Z_SYNC_FLUSH","finishFlush","createGunzip","createBrotliDecompress","createInflate","createInflateRaw","dest","write","writeToStream","n","CacheControlType","nodeFetch","freeze","default","fetch$1","Request$1","nodePonyfill","fn","basedir","path","base","commonjsRequire","createCommonjsModule","realFetch","fetchNode","bind","_defineProperties","props","descriptor","_createClass","Constructor","protoProps","staticProps","_inheritsLoose","subClass","superClass","_getPrototypeOf","o","_setPrototypeOf","p","_isNativeReflectConstruct","Reflect","construct","sham","Proxy","Date","_construct","Parent","args","Class","apply","Function","_wrapNativeSuper","_cache","Map","indexOf","Wrapper","_assertThisInitialized","ReferenceError","_arrayLikeToArray","arr","len","arr2","_createForOfIteratorHelperLoose","allowArrayLike","it","minLen","_unsupportedIterableToArray","next","polyfill","RxNodeType","SelectorType","CacheItem","maxAge","cacheControl","Public","date","NoStore","getTime","now","CacheService","cache_","cacheItem","expired","stringify","isRxElement","x","nodeType","ELEMENT_NODE","isRxText","TEXT_NODE","html","node","doc","RxDocument","parentNode","parser","Parser","onopentag","nodeName","attributes","RxElement","childNodes","onclosetag","ontext","nodeValue","textNode","RxText","onprocessinginstruction","RxDocumentType","RxProcessingInstruction","oncomment","RxComment","oncommentend","oncdatastart","console","log","oncdataend","onerror","decodeEntities","lowerCaseTags","getQueries","selector","queries","trim","split","_step","selectors","_iterator","matchAll","match","Id","negate","Attribute","TagName","inner","matchSelectors","child","reduce","id","classList","matchSelector","querySelector","query","shift","_step3","_iterator3","cloneNode","source","deep","nodeElement","DOCUMENT_FRAGMENT_NODE","nodeDocumentFragment","RxDocumentFragment","COMMENT_NODE","isRxComment","DOCUMENT_NODE","isRxDocument","documentElement","HttpEventType","RxNode","_proto","serialize","RxStyle","_proto2","item","getPropertyPriority","getPropertyValue","setProperty","important","serialize_","removeProperty","style","_this$node$attributes","RxClassList","_Array","_proto3","contains","add","_len","names","remove","_this5","_len2","splice","toggle","force","replace","oldClass","newClass","class","_this$node$attributes2","_RxNode","_this6","_proto4","_this7","_len3","nodesOrDOMStrings","nodeOrDomString","prepend","_this8","_len4","unshift","replaceChildren","_this9","_len5","nodes","querySelectorAll","filter","hasAttribute","attribute","getAttribute","setAttribute","removeAttribute","replaceChild","newChild","oldChild","removeChild","insertBefore","newNode","referenceNode","addListener","eventName","handler","removeListener","serializeAttributes","_this10","children","count","_step4","_iterator4","innerText","_this11","_RxNode2","_this12","_RxNode4","_this14","_RxNode5","_this15","PROCESSING_INSTRUCTION_NODE","_RxNode6","_this16","DOCUMENT_TYPE_NODE","_RxElement","_this17","_RxElement2","_this18","isRxDocumentType","title","firstElementChild","_proto10","createAttribute","createAttributeNS","createCDATASection","createComment","createDocumentFragment","createElement","createElementNS","createEvent","createNodeIterator","createProcessingInstruction","createRange","createTextNode","createTouchList","createTreeWalker","Vars","static","development","production","host","resource","api","fs","ServerResponse","ServerErrorResponse","Server","_Platform","bootstrap","moduleFactory","template","isPlatformServer","ModuleError","meta","document","resolveGlobals","resolveMeta","_node$parentNode","nodeInnerHTML","rxcomp_hydrate_","innerHTML","scriptNode","scriptText","imports","instances","compile","pushChanges","documentOrHtml","Platform","template$","Observable","observer","complete","readFile","renderRequest$","cached","switchMap","subscribe","success","HttpHeaders","headers_","line","clone_","v","HttpErrorResponse","_Error","ResponseError","HttpResponse","HttpFetchHandler","response_","handle","requestInfo","urlWithParams","requestInit","toInitRequest","getProgress","getResponse","catchError","errorResponse","httpErrorResponse","nextError$","of","clonedBody","isPlatformBrowser","reportProgress","reader","getReader","contentLength","progress","percent","current","total","read","_ref2","onProgress","receivedLength","closed","responseType","catch","getResponseType","getReadableStream","ReadableStream","controller","_ref3","close","enqueue","HttpInterceptorHandler","interceptor","intercept","HttpInterceptors","fetchHandler","HttpInterceptingHandler","chain","interceptors","reduceRight","HttpUrlEncodingCodec","encodeKey","encodeParam_","encodeValue","decodeKey","decodeURIComponent","decodeValue","HttpParams","encoder","params_","params","queryString","keyValue","parseRawParams_","encodeURIComponent","HttpRequest","third","fourth","withCredentials","observe","isStaticFile","methodHasBody","sep","serializeBody","isArrayBuffer","isFormData","detectContentTypeHeader","mode","credentials","cache","toFetchRequest__","FormData","HttpClient","incrementPendingRequest","pendingRequests$","getValue","decrementPendingRequest","request$","first","events$","concatMap","throwError","getError","event","delete$","get$","head$","jsonp$","callbackParam","options$","patch$","optionsWithBody_","post$","put$","BehaviorSubject","CustomInterceptor","clonedRequest","AppComponent","_Component","items","onInit","data","getTodos","errors$","takeUntil","unsubscribe$","onClick","completed","Component","AppModule","_Module","Module","CoreModule","declarations","bootstrap$","renderServer"],"mappings":"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","file":"server/main.server.umd.min.js","sourcesContent":[null,"import Stream from 'stream';\nimport http from 'http';\nimport Url from 'url';\nimport https from 'https';\nimport zlib from 'zlib';\n\n// Based on https://github.com/tmpvar/jsdom/blob/aa85b2abf07766ff7bf5c1f6daafb3726f2f2db5/lib/jsdom/living/blob.js\n\n// fix for \"Readable\" isn't a named export issue\nconst Readable = Stream.Readable;\n\nconst BUFFER = Symbol('buffer');\nconst TYPE = Symbol('type');\n\nclass Blob {\n\tconstructor() {\n\t\tthis[TYPE] = '';\n\n\t\tconst blobParts = arguments[0];\n\t\tconst options = arguments[1];\n\n\t\tconst buffers = [];\n\t\tlet size = 0;\n\n\t\tif (blobParts) {\n\t\t\tconst a = blobParts;\n\t\t\tconst length = Number(a.length);\n\t\t\tfor (let i = 0; i < length; i++) {\n\t\t\t\tconst element = a[i];\n\t\t\t\tlet buffer;\n\t\t\t\tif (element instanceof Buffer) {\n\t\t\t\t\tbuffer = element;\n\t\t\t\t} else if (ArrayBuffer.isView(element)) {\n\t\t\t\t\tbuffer = Buffer.from(element.buffer, element.byteOffset, element.byteLength);\n\t\t\t\t} else if (element instanceof ArrayBuffer) {\n\t\t\t\t\tbuffer = Buffer.from(element);\n\t\t\t\t} else if (element instanceof Blob) {\n\t\t\t\t\tbuffer = element[BUFFER];\n\t\t\t\t} else {\n\t\t\t\t\tbuffer = Buffer.from(typeof element === 'string' ? element : String(element));\n\t\t\t\t}\n\t\t\t\tsize += buffer.length;\n\t\t\t\tbuffers.push(buffer);\n\t\t\t}\n\t\t}\n\n\t\tthis[BUFFER] = Buffer.concat(buffers);\n\n\t\tlet type = options && options.type !== undefined && String(options.type).toLowerCase();\n\t\tif (type && !/[^\\u0020-\\u007E]/.test(type)) {\n\t\t\tthis[TYPE] = type;\n\t\t}\n\t}\n\tget size() {\n\t\treturn this[BUFFER].length;\n\t}\n\tget type() {\n\t\treturn this[TYPE];\n\t}\n\ttext() {\n\t\treturn Promise.resolve(this[BUFFER].toString());\n\t}\n\tarrayBuffer() {\n\t\tconst buf = this[BUFFER];\n\t\tconst ab = buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);\n\t\treturn Promise.resolve(ab);\n\t}\n\tstream() {\n\t\tconst readable = new Readable();\n\t\treadable._read = function () {};\n\t\treadable.push(this[BUFFER]);\n\t\treadable.push(null);\n\t\treturn readable;\n\t}\n\ttoString() {\n\t\treturn '[object Blob]';\n\t}\n\tslice() {\n\t\tconst size = this.size;\n\n\t\tconst start = arguments[0];\n\t\tconst end = arguments[1];\n\t\tlet relativeStart, relativeEnd;\n\t\tif (start === undefined) {\n\t\t\trelativeStart = 0;\n\t\t} else if (start < 0) {\n\t\t\trelativeStart = Math.max(size + start, 0);\n\t\t} else {\n\t\t\trelativeStart = Math.min(start, size);\n\t\t}\n\t\tif (end === undefined) {\n\t\t\trelativeEnd = size;\n\t\t} else if (end < 0) {\n\t\t\trelativeEnd = Math.max(size + end, 0);\n\t\t} else {\n\t\t\trelativeEnd = Math.min(end, size);\n\t\t}\n\t\tconst span = Math.max(relativeEnd - relativeStart, 0);\n\n\t\tconst buffer = this[BUFFER];\n\t\tconst slicedBuffer = buffer.slice(relativeStart, relativeStart + span);\n\t\tconst blob = new Blob([], { type: arguments[2] });\n\t\tblob[BUFFER] = slicedBuffer;\n\t\treturn blob;\n\t}\n}\n\nObject.defineProperties(Blob.prototype, {\n\tsize: { enumerable: true },\n\ttype: { enumerable: true },\n\tslice: { enumerable: true }\n});\n\nObject.defineProperty(Blob.prototype, Symbol.toStringTag, {\n\tvalue: 'Blob',\n\twritable: false,\n\tenumerable: false,\n\tconfigurable: true\n});\n\n/**\n * fetch-error.js\n *\n * FetchError interface for operational errors\n */\n\n/**\n * Create FetchError instance\n *\n * @param   String      message      Error message for human\n * @param   String      type         Error type for machine\n * @param   String      systemError  For Node.js system error\n * @return  FetchError\n */\nfunction FetchError(message, type, systemError) {\n  Error.call(this, message);\n\n  this.message = message;\n  this.type = type;\n\n  // when err.type is `system`, err.code contains system error code\n  if (systemError) {\n    this.code = this.errno = systemError.code;\n  }\n\n  // hide custom error implementation details from end-users\n  Error.captureStackTrace(this, this.constructor);\n}\n\nFetchError.prototype = Object.create(Error.prototype);\nFetchError.prototype.constructor = FetchError;\nFetchError.prototype.name = 'FetchError';\n\nlet convert;\ntry {\n\tconvert = require('encoding').convert;\n} catch (e) {}\n\nconst INTERNALS = Symbol('Body internals');\n\n// fix an issue where \"PassThrough\" isn't a named export for node <10\nconst PassThrough = Stream.PassThrough;\n\n/**\n * Body mixin\n *\n * Ref: https://fetch.spec.whatwg.org/#body\n *\n * @param   Stream  body  Readable stream\n * @param   Object  opts  Response options\n * @return  Void\n */\nfunction Body(body) {\n\tvar _this = this;\n\n\tvar _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n\t    _ref$size = _ref.size;\n\n\tlet size = _ref$size === undefined ? 0 : _ref$size;\n\tvar _ref$timeout = _ref.timeout;\n\tlet timeout = _ref$timeout === undefined ? 0 : _ref$timeout;\n\n\tif (body == null) {\n\t\t// body is undefined or null\n\t\tbody = null;\n\t} else if (isURLSearchParams(body)) {\n\t\t// body is a URLSearchParams\n\t\tbody = Buffer.from(body.toString());\n\t} else if (isBlob(body)) ; else if (Buffer.isBuffer(body)) ; else if (Object.prototype.toString.call(body) === '[object ArrayBuffer]') {\n\t\t// body is ArrayBuffer\n\t\tbody = Buffer.from(body);\n\t} else if (ArrayBuffer.isView(body)) {\n\t\t// body is ArrayBufferView\n\t\tbody = Buffer.from(body.buffer, body.byteOffset, body.byteLength);\n\t} else if (body instanceof Stream) ; else {\n\t\t// none of the above\n\t\t// coerce to string then buffer\n\t\tbody = Buffer.from(String(body));\n\t}\n\tthis[INTERNALS] = {\n\t\tbody,\n\t\tdisturbed: false,\n\t\terror: null\n\t};\n\tthis.size = size;\n\tthis.timeout = timeout;\n\n\tif (body instanceof Stream) {\n\t\tbody.on('error', function (err) {\n\t\t\tconst error = err.name === 'AbortError' ? err : new FetchError(`Invalid response body while trying to fetch ${_this.url}: ${err.message}`, 'system', err);\n\t\t\t_this[INTERNALS].error = error;\n\t\t});\n\t}\n}\n\nBody.prototype = {\n\tget body() {\n\t\treturn this[INTERNALS].body;\n\t},\n\n\tget bodyUsed() {\n\t\treturn this[INTERNALS].disturbed;\n\t},\n\n\t/**\n  * Decode response as ArrayBuffer\n  *\n  * @return  Promise\n  */\n\tarrayBuffer() {\n\t\treturn consumeBody.call(this).then(function (buf) {\n\t\t\treturn buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);\n\t\t});\n\t},\n\n\t/**\n  * Return raw response as Blob\n  *\n  * @return Promise\n  */\n\tblob() {\n\t\tlet ct = this.headers && this.headers.get('content-type') || '';\n\t\treturn consumeBody.call(this).then(function (buf) {\n\t\t\treturn Object.assign(\n\t\t\t// Prevent copying\n\t\t\tnew Blob([], {\n\t\t\t\ttype: ct.toLowerCase()\n\t\t\t}), {\n\t\t\t\t[BUFFER]: buf\n\t\t\t});\n\t\t});\n\t},\n\n\t/**\n  * Decode response as json\n  *\n  * @return  Promise\n  */\n\tjson() {\n\t\tvar _this2 = this;\n\n\t\treturn consumeBody.call(this).then(function (buffer) {\n\t\t\ttry {\n\t\t\t\treturn JSON.parse(buffer.toString());\n\t\t\t} catch (err) {\n\t\t\t\treturn Body.Promise.reject(new FetchError(`invalid json response body at ${_this2.url} reason: ${err.message}`, 'invalid-json'));\n\t\t\t}\n\t\t});\n\t},\n\n\t/**\n  * Decode response as text\n  *\n  * @return  Promise\n  */\n\ttext() {\n\t\treturn consumeBody.call(this).then(function (buffer) {\n\t\t\treturn buffer.toString();\n\t\t});\n\t},\n\n\t/**\n  * Decode response as buffer (non-spec api)\n  *\n  * @return  Promise\n  */\n\tbuffer() {\n\t\treturn consumeBody.call(this);\n\t},\n\n\t/**\n  * Decode response as text, while automatically detecting the encoding and\n  * trying to decode to UTF-8 (non-spec api)\n  *\n  * @return  Promise\n  */\n\ttextConverted() {\n\t\tvar _this3 = this;\n\n\t\treturn consumeBody.call(this).then(function (buffer) {\n\t\t\treturn convertBody(buffer, _this3.headers);\n\t\t});\n\t}\n};\n\n// In browsers, all properties are enumerable.\nObject.defineProperties(Body.prototype, {\n\tbody: { enumerable: true },\n\tbodyUsed: { enumerable: true },\n\tarrayBuffer: { enumerable: true },\n\tblob: { enumerable: true },\n\tjson: { enumerable: true },\n\ttext: { enumerable: true }\n});\n\nBody.mixIn = function (proto) {\n\tfor (const name of Object.getOwnPropertyNames(Body.prototype)) {\n\t\t// istanbul ignore else: future proof\n\t\tif (!(name in proto)) {\n\t\t\tconst desc = Object.getOwnPropertyDescriptor(Body.prototype, name);\n\t\t\tObject.defineProperty(proto, name, desc);\n\t\t}\n\t}\n};\n\n/**\n * Consume and convert an entire Body to a Buffer.\n *\n * Ref: https://fetch.spec.whatwg.org/#concept-body-consume-body\n *\n * @return  Promise\n */\nfunction consumeBody() {\n\tvar _this4 = this;\n\n\tif (this[INTERNALS].disturbed) {\n\t\treturn Body.Promise.reject(new TypeError(`body used already for: ${this.url}`));\n\t}\n\n\tthis[INTERNALS].disturbed = true;\n\n\tif (this[INTERNALS].error) {\n\t\treturn Body.Promise.reject(this[INTERNALS].error);\n\t}\n\n\tlet body = this.body;\n\n\t// body is null\n\tif (body === null) {\n\t\treturn Body.Promise.resolve(Buffer.alloc(0));\n\t}\n\n\t// body is blob\n\tif (isBlob(body)) {\n\t\tbody = body.stream();\n\t}\n\n\t// body is buffer\n\tif (Buffer.isBuffer(body)) {\n\t\treturn Body.Promise.resolve(body);\n\t}\n\n\t// istanbul ignore if: should never happen\n\tif (!(body instanceof Stream)) {\n\t\treturn Body.Promise.resolve(Buffer.alloc(0));\n\t}\n\n\t// body is stream\n\t// get ready to actually consume the body\n\tlet accum = [];\n\tlet accumBytes = 0;\n\tlet abort = false;\n\n\treturn new Body.Promise(function (resolve, reject) {\n\t\tlet resTimeout;\n\n\t\t// allow timeout on slow response body\n\t\tif (_this4.timeout) {\n\t\t\tresTimeout = setTimeout(function () {\n\t\t\t\tabort = true;\n\t\t\t\treject(new FetchError(`Response timeout while trying to fetch ${_this4.url} (over ${_this4.timeout}ms)`, 'body-timeout'));\n\t\t\t}, _this4.timeout);\n\t\t}\n\n\t\t// handle stream errors\n\t\tbody.on('error', function (err) {\n\t\t\tif (err.name === 'AbortError') {\n\t\t\t\t// if the request was aborted, reject with this Error\n\t\t\t\tabort = true;\n\t\t\t\treject(err);\n\t\t\t} else {\n\t\t\t\t// other errors, such as incorrect content-encoding\n\t\t\t\treject(new FetchError(`Invalid response body while trying to fetch ${_this4.url}: ${err.message}`, 'system', err));\n\t\t\t}\n\t\t});\n\n\t\tbody.on('data', function (chunk) {\n\t\t\tif (abort || chunk === null) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (_this4.size && accumBytes + chunk.length > _this4.size) {\n\t\t\t\tabort = true;\n\t\t\t\treject(new FetchError(`content size at ${_this4.url} over limit: ${_this4.size}`, 'max-size'));\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\taccumBytes += chunk.length;\n\t\t\taccum.push(chunk);\n\t\t});\n\n\t\tbody.on('end', function () {\n\t\t\tif (abort) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tclearTimeout(resTimeout);\n\n\t\t\ttry {\n\t\t\t\tresolve(Buffer.concat(accum, accumBytes));\n\t\t\t} catch (err) {\n\t\t\t\t// handle streams that have accumulated too much data (issue #414)\n\t\t\t\treject(new FetchError(`Could not create Buffer from response body for ${_this4.url}: ${err.message}`, 'system', err));\n\t\t\t}\n\t\t});\n\t});\n}\n\n/**\n * Detect buffer encoding and convert to target encoding\n * ref: http://www.w3.org/TR/2011/WD-html5-20110113/parsing.html#determining-the-character-encoding\n *\n * @param   Buffer  buffer    Incoming buffer\n * @param   String  encoding  Target encoding\n * @return  String\n */\nfunction convertBody(buffer, headers) {\n\tif (typeof convert !== 'function') {\n\t\tthrow new Error('The package `encoding` must be installed to use the textConverted() function');\n\t}\n\n\tconst ct = headers.get('content-type');\n\tlet charset = 'utf-8';\n\tlet res, str;\n\n\t// header\n\tif (ct) {\n\t\tres = /charset=([^;]*)/i.exec(ct);\n\t}\n\n\t// no charset in content type, peek at response body for at most 1024 bytes\n\tstr = buffer.slice(0, 1024).toString();\n\n\t// html5\n\tif (!res && str) {\n\t\tres = /<meta.+?charset=(['\"])(.+?)\\1/i.exec(str);\n\t}\n\n\t// html4\n\tif (!res && str) {\n\t\tres = /<meta[\\s]+?http-equiv=(['\"])content-type\\1[\\s]+?content=(['\"])(.+?)\\2/i.exec(str);\n\n\t\tif (res) {\n\t\t\tres = /charset=(.*)/i.exec(res.pop());\n\t\t}\n\t}\n\n\t// xml\n\tif (!res && str) {\n\t\tres = /<\\?xml.+?encoding=(['\"])(.+?)\\1/i.exec(str);\n\t}\n\n\t// found charset\n\tif (res) {\n\t\tcharset = res.pop();\n\n\t\t// prevent decode issues when sites use incorrect encoding\n\t\t// ref: https://hsivonen.fi/encoding-menu/\n\t\tif (charset === 'gb2312' || charset === 'gbk') {\n\t\t\tcharset = 'gb18030';\n\t\t}\n\t}\n\n\t// turn raw buffers into a single utf-8 buffer\n\treturn convert(buffer, 'UTF-8', charset).toString();\n}\n\n/**\n * Detect a URLSearchParams object\n * ref: https://github.com/bitinn/node-fetch/issues/296#issuecomment-307598143\n *\n * @param   Object  obj     Object to detect by type or brand\n * @return  String\n */\nfunction isURLSearchParams(obj) {\n\t// Duck-typing as a necessary condition.\n\tif (typeof obj !== 'object' || typeof obj.append !== 'function' || typeof obj.delete !== 'function' || typeof obj.get !== 'function' || typeof obj.getAll !== 'function' || typeof obj.has !== 'function' || typeof obj.set !== 'function') {\n\t\treturn false;\n\t}\n\n\t// Brand-checking and more duck-typing as optional condition.\n\treturn obj.constructor.name === 'URLSearchParams' || Object.prototype.toString.call(obj) === '[object URLSearchParams]' || typeof obj.sort === 'function';\n}\n\n/**\n * Check if `obj` is a W3C `Blob` object (which `File` inherits from)\n * @param  {*} obj\n * @return {boolean}\n */\nfunction isBlob(obj) {\n\treturn typeof obj === 'object' && typeof obj.arrayBuffer === 'function' && typeof obj.type === 'string' && typeof obj.stream === 'function' && typeof obj.constructor === 'function' && typeof obj.constructor.name === 'string' && /^(Blob|File)$/.test(obj.constructor.name) && /^(Blob|File)$/.test(obj[Symbol.toStringTag]);\n}\n\n/**\n * Clone body given Res/Req instance\n *\n * @param   Mixed  instance  Response or Request instance\n * @return  Mixed\n */\nfunction clone(instance) {\n\tlet p1, p2;\n\tlet body = instance.body;\n\n\t// don't allow cloning a used body\n\tif (instance.bodyUsed) {\n\t\tthrow new Error('cannot clone body after it is used');\n\t}\n\n\t// check that body is a stream and not form-data object\n\t// note: we can't clone the form-data object without having it as a dependency\n\tif (body instanceof Stream && typeof body.getBoundary !== 'function') {\n\t\t// tee instance body\n\t\tp1 = new PassThrough();\n\t\tp2 = new PassThrough();\n\t\tbody.pipe(p1);\n\t\tbody.pipe(p2);\n\t\t// set instance body to teed body and return the other teed body\n\t\tinstance[INTERNALS].body = p1;\n\t\tbody = p2;\n\t}\n\n\treturn body;\n}\n\n/**\n * Performs the operation \"extract a `Content-Type` value from |object|\" as\n * specified in the specification:\n * https://fetch.spec.whatwg.org/#concept-bodyinit-extract\n *\n * This function assumes that instance.body is present.\n *\n * @param   Mixed  instance  Any options.body input\n */\nfunction extractContentType(body) {\n\tif (body === null) {\n\t\t// body is null\n\t\treturn null;\n\t} else if (typeof body === 'string') {\n\t\t// body is string\n\t\treturn 'text/plain;charset=UTF-8';\n\t} else if (isURLSearchParams(body)) {\n\t\t// body is a URLSearchParams\n\t\treturn 'application/x-www-form-urlencoded;charset=UTF-8';\n\t} else if (isBlob(body)) {\n\t\t// body is blob\n\t\treturn body.type || null;\n\t} else if (Buffer.isBuffer(body)) {\n\t\t// body is buffer\n\t\treturn null;\n\t} else if (Object.prototype.toString.call(body) === '[object ArrayBuffer]') {\n\t\t// body is ArrayBuffer\n\t\treturn null;\n\t} else if (ArrayBuffer.isView(body)) {\n\t\t// body is ArrayBufferView\n\t\treturn null;\n\t} else if (typeof body.getBoundary === 'function') {\n\t\t// detect form data input from form-data module\n\t\treturn `multipart/form-data;boundary=${body.getBoundary()}`;\n\t} else if (body instanceof Stream) {\n\t\t// body is stream\n\t\t// can't really do much about this\n\t\treturn null;\n\t} else {\n\t\t// Body constructor defaults other things to string\n\t\treturn 'text/plain;charset=UTF-8';\n\t}\n}\n\n/**\n * The Fetch Standard treats this as if \"total bytes\" is a property on the body.\n * For us, we have to explicitly get it with a function.\n *\n * ref: https://fetch.spec.whatwg.org/#concept-body-total-bytes\n *\n * @param   Body    instance   Instance of Body\n * @return  Number?            Number of bytes, or null if not possible\n */\nfunction getTotalBytes(instance) {\n\tconst body = instance.body;\n\n\n\tif (body === null) {\n\t\t// body is null\n\t\treturn 0;\n\t} else if (isBlob(body)) {\n\t\treturn body.size;\n\t} else if (Buffer.isBuffer(body)) {\n\t\t// body is buffer\n\t\treturn body.length;\n\t} else if (body && typeof body.getLengthSync === 'function') {\n\t\t// detect form data input from form-data module\n\t\tif (body._lengthRetrievers && body._lengthRetrievers.length == 0 || // 1.x\n\t\tbody.hasKnownLength && body.hasKnownLength()) {\n\t\t\t// 2.x\n\t\t\treturn body.getLengthSync();\n\t\t}\n\t\treturn null;\n\t} else {\n\t\t// body is stream\n\t\treturn null;\n\t}\n}\n\n/**\n * Write a Body to a Node.js WritableStream (e.g. http.Request) object.\n *\n * @param   Body    instance   Instance of Body\n * @return  Void\n */\nfunction writeToStream(dest, instance) {\n\tconst body = instance.body;\n\n\n\tif (body === null) {\n\t\t// body is null\n\t\tdest.end();\n\t} else if (isBlob(body)) {\n\t\tbody.stream().pipe(dest);\n\t} else if (Buffer.isBuffer(body)) {\n\t\t// body is buffer\n\t\tdest.write(body);\n\t\tdest.end();\n\t} else {\n\t\t// body is stream\n\t\tbody.pipe(dest);\n\t}\n}\n\n// expose Promise\nBody.Promise = global.Promise;\n\n/**\n * headers.js\n *\n * Headers class offers convenient helpers\n */\n\nconst invalidTokenRegex = /[^\\^_`a-zA-Z\\-0-9!#$%&'*+.|~]/;\nconst invalidHeaderCharRegex = /[^\\t\\x20-\\x7e\\x80-\\xff]/;\n\nfunction validateName(name) {\n\tname = `${name}`;\n\tif (invalidTokenRegex.test(name) || name === '') {\n\t\tthrow new TypeError(`${name} is not a legal HTTP header name`);\n\t}\n}\n\nfunction validateValue(value) {\n\tvalue = `${value}`;\n\tif (invalidHeaderCharRegex.test(value)) {\n\t\tthrow new TypeError(`${value} is not a legal HTTP header value`);\n\t}\n}\n\n/**\n * Find the key in the map object given a header name.\n *\n * Returns undefined if not found.\n *\n * @param   String  name  Header name\n * @return  String|Undefined\n */\nfunction find(map, name) {\n\tname = name.toLowerCase();\n\tfor (const key in map) {\n\t\tif (key.toLowerCase() === name) {\n\t\t\treturn key;\n\t\t}\n\t}\n\treturn undefined;\n}\n\nconst MAP = Symbol('map');\nclass Headers {\n\t/**\n  * Headers class\n  *\n  * @param   Object  headers  Response headers\n  * @return  Void\n  */\n\tconstructor() {\n\t\tlet init = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;\n\n\t\tthis[MAP] = Object.create(null);\n\n\t\tif (init instanceof Headers) {\n\t\t\tconst rawHeaders = init.raw();\n\t\t\tconst headerNames = Object.keys(rawHeaders);\n\n\t\t\tfor (const headerName of headerNames) {\n\t\t\t\tfor (const value of rawHeaders[headerName]) {\n\t\t\t\t\tthis.append(headerName, value);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\t// We don't worry about converting prop to ByteString here as append()\n\t\t// will handle it.\n\t\tif (init == null) ; else if (typeof init === 'object') {\n\t\t\tconst method = init[Symbol.iterator];\n\t\t\tif (method != null) {\n\t\t\t\tif (typeof method !== 'function') {\n\t\t\t\t\tthrow new TypeError('Header pairs must be iterable');\n\t\t\t\t}\n\n\t\t\t\t// sequence<sequence<ByteString>>\n\t\t\t\t// Note: per spec we have to first exhaust the lists then process them\n\t\t\t\tconst pairs = [];\n\t\t\t\tfor (const pair of init) {\n\t\t\t\t\tif (typeof pair !== 'object' || typeof pair[Symbol.iterator] !== 'function') {\n\t\t\t\t\t\tthrow new TypeError('Each header pair must be iterable');\n\t\t\t\t\t}\n\t\t\t\t\tpairs.push(Array.from(pair));\n\t\t\t\t}\n\n\t\t\t\tfor (const pair of pairs) {\n\t\t\t\t\tif (pair.length !== 2) {\n\t\t\t\t\t\tthrow new TypeError('Each header pair must be a name/value tuple');\n\t\t\t\t\t}\n\t\t\t\t\tthis.append(pair[0], pair[1]);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// record<ByteString, ByteString>\n\t\t\t\tfor (const key of Object.keys(init)) {\n\t\t\t\t\tconst value = init[key];\n\t\t\t\t\tthis.append(key, value);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tthrow new TypeError('Provided initializer must be an object');\n\t\t}\n\t}\n\n\t/**\n  * Return combined header value given name\n  *\n  * @param   String  name  Header name\n  * @return  Mixed\n  */\n\tget(name) {\n\t\tname = `${name}`;\n\t\tvalidateName(name);\n\t\tconst key = find(this[MAP], name);\n\t\tif (key === undefined) {\n\t\t\treturn null;\n\t\t}\n\n\t\treturn this[MAP][key].join(', ');\n\t}\n\n\t/**\n  * Iterate over all headers\n  *\n  * @param   Function  callback  Executed for each item with parameters (value, name, thisArg)\n  * @param   Boolean   thisArg   `this` context for callback function\n  * @return  Void\n  */\n\tforEach(callback) {\n\t\tlet thisArg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n\n\t\tlet pairs = getHeaders(this);\n\t\tlet i = 0;\n\t\twhile (i < pairs.length) {\n\t\t\tvar _pairs$i = pairs[i];\n\t\t\tconst name = _pairs$i[0],\n\t\t\t      value = _pairs$i[1];\n\n\t\t\tcallback.call(thisArg, value, name, this);\n\t\t\tpairs = getHeaders(this);\n\t\t\ti++;\n\t\t}\n\t}\n\n\t/**\n  * Overwrite header values given name\n  *\n  * @param   String  name   Header name\n  * @param   String  value  Header value\n  * @return  Void\n  */\n\tset(name, value) {\n\t\tname = `${name}`;\n\t\tvalue = `${value}`;\n\t\tvalidateName(name);\n\t\tvalidateValue(value);\n\t\tconst key = find(this[MAP], name);\n\t\tthis[MAP][key !== undefined ? key : name] = [value];\n\t}\n\n\t/**\n  * Append a value onto existing header\n  *\n  * @param   String  name   Header name\n  * @param   String  value  Header value\n  * @return  Void\n  */\n\tappend(name, value) {\n\t\tname = `${name}`;\n\t\tvalue = `${value}`;\n\t\tvalidateName(name);\n\t\tvalidateValue(value);\n\t\tconst key = find(this[MAP], name);\n\t\tif (key !== undefined) {\n\t\t\tthis[MAP][key].push(value);\n\t\t} else {\n\t\t\tthis[MAP][name] = [value];\n\t\t}\n\t}\n\n\t/**\n  * Check for header name existence\n  *\n  * @param   String   name  Header name\n  * @return  Boolean\n  */\n\thas(name) {\n\t\tname = `${name}`;\n\t\tvalidateName(name);\n\t\treturn find(this[MAP], name) !== undefined;\n\t}\n\n\t/**\n  * Delete all header values given name\n  *\n  * @param   String  name  Header name\n  * @return  Void\n  */\n\tdelete(name) {\n\t\tname = `${name}`;\n\t\tvalidateName(name);\n\t\tconst key = find(this[MAP], name);\n\t\tif (key !== undefined) {\n\t\t\tdelete this[MAP][key];\n\t\t}\n\t}\n\n\t/**\n  * Return raw headers (non-spec api)\n  *\n  * @return  Object\n  */\n\traw() {\n\t\treturn this[MAP];\n\t}\n\n\t/**\n  * Get an iterator on keys.\n  *\n  * @return  Iterator\n  */\n\tkeys() {\n\t\treturn createHeadersIterator(this, 'key');\n\t}\n\n\t/**\n  * Get an iterator on values.\n  *\n  * @return  Iterator\n  */\n\tvalues() {\n\t\treturn createHeadersIterator(this, 'value');\n\t}\n\n\t/**\n  * Get an iterator on entries.\n  *\n  * This is the default iterator of the Headers object.\n  *\n  * @return  Iterator\n  */\n\t[Symbol.iterator]() {\n\t\treturn createHeadersIterator(this, 'key+value');\n\t}\n}\nHeaders.prototype.entries = Headers.prototype[Symbol.iterator];\n\nObject.defineProperty(Headers.prototype, Symbol.toStringTag, {\n\tvalue: 'Headers',\n\twritable: false,\n\tenumerable: false,\n\tconfigurable: true\n});\n\nObject.defineProperties(Headers.prototype, {\n\tget: { enumerable: true },\n\tforEach: { enumerable: true },\n\tset: { enumerable: true },\n\tappend: { enumerable: true },\n\thas: { enumerable: true },\n\tdelete: { enumerable: true },\n\tkeys: { enumerable: true },\n\tvalues: { enumerable: true },\n\tentries: { enumerable: true }\n});\n\nfunction getHeaders(headers) {\n\tlet kind = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'key+value';\n\n\tconst keys = Object.keys(headers[MAP]).sort();\n\treturn keys.map(kind === 'key' ? function (k) {\n\t\treturn k.toLowerCase();\n\t} : kind === 'value' ? function (k) {\n\t\treturn headers[MAP][k].join(', ');\n\t} : function (k) {\n\t\treturn [k.toLowerCase(), headers[MAP][k].join(', ')];\n\t});\n}\n\nconst INTERNAL = Symbol('internal');\n\nfunction createHeadersIterator(target, kind) {\n\tconst iterator = Object.create(HeadersIteratorPrototype);\n\titerator[INTERNAL] = {\n\t\ttarget,\n\t\tkind,\n\t\tindex: 0\n\t};\n\treturn iterator;\n}\n\nconst HeadersIteratorPrototype = Object.setPrototypeOf({\n\tnext() {\n\t\t// istanbul ignore if\n\t\tif (!this || Object.getPrototypeOf(this) !== HeadersIteratorPrototype) {\n\t\t\tthrow new TypeError('Value of `this` is not a HeadersIterator');\n\t\t}\n\n\t\tvar _INTERNAL = this[INTERNAL];\n\t\tconst target = _INTERNAL.target,\n\t\t      kind = _INTERNAL.kind,\n\t\t      index = _INTERNAL.index;\n\n\t\tconst values = getHeaders(target, kind);\n\t\tconst len = values.length;\n\t\tif (index >= len) {\n\t\t\treturn {\n\t\t\t\tvalue: undefined,\n\t\t\t\tdone: true\n\t\t\t};\n\t\t}\n\n\t\tthis[INTERNAL].index = index + 1;\n\n\t\treturn {\n\t\t\tvalue: values[index],\n\t\t\tdone: false\n\t\t};\n\t}\n}, Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]())));\n\nObject.defineProperty(HeadersIteratorPrototype, Symbol.toStringTag, {\n\tvalue: 'HeadersIterator',\n\twritable: false,\n\tenumerable: false,\n\tconfigurable: true\n});\n\n/**\n * Export the Headers object in a form that Node.js can consume.\n *\n * @param   Headers  headers\n * @return  Object\n */\nfunction exportNodeCompatibleHeaders(headers) {\n\tconst obj = Object.assign({ __proto__: null }, headers[MAP]);\n\n\t// http.request() only supports string as Host header. This hack makes\n\t// specifying custom Host header possible.\n\tconst hostHeaderKey = find(headers[MAP], 'Host');\n\tif (hostHeaderKey !== undefined) {\n\t\tobj[hostHeaderKey] = obj[hostHeaderKey][0];\n\t}\n\n\treturn obj;\n}\n\n/**\n * Create a Headers object from an object of headers, ignoring those that do\n * not conform to HTTP grammar productions.\n *\n * @param   Object  obj  Object of headers\n * @return  Headers\n */\nfunction createHeadersLenient(obj) {\n\tconst headers = new Headers();\n\tfor (const name of Object.keys(obj)) {\n\t\tif (invalidTokenRegex.test(name)) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (Array.isArray(obj[name])) {\n\t\t\tfor (const val of obj[name]) {\n\t\t\t\tif (invalidHeaderCharRegex.test(val)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (headers[MAP][name] === undefined) {\n\t\t\t\t\theaders[MAP][name] = [val];\n\t\t\t\t} else {\n\t\t\t\t\theaders[MAP][name].push(val);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (!invalidHeaderCharRegex.test(obj[name])) {\n\t\t\theaders[MAP][name] = [obj[name]];\n\t\t}\n\t}\n\treturn headers;\n}\n\nconst INTERNALS$1 = Symbol('Response internals');\n\n// fix an issue where \"STATUS_CODES\" aren't a named export for node <10\nconst STATUS_CODES = http.STATUS_CODES;\n\n/**\n * Response class\n *\n * @param   Stream  body  Readable stream\n * @param   Object  opts  Response options\n * @return  Void\n */\nclass Response {\n\tconstructor() {\n\t\tlet body = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\t\tlet opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n\t\tBody.call(this, body, opts);\n\n\t\tconst status = opts.status || 200;\n\t\tconst headers = new Headers(opts.headers);\n\n\t\tif (body != null && !headers.has('Content-Type')) {\n\t\t\tconst contentType = extractContentType(body);\n\t\t\tif (contentType) {\n\t\t\t\theaders.append('Content-Type', contentType);\n\t\t\t}\n\t\t}\n\n\t\tthis[INTERNALS$1] = {\n\t\t\turl: opts.url,\n\t\t\tstatus,\n\t\t\tstatusText: opts.statusText || STATUS_CODES[status],\n\t\t\theaders,\n\t\t\tcounter: opts.counter\n\t\t};\n\t}\n\n\tget url() {\n\t\treturn this[INTERNALS$1].url || '';\n\t}\n\n\tget status() {\n\t\treturn this[INTERNALS$1].status;\n\t}\n\n\t/**\n  * Convenience property representing if the request ended normally\n  */\n\tget ok() {\n\t\treturn this[INTERNALS$1].status >= 200 && this[INTERNALS$1].status < 300;\n\t}\n\n\tget redirected() {\n\t\treturn this[INTERNALS$1].counter > 0;\n\t}\n\n\tget statusText() {\n\t\treturn this[INTERNALS$1].statusText;\n\t}\n\n\tget headers() {\n\t\treturn this[INTERNALS$1].headers;\n\t}\n\n\t/**\n  * Clone this response\n  *\n  * @return  Response\n  */\n\tclone() {\n\t\treturn new Response(clone(this), {\n\t\t\turl: this.url,\n\t\t\tstatus: this.status,\n\t\t\tstatusText: this.statusText,\n\t\t\theaders: this.headers,\n\t\t\tok: this.ok,\n\t\t\tredirected: this.redirected\n\t\t});\n\t}\n}\n\nBody.mixIn(Response.prototype);\n\nObject.defineProperties(Response.prototype, {\n\turl: { enumerable: true },\n\tstatus: { enumerable: true },\n\tok: { enumerable: true },\n\tredirected: { enumerable: true },\n\tstatusText: { enumerable: true },\n\theaders: { enumerable: true },\n\tclone: { enumerable: true }\n});\n\nObject.defineProperty(Response.prototype, Symbol.toStringTag, {\n\tvalue: 'Response',\n\twritable: false,\n\tenumerable: false,\n\tconfigurable: true\n});\n\nconst INTERNALS$2 = Symbol('Request internals');\n\n// fix an issue where \"format\", \"parse\" aren't a named export for node <10\nconst parse_url = Url.parse;\nconst format_url = Url.format;\n\nconst streamDestructionSupported = 'destroy' in Stream.Readable.prototype;\n\n/**\n * Check if a value is an instance of Request.\n *\n * @param   Mixed   input\n * @return  Boolean\n */\nfunction isRequest(input) {\n\treturn typeof input === 'object' && typeof input[INTERNALS$2] === 'object';\n}\n\nfunction isAbortSignal(signal) {\n\tconst proto = signal && typeof signal === 'object' && Object.getPrototypeOf(signal);\n\treturn !!(proto && proto.constructor.name === 'AbortSignal');\n}\n\n/**\n * Request class\n *\n * @param   Mixed   input  Url or Request instance\n * @param   Object  init   Custom options\n * @return  Void\n */\nclass Request {\n\tconstructor(input) {\n\t\tlet init = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n\t\tlet parsedURL;\n\n\t\t// normalize input\n\t\tif (!isRequest(input)) {\n\t\t\tif (input && input.href) {\n\t\t\t\t// in order to support Node.js' Url objects; though WHATWG's URL objects\n\t\t\t\t// will fall into this branch also (since their `toString()` will return\n\t\t\t\t// `href` property anyway)\n\t\t\t\tparsedURL = parse_url(input.href);\n\t\t\t} else {\n\t\t\t\t// coerce input to a string before attempting to parse\n\t\t\t\tparsedURL = parse_url(`${input}`);\n\t\t\t}\n\t\t\tinput = {};\n\t\t} else {\n\t\t\tparsedURL = parse_url(input.url);\n\t\t}\n\n\t\tlet method = init.method || input.method || 'GET';\n\t\tmethod = method.toUpperCase();\n\n\t\tif ((init.body != null || isRequest(input) && input.body !== null) && (method === 'GET' || method === 'HEAD')) {\n\t\t\tthrow new TypeError('Request with GET/HEAD method cannot have body');\n\t\t}\n\n\t\tlet inputBody = init.body != null ? init.body : isRequest(input) && input.body !== null ? clone(input) : null;\n\n\t\tBody.call(this, inputBody, {\n\t\t\ttimeout: init.timeout || input.timeout || 0,\n\t\t\tsize: init.size || input.size || 0\n\t\t});\n\n\t\tconst headers = new Headers(init.headers || input.headers || {});\n\n\t\tif (inputBody != null && !headers.has('Content-Type')) {\n\t\t\tconst contentType = extractContentType(inputBody);\n\t\t\tif (contentType) {\n\t\t\t\theaders.append('Content-Type', contentType);\n\t\t\t}\n\t\t}\n\n\t\tlet signal = isRequest(input) ? input.signal : null;\n\t\tif ('signal' in init) signal = init.signal;\n\n\t\tif (signal != null && !isAbortSignal(signal)) {\n\t\t\tthrow new TypeError('Expected signal to be an instanceof AbortSignal');\n\t\t}\n\n\t\tthis[INTERNALS$2] = {\n\t\t\tmethod,\n\t\t\tredirect: init.redirect || input.redirect || 'follow',\n\t\t\theaders,\n\t\t\tparsedURL,\n\t\t\tsignal\n\t\t};\n\n\t\t// node-fetch-only options\n\t\tthis.follow = init.follow !== undefined ? init.follow : input.follow !== undefined ? input.follow : 20;\n\t\tthis.compress = init.compress !== undefined ? init.compress : input.compress !== undefined ? input.compress : true;\n\t\tthis.counter = init.counter || input.counter || 0;\n\t\tthis.agent = init.agent || input.agent;\n\t}\n\n\tget method() {\n\t\treturn this[INTERNALS$2].method;\n\t}\n\n\tget url() {\n\t\treturn format_url(this[INTERNALS$2].parsedURL);\n\t}\n\n\tget headers() {\n\t\treturn this[INTERNALS$2].headers;\n\t}\n\n\tget redirect() {\n\t\treturn this[INTERNALS$2].redirect;\n\t}\n\n\tget signal() {\n\t\treturn this[INTERNALS$2].signal;\n\t}\n\n\t/**\n  * Clone this request\n  *\n  * @return  Request\n  */\n\tclone() {\n\t\treturn new Request(this);\n\t}\n}\n\nBody.mixIn(Request.prototype);\n\nObject.defineProperty(Request.prototype, Symbol.toStringTag, {\n\tvalue: 'Request',\n\twritable: false,\n\tenumerable: false,\n\tconfigurable: true\n});\n\nObject.defineProperties(Request.prototype, {\n\tmethod: { enumerable: true },\n\turl: { enumerable: true },\n\theaders: { enumerable: true },\n\tredirect: { enumerable: true },\n\tclone: { enumerable: true },\n\tsignal: { enumerable: true }\n});\n\n/**\n * Convert a Request to Node.js http request options.\n *\n * @param   Request  A Request instance\n * @return  Object   The options object to be passed to http.request\n */\nfunction getNodeRequestOptions(request) {\n\tconst parsedURL = request[INTERNALS$2].parsedURL;\n\tconst headers = new Headers(request[INTERNALS$2].headers);\n\n\t// fetch step 1.3\n\tif (!headers.has('Accept')) {\n\t\theaders.set('Accept', '*/*');\n\t}\n\n\t// Basic fetch\n\tif (!parsedURL.protocol || !parsedURL.hostname) {\n\t\tthrow new TypeError('Only absolute URLs are supported');\n\t}\n\n\tif (!/^https?:$/.test(parsedURL.protocol)) {\n\t\tthrow new TypeError('Only HTTP(S) protocols are supported');\n\t}\n\n\tif (request.signal && request.body instanceof Stream.Readable && !streamDestructionSupported) {\n\t\tthrow new Error('Cancellation of streamed requests with AbortSignal is not supported in node < 8');\n\t}\n\n\t// HTTP-network-or-cache fetch steps 2.4-2.7\n\tlet contentLengthValue = null;\n\tif (request.body == null && /^(POST|PUT)$/i.test(request.method)) {\n\t\tcontentLengthValue = '0';\n\t}\n\tif (request.body != null) {\n\t\tconst totalBytes = getTotalBytes(request);\n\t\tif (typeof totalBytes === 'number') {\n\t\t\tcontentLengthValue = String(totalBytes);\n\t\t}\n\t}\n\tif (contentLengthValue) {\n\t\theaders.set('Content-Length', contentLengthValue);\n\t}\n\n\t// HTTP-network-or-cache fetch step 2.11\n\tif (!headers.has('User-Agent')) {\n\t\theaders.set('User-Agent', 'node-fetch/1.0 (+https://github.com/bitinn/node-fetch)');\n\t}\n\n\t// HTTP-network-or-cache fetch step 2.15\n\tif (request.compress && !headers.has('Accept-Encoding')) {\n\t\theaders.set('Accept-Encoding', 'gzip,deflate');\n\t}\n\n\tlet agent = request.agent;\n\tif (typeof agent === 'function') {\n\t\tagent = agent(parsedURL);\n\t}\n\n\tif (!headers.has('Connection') && !agent) {\n\t\theaders.set('Connection', 'close');\n\t}\n\n\t// HTTP-network fetch step 4.2\n\t// chunked encoding is handled by Node.js\n\n\treturn Object.assign({}, parsedURL, {\n\t\tmethod: request.method,\n\t\theaders: exportNodeCompatibleHeaders(headers),\n\t\tagent\n\t});\n}\n\n/**\n * abort-error.js\n *\n * AbortError interface for cancelled requests\n */\n\n/**\n * Create AbortError instance\n *\n * @param   String      message      Error message for human\n * @return  AbortError\n */\nfunction AbortError(message) {\n  Error.call(this, message);\n\n  this.type = 'aborted';\n  this.message = message;\n\n  // hide custom error implementation details from end-users\n  Error.captureStackTrace(this, this.constructor);\n}\n\nAbortError.prototype = Object.create(Error.prototype);\nAbortError.prototype.constructor = AbortError;\nAbortError.prototype.name = 'AbortError';\n\n// fix an issue where \"PassThrough\", \"resolve\" aren't a named export for node <10\nconst PassThrough$1 = Stream.PassThrough;\nconst resolve_url = Url.resolve;\n\n/**\n * Fetch function\n *\n * @param   Mixed    url   Absolute url or Request instance\n * @param   Object   opts  Fetch options\n * @return  Promise\n */\nfunction fetch(url, opts) {\n\n\t// allow custom promise\n\tif (!fetch.Promise) {\n\t\tthrow new Error('native promise missing, set fetch.Promise to your favorite alternative');\n\t}\n\n\tBody.Promise = fetch.Promise;\n\n\t// wrap http.request into fetch\n\treturn new fetch.Promise(function (resolve, reject) {\n\t\t// build request object\n\t\tconst request = new Request(url, opts);\n\t\tconst options = getNodeRequestOptions(request);\n\n\t\tconst send = (options.protocol === 'https:' ? https : http).request;\n\t\tconst signal = request.signal;\n\n\t\tlet response = null;\n\n\t\tconst abort = function abort() {\n\t\t\tlet error = new AbortError('The user aborted a request.');\n\t\t\treject(error);\n\t\t\tif (request.body && request.body instanceof Stream.Readable) {\n\t\t\t\trequest.body.destroy(error);\n\t\t\t}\n\t\t\tif (!response || !response.body) return;\n\t\t\tresponse.body.emit('error', error);\n\t\t};\n\n\t\tif (signal && signal.aborted) {\n\t\t\tabort();\n\t\t\treturn;\n\t\t}\n\n\t\tconst abortAndFinalize = function abortAndFinalize() {\n\t\t\tabort();\n\t\t\tfinalize();\n\t\t};\n\n\t\t// send request\n\t\tconst req = send(options);\n\t\tlet reqTimeout;\n\n\t\tif (signal) {\n\t\t\tsignal.addEventListener('abort', abortAndFinalize);\n\t\t}\n\n\t\tfunction finalize() {\n\t\t\treq.abort();\n\t\t\tif (signal) signal.removeEventListener('abort', abortAndFinalize);\n\t\t\tclearTimeout(reqTimeout);\n\t\t}\n\n\t\tif (request.timeout) {\n\t\t\treq.once('socket', function (socket) {\n\t\t\t\treqTimeout = setTimeout(function () {\n\t\t\t\t\treject(new FetchError(`network timeout at: ${request.url}`, 'request-timeout'));\n\t\t\t\t\tfinalize();\n\t\t\t\t}, request.timeout);\n\t\t\t});\n\t\t}\n\n\t\treq.on('error', function (err) {\n\t\t\treject(new FetchError(`request to ${request.url} failed, reason: ${err.message}`, 'system', err));\n\t\t\tfinalize();\n\t\t});\n\n\t\treq.on('response', function (res) {\n\t\t\tclearTimeout(reqTimeout);\n\n\t\t\tconst headers = createHeadersLenient(res.headers);\n\n\t\t\t// HTTP fetch step 5\n\t\t\tif (fetch.isRedirect(res.statusCode)) {\n\t\t\t\t// HTTP fetch step 5.2\n\t\t\t\tconst location = headers.get('Location');\n\n\t\t\t\t// HTTP fetch step 5.3\n\t\t\t\tconst locationURL = location === null ? null : resolve_url(request.url, location);\n\n\t\t\t\t// HTTP fetch step 5.5\n\t\t\t\tswitch (request.redirect) {\n\t\t\t\t\tcase 'error':\n\t\t\t\t\t\treject(new FetchError(`redirect mode is set to error: ${request.url}`, 'no-redirect'));\n\t\t\t\t\t\tfinalize();\n\t\t\t\t\t\treturn;\n\t\t\t\t\tcase 'manual':\n\t\t\t\t\t\t// node-fetch-specific step: make manual redirect a bit easier to use by setting the Location header value to the resolved URL.\n\t\t\t\t\t\tif (locationURL !== null) {\n\t\t\t\t\t\t\t// handle corrupted header\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\theaders.set('Location', locationURL);\n\t\t\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\t\t\t// istanbul ignore next: nodejs server prevent invalid response headers, we can't test this through normal request\n\t\t\t\t\t\t\t\treject(err);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'follow':\n\t\t\t\t\t\t// HTTP-redirect fetch step 2\n\t\t\t\t\t\tif (locationURL === null) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// HTTP-redirect fetch step 5\n\t\t\t\t\t\tif (request.counter >= request.follow) {\n\t\t\t\t\t\t\treject(new FetchError(`maximum redirect reached at: ${request.url}`, 'max-redirect'));\n\t\t\t\t\t\t\tfinalize();\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// HTTP-redirect fetch step 6 (counter increment)\n\t\t\t\t\t\t// Create a new Request object.\n\t\t\t\t\t\tconst requestOpts = {\n\t\t\t\t\t\t\theaders: new Headers(request.headers),\n\t\t\t\t\t\t\tfollow: request.follow,\n\t\t\t\t\t\t\tcounter: request.counter + 1,\n\t\t\t\t\t\t\tagent: request.agent,\n\t\t\t\t\t\t\tcompress: request.compress,\n\t\t\t\t\t\t\tmethod: request.method,\n\t\t\t\t\t\t\tbody: request.body,\n\t\t\t\t\t\t\tsignal: request.signal,\n\t\t\t\t\t\t\ttimeout: request.timeout\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\t// HTTP-redirect fetch step 9\n\t\t\t\t\t\tif (res.statusCode !== 303 && request.body && getTotalBytes(request) === null) {\n\t\t\t\t\t\t\treject(new FetchError('Cannot follow redirect with body being a readable stream', 'unsupported-redirect'));\n\t\t\t\t\t\t\tfinalize();\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// HTTP-redirect fetch step 11\n\t\t\t\t\t\tif (res.statusCode === 303 || (res.statusCode === 301 || res.statusCode === 302) && request.method === 'POST') {\n\t\t\t\t\t\t\trequestOpts.method = 'GET';\n\t\t\t\t\t\t\trequestOpts.body = undefined;\n\t\t\t\t\t\t\trequestOpts.headers.delete('content-length');\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// HTTP-redirect fetch step 15\n\t\t\t\t\t\tresolve(fetch(new Request(locationURL, requestOpts)));\n\t\t\t\t\t\tfinalize();\n\t\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// prepare response\n\t\t\tres.once('end', function () {\n\t\t\t\tif (signal) signal.removeEventListener('abort', abortAndFinalize);\n\t\t\t});\n\t\t\tlet body = res.pipe(new PassThrough$1());\n\n\t\t\tconst response_options = {\n\t\t\t\turl: request.url,\n\t\t\t\tstatus: res.statusCode,\n\t\t\t\tstatusText: res.statusMessage,\n\t\t\t\theaders: headers,\n\t\t\t\tsize: request.size,\n\t\t\t\ttimeout: request.timeout,\n\t\t\t\tcounter: request.counter\n\t\t\t};\n\n\t\t\t// HTTP-network fetch step 12.1.1.3\n\t\t\tconst codings = headers.get('Content-Encoding');\n\n\t\t\t// HTTP-network fetch step 12.1.1.4: handle content codings\n\n\t\t\t// in following scenarios we ignore compression support\n\t\t\t// 1. compression support is disabled\n\t\t\t// 2. HEAD request\n\t\t\t// 3. no Content-Encoding header\n\t\t\t// 4. no content response (204)\n\t\t\t// 5. content not modified response (304)\n\t\t\tif (!request.compress || request.method === 'HEAD' || codings === null || res.statusCode === 204 || res.statusCode === 304) {\n\t\t\t\tresponse = new Response(body, response_options);\n\t\t\t\tresolve(response);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// For Node v6+\n\t\t\t// Be less strict when decoding compressed responses, since sometimes\n\t\t\t// servers send slightly invalid responses that are still accepted\n\t\t\t// by common browsers.\n\t\t\t// Always using Z_SYNC_FLUSH is what cURL does.\n\t\t\tconst zlibOptions = {\n\t\t\t\tflush: zlib.Z_SYNC_FLUSH,\n\t\t\t\tfinishFlush: zlib.Z_SYNC_FLUSH\n\t\t\t};\n\n\t\t\t// for gzip\n\t\t\tif (codings == 'gzip' || codings == 'x-gzip') {\n\t\t\t\tbody = body.pipe(zlib.createGunzip(zlibOptions));\n\t\t\t\tresponse = new Response(body, response_options);\n\t\t\t\tresolve(response);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// for deflate\n\t\t\tif (codings == 'deflate' || codings == 'x-deflate') {\n\t\t\t\t// handle the infamous raw deflate response from old servers\n\t\t\t\t// a hack for old IIS and Apache servers\n\t\t\t\tconst raw = res.pipe(new PassThrough$1());\n\t\t\t\traw.once('data', function (chunk) {\n\t\t\t\t\t// see http://stackoverflow.com/questions/37519828\n\t\t\t\t\tif ((chunk[0] & 0x0F) === 0x08) {\n\t\t\t\t\t\tbody = body.pipe(zlib.createInflate());\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbody = body.pipe(zlib.createInflateRaw());\n\t\t\t\t\t}\n\t\t\t\t\tresponse = new Response(body, response_options);\n\t\t\t\t\tresolve(response);\n\t\t\t\t});\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// for br\n\t\t\tif (codings == 'br' && typeof zlib.createBrotliDecompress === 'function') {\n\t\t\t\tbody = body.pipe(zlib.createBrotliDecompress());\n\t\t\t\tresponse = new Response(body, response_options);\n\t\t\t\tresolve(response);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// otherwise, use response as-is\n\t\t\tresponse = new Response(body, response_options);\n\t\t\tresolve(response);\n\t\t});\n\n\t\twriteToStream(req, request);\n\t});\n}\n/**\n * Redirect code matching\n *\n * @param   Number   code  Status code\n * @return  Boolean\n */\nfetch.isRedirect = function (code) {\n\treturn code === 301 || code === 302 || code === 303 || code === 307 || code === 308;\n};\n\n// expose Promise\nfetch.Promise = global.Promise;\n\nexport default fetch;\nexport { Headers, Request, Response, FetchError };\n","export enum CacheControlType {\n\tPublic = 'public', // The response may be stored by any cache, even if the response is normally non-cacheable.\n\tPrivate = 'private', // The response may be stored only by a browser's cache, even if the response is normally non-cacheable. If you mean to not store the response in any cache, use no-store instead. This directive is not effective in preventing caches from storing your response.\n\tNoCache = 'no-cache', // The response may be stored by any cache, even if the response is normally non-cacheable. However, the stored response MUST always go through validation with the origin server first before using it, therefore, you cannot use no-cache in-conjunction with immutable. If you mean to not store the response in any cache, use no-store instead. This directive is not effective in preventing caches from storing your response.\n\tNoStore = 'no-store', // The response may not be stored in any cache. Although other directives may be set, this alone is the only directive you need in preventing cached responses on modern browsers. max-age=0 is already implied. Setting must-revalidate does not make sense because in order to go through revalidation you need the response to be stored in a cache, which no-store prevents.\n}\n\nexport interface ICacheItem {\n\tvalue: any;\n\tdate?: Date,\n\tmaxAge?: number;\n\tcacheControl?: CacheControlType;\n}\n\nexport class CacheItem {\n\tvalue: any;\n\tdate!: Date;\n\tmaxAge: number = 0;\n\tcacheControl: CacheControlType = CacheControlType.Public;\n\tget expired(): boolean {\n\t\treturn this.cacheControl === CacheControlType.NoStore\n\t\t\t|| this.maxAge === 0\n\t\t\t|| (this.date.getTime() + (this.maxAge * 1000) < Date.now());\n\t}\n\tconstructor(options?: ICacheItem) {\n\t\tif (options) {\n\t\t\tObject.assign(this, options);\n\t\t}\n\t}\n\tset(options?: ICacheItem): CacheItem {\n\t\tif (options) {\n\t\t\tObject.assign(this, options);\n\t\t}\n\t\tthis.date = new Date();\n\t\treturn this;\n\t}\n}\n\nexport default class CacheService {\n\n\tprivate static cache_: Map<string, CacheItem> = new Map<string, CacheItem>();\n\n\tstatic delete(type: string = 'cache', name: string): void {\n\t\tconst key: string = `${type}_${name}`;\n\t\tif (this.cache_.has(key)) {\n\t\t\tthis.cache_.delete(key);\n\t\t}\n\t}\n\n\tstatic has(type: string = 'cache', name: string): boolean {\n\t\tconst key: string = `${type}_${name}`;\n\t\treturn this.cache_.has(key);\n\t}\n\n\tstatic get(type: string = 'cache', name: string): any {\n\t\tlet value = null;\n\t\tconst key: string = `${type}_${name}`;\n\t\tif (this.cache_.has(key)) {\n\t\t\tconst cacheItem: CacheItem = this.cache_.get(key) as CacheItem;\n\t\t\tif (cacheItem) {\n\t\t\t\tif (cacheItem.expired) {\n\t\t\t\t\tthis.cache_.delete(key);\n\t\t\t\t} else {\n\t\t\t\t\tvalue = JSON.parse(cacheItem.value);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn value;\n\t}\n\n\tstatic set(type: string = 'cache', name: string, value: any, maxAge: number = 0): any {\n\t\tconst key: string = `${type}_${name}`;\n\t\tconst cacheItem: CacheItem = new CacheItem().set({ value: JSON.stringify(value, null, 0), maxAge });\n\t\tthis.cache_.set(key, cacheItem);\n\t\treturn value;\n\t}\n\n}\n\n/*\nCache-Control: max-age=0, private, must-revalidate\nDate: Fri, 14 Aug 2020 20:09:02 GMT\nExpect-CT: max-age=2592000, report-uri=\"https://api.github.com/_private/browser/errors\"\nStatus: 200 OK\nStrict-Transport-Security: max-age=31536000; includeSubdomains; preload\nCache-Control: no-cache\nConnection: keep-alive\nPragma: no-cache\n*/\n","var nodeFetch = require('node-fetch')\nvar realFetch = nodeFetch.default || nodeFetch\n\nvar fetch = function (url, options) {\n  // Support schemaless URIs on the server for parity with the browser.\n  // Ex: //github.com/ -> https://github.com/\n  if (/^\\/\\//.test(url)) {\n    url = 'https:' + url\n  }\n  return realFetch.call(this, url, options)\n}\n\nmodule.exports = exports = fetch\nexports.fetch = fetch\nexports.Headers = nodeFetch.Headers\nexports.Request = nodeFetch.Request\nexports.Response = nodeFetch.Response\n\n// Needed for TypeScript consumers without esModuleInterop.\nexports.default = fetch\n","var fetchNode = require('./node-ponyfill')\nvar fetch = fetchNode.fetch.bind({})\n\nfetch.polyfill = true\n\nif (!global.fetch) {\n  global.fetch = fetch\n  global.Response = fetchNode.Response\n  global.Headers = fetchNode.Headers\n  global.Request = fetchNode.Request\n}\n","import { Parser } from 'htmlparser2';\n\n// export const NO_CHILDS = ['title','base','meta','link','img','br','input',];\n// const SKIP = ['html','head','title','base','meta','script','link','body',];\n// document.createComment = nodeValue => { return new RxComment(null, nodeValue); };\n// document.createTextNode = nodeValue => { return new RxText(null, nodeValue); };\n\nexport enum RxNodeType {\n\tELEMENT_NODE = 1, //\tUn nodo Element come <p> o <div>.\n\tTEXT_NODE = 3, //\tL'attuale Text dentro un Element o Attr.\n\tCDATA_SECTION_NODE = 4, //\tUna CDATASection, ad esempio <!CDATA[[ … ]]>.\n\tPROCESSING_INSTRUCTION_NODE = 7, //\tUna ProcessingInstruction di un documento XML, come <?xml-stylesheet … ?>.\n\tCOMMENT_NODE = 8, //\tUn nodo Comment, come <!-- … -->.\n\tDOCUMENT_NODE = 9, //\tUn nodo Document.\n\tDOCUMENT_TYPE_NODE = 10, //\tUn nodo DocumentType, come <!DOCTYPE html>.\n\tDOCUMENT_FRAGMENT_NODE = 11, //\tUn nodo DocumentFragment.\n}\n\nexport enum SelectorType {\n\tNone = -1,\n\tId = 0,\n\tClass = 1,\n\tAttribute = 2,\n\tTagName = 3,\n}\n\nexport function isRxElement(x: RxNode): x is RxElement {\n\treturn x.nodeType === RxNodeType.ELEMENT_NODE;\n}\n\nexport function isRxText(x: RxNode): x is RxText {\n\treturn x.nodeType === RxNodeType.TEXT_NODE;\n}\n\nexport function isRxComment(x: RxNode): x is RxComment {\n\treturn x.nodeType === RxNodeType.COMMENT_NODE;\n}\n\nexport function isRxDocument(x: RxNode): x is RxDocument {\n\treturn x.nodeType === RxNodeType.DOCUMENT_NODE;\n}\n\nexport function isRxDocumentFragment(x: RxNode): x is RxDocumentFragment {\n\treturn x.nodeType === RxNodeType.DOCUMENT_FRAGMENT_NODE;\n}\n\nexport function isRxDocumentType(x: RxNode): x is RxDocumentType {\n\treturn x.nodeType === RxNodeType.DOCUMENT_TYPE_NODE;\n}\n\nexport function isRxProcessingInstruction(x: RxNode): x is RxProcessingInstruction {\n\treturn x.nodeType === RxNodeType.PROCESSING_INSTRUCTION_NODE;\n}\n\nexport function parse(html: string) {\n\tconst doc = new RxDocument();\n\tlet parentNode: RxElement = doc,\n\t\tnode;\n\tconst parser = new Parser(\n\t\t{\n\t\t\tonopentag: (nodeName, attributes) => {\n\t\t\t\t// console.log(nodeName);\n\t\t\t\tnode = new RxElement(parentNode, nodeName, attributes);\n\t\t\t\tparentNode.childNodes.push(node);\n\t\t\t\tparentNode = node;\n\t\t\t\t// if (NO_CHILDS.indexOf(nodeName) === -1) {\n\t\t\t\t//\tconsole.log(nodeName);\n\t\t\t\t//\tparentNode = node;\n\t\t\t\t// }\n\t\t\t},\n\t\t\tonclosetag: (nodeName) => {\n\t\t\t\tif (parentNode.parentNode) {\n\t\t\t\t\tparentNode = parentNode.parentNode;\n\t\t\t\t}\n\t\t\t},\n\t\t\tontext: (nodeValue) => {\n\t\t\t\t// console.log('ontext', nodeValue);\n\t\t\t\t// if (nodeValue.length) {\n\t\t\t\tconst textNode = new RxText(parentNode, nodeValue);\n\t\t\t\tparentNode.childNodes.push(textNode);\n\t\t\t\t// }\n\t\t\t},\n\t\t\tonprocessinginstruction: (nodeName, nodeValue) => {\n\t\t\t\t// console.log('onprocessinginstruction', nodeName, nodeValue);\n\t\t\t\tif (nodeName === '!doctype') {\n\t\t\t\t\tnode = new RxDocumentType(parentNode, nodeValue);\n\t\t\t\t} else {\n\t\t\t\t\tnode = new RxProcessingInstruction(parentNode, nodeValue);\n\t\t\t\t}\n\t\t\t\tparentNode.childNodes.push(node);\n\t\t\t},\n\t\t\toncomment: nodeValue => {\n\t\t\t\t// console.log('oncomment', nodeValue);\n\t\t\t\tnode = new RxComment(parentNode, nodeValue);\n\t\t\t\tparentNode.childNodes.push(node);\n\t\t\t\t// parentNode = node;\n\t\t\t},\n\t\t\toncommentend: () => {\n\t\t\t\t// console.log('oncommentend');\n\t\t\t\t// parentNode = parentNode.parentNode;\n\t\t\t},\n\t\t\toncdatastart: () => {\n\t\t\t\tconsole.log('oncdatastart');\n\t\t\t},\n\t\t\toncdataend: () => {\n\t\t\t\tconsole.log('oncdataend');\n\t\t\t},\n\t\t\tonerror: error => {\n\t\t\t\tconsole.log('error', error);\n\t\t\t},\n\t\t\t/*\n\t\t\tonopentagname: (name) => {\n\t\t\t\tconsole.log('onopentagname', name);\n\t\t\t},\n\t\t\tonattribute: (name, value) => {\n\t\t\t\tconsole.log('onattribute', name, value);\n\t\t\t},\n\t\t\tonreset: () => {\n\t\t\t\tconsole.log('reset');\n\t\t\t},\n\t\t\tonend: () => {\n\t\t\t\tconsole.log('end');\n\t\t\t},\n\t\t\t*/\n\t\t},\n\t\t{\n\t\t\tdecodeEntities: false,\n\t\t\tlowerCaseTags: true,\n\t\t}\n\t);\n\tparser.write(html);\n\tparser.end();\n\treturn doc;\n}\n\nexport function getQueries(selector: string): RxQuery[] {\n\tconst queries: RxQuery[] = [];\n\tselector\n\t\t.trim()\n\t\t.split(' ')\n\t\t.forEach((x: string) => {\n\t\t\tx.trim()\n\t\t\t\t.split('>')\n\t\t\t\t.forEach((x, i) => {\n\t\t\t\t\t// const regex = /\\.([^\\.[]+)|\\[([^\\.\\[]+)\\]|([^\\.\\[\\]]+)/g;\n\t\t\t\t\t// const regex = /\\#([^\\.[#]+)|\\.([^\\.[#]+)|\\[([^\\.\\[#]+)\\]|([^\\.\\[#\\]]+)/g;\n\t\t\t\t\tconst regex = /\\:not\\(\\#([^\\.[#:]+)\\)|\\:not\\(\\.([^\\.[#:]+)\\)|\\:not\\(\\[([^\\.\\[#:]+)\\]\\)|\\:not\\(([^\\.\\[#:\\]]+)\\)|\\#([^\\.[#:]+)|\\.([^\\.[#:]+)|\\[([^\\.\\[#:]+)\\]|([^\\.\\[#:\\]]+)/g;\n\t\t\t\t\t/* eslint no-useless-escape: \"off\" */\n\t\t\t\t\tconst selectors = [];\n\t\t\t\t\tconst matches = x.matchAll(regex);\n\t\t\t\t\tfor (const match of matches) {\n\t\t\t\t\t\tif (match[1]) {\n\t\t\t\t\t\t\tselectors.push({ selector: match[1], type: SelectorType.Id, negate: true });\n\t\t\t\t\t\t} else if (match[2]) {\n\t\t\t\t\t\t\tselectors.push({ selector: match[2], type: SelectorType.Class, negate: true });\n\t\t\t\t\t\t} else if (match[3]) {\n\t\t\t\t\t\t\tselectors.push({ selector: match[3], type: SelectorType.Attribute, negate: true });\n\t\t\t\t\t\t} else if (match[4]) {\n\t\t\t\t\t\t\tselectors.push({ selector: match[4], type: SelectorType.TagName, negate: true });\n\t\t\t\t\t\t} else if (match[5]) {\n\t\t\t\t\t\t\tselectors.push({ selector: match[5], type: SelectorType.Id, negate: false });\n\t\t\t\t\t\t} else if (match[6]) {\n\t\t\t\t\t\t\tselectors.push({ selector: match[6], type: SelectorType.Class, negate: false });\n\t\t\t\t\t\t} else if (match[7]) {\n\t\t\t\t\t\t\tselectors.push({ selector: match[7], type: SelectorType.Attribute, negate: false });\n\t\t\t\t\t\t} else if (match[8]) {\n\t\t\t\t\t\t\tselectors.push({ selector: match[8], type: SelectorType.TagName, negate: false });\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// console.log('match', match);\n\t\t\t\t\t}\n\t\t\t\t\tconst selector =\n\t\t\t\t\t\ti > 0\n\t\t\t\t\t\t\t? { selector: x, selectors, inner: true }\n\t\t\t\t\t\t\t: { selector: x, selectors, inner: false };\n\t\t\t\t\tqueries.push.call(queries, selector);\n\t\t\t\t});\n\t\t});\n\treturn queries;\n}\n\nexport function matchSelector(child: RxElement, selector: RxSelector): boolean {\n\tswitch (selector.type) {\n\t\tcase SelectorType.Id:\n\t\t\treturn (selector.selector !== '' && child.attributes.id === selector.selector) !== selector.negate;\n\t\tcase SelectorType.Class:\n\t\t\treturn (child.classList.indexOf(selector.selector) !== -1) !== selector.negate;\n\t\tcase SelectorType.Attribute:\n\t\t\treturn (Object.keys(child.attributes).indexOf(selector.selector) !== -1) !== selector.negate;\n\t\tcase SelectorType.TagName:\n\t\t\treturn (child.nodeName === selector.selector) !== selector.negate;\n\t\tdefault:\n\t\t\treturn false;\n\t}\n}\n\nexport function matchSelectors(child: RxElement, selectors: RxSelector[]): boolean {\n\treturn selectors.reduce(function (p: boolean, selector: RxSelector) {\n\t\treturn p && matchSelector(child, selector);\n\t}, true);\n}\n\nexport function querySelectorAll(queries: RxQuery[], childNodes: RxNode[], query: RxQuery | null = null, nodes: RxElement[] = []): RxElement[] | null {\n\tif (query || queries.length) {\n\t\tquery = query || queries.shift() as RxQuery;\n\t\tfor (let child of childNodes) {\n\t\t\tif (child instanceof RxElement) {\n\t\t\t\tif (matchSelectors(child, query.selectors)) {\n\t\t\t\t\t// console.log(query);\n\t\t\t\t\tif (queries.length) {\n\t\t\t\t\t\tconst results: RxElement[] | null = querySelectorAll(queries, child.childNodes);\n\t\t\t\t\t\tif (results) {\n\t\t\t\t\t\t\tArray.prototype.push.apply(nodes, results);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnodes.push(child);\n\t\t\t\t\t}\n\t\t\t\t} else if (!query.inner) {\n\t\t\t\t\tconst results: RxElement[] | null = querySelectorAll(queries, child.childNodes, query);\n\t\t\t\t\tif (results) {\n\t\t\t\t\t\tArray.prototype.push.apply(nodes, results);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn nodes.length ? nodes : null;\n}\n\nexport function querySelector(queries: RxQuery[], childNodes: RxNode[], query: RxQuery | null = null): RxElement | null {\n\tlet node = null;\n\tif (query || queries.length) {\n\t\tquery = query || queries.shift() as RxQuery;\n\t\tfor (let child of childNodes) {\n\t\t\tif (child instanceof RxElement) {\n\t\t\t\tif (matchSelectors(child, query.selectors)) {\n\t\t\t\t\t// console.log(query);\n\t\t\t\t\tif (queries.length) {\n\t\t\t\t\t\treturn querySelector(queries, child.childNodes);\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn child;\n\t\t\t\t\t}\n\t\t\t\t} else if (!query.inner) {\n\t\t\t\t\tnode = querySelector(queries, child.childNodes, query);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn node;\n}\n\nexport function cloneNode(source: RxNode, deep: boolean = false, parentNode: RxElement | null = null): RxNode {\n\tlet node: RxNode;\n\tif (isRxElement(source)) {\n\t\tconst nodeElement: RxElement = new RxElement(\n\t\t\tparentNode,\n\t\t\tsource.nodeName,\n\t\t\tObject.assign({}, source.attributes),\n\t\t);\n\t\tif (deep) {\n\t\t\tnodeElement.childNodes = source.childNodes.map(x => cloneNode.apply(x, [x, deep, nodeElement]));\n\t\t}\n\t\tnode = nodeElement;\n\t} else if (isRxDocumentFragment(source)) {\n\t\tconst nodeDocumentFragment: RxDocumentFragment = new RxDocumentFragment();\n\t\tif (deep) {\n\t\t\tnodeDocumentFragment.childNodes = source.childNodes.map(x => cloneNode.apply(x, [x, deep, nodeDocumentFragment]));\n\t\t}\n\t\tnode = nodeDocumentFragment;\n\t} else if (isRxText(source)) {\n\t\tnode = new RxText(parentNode, source.nodeValue);\n\t} else if (isRxComment(source)) {\n\t\tnode = new RxComment(parentNode, source.nodeValue);\n\t} else if (isRxDocument(source)) {\n\t\tconst documentElement: RxDocument = new RxDocument();\n\t\tif (deep) {\n\t\t\tdocumentElement.childNodes = source.childNodes.map(x => cloneNode.apply(x, [x, deep, documentElement]));\n\t\t}\n\t\tnode = documentElement;\n\t} else {\n\t\tthrow new Error('Invalid node type');\n\t}\n\treturn node;\n}\n\nexport class RxSelector {\n\tselector: string = '';\n\ttype: SelectorType = SelectorType.None;\n\tnegate: boolean = false;\n\tconstructor(options: RxSelector) {\n\t\tif (options) {\n\t\t\tObject.assign(this, options);\n\t\t}\n\t}\n}\n\nexport class RxQuery {\n\tselector: string = '';\n\tselectors: RxSelector[] = [];\n\tinner: boolean = false;\n\tconstructor(options: RxQuery) {\n\t\tif (options) {\n\t\t\tObject.assign(this, options);\n\t\t}\n\t}\n}\n\nexport class RxNode {\n\tparentNode: RxElement | null;\n\tnodeType: RxNodeType;\n\tnodeValue: string | null = null;\n\n\tconstructor(parentNode: RxElement | null = null) {\n\t\tthis.parentNode = parentNode;\n\t\tthis.nodeType = -1;\n\t}\n\tcloneNode(deep: boolean = false) {\n\t\treturn cloneNode.apply(this, [this, deep]);\n\t}\n\tserialize(): string {\n\t\treturn ``;\n\t}\n}\n\nexport class RxStyle {\n\t[key: string]: any;\n\titem(index: number): string | undefined {\n\t\tconst keys = Object.keys(this);\n\t\tif (keys.length > index) {\n\t\t\treturn keys[index];\n\t\t} else {\n\t\t\treturn undefined;\n\t\t}\n\t}\n\tgetPropertyPriority(key: string): string {\n\t\tconst value = this[key];\n\t\tif (value && value.indexOf('!important')) {\n\t\t\treturn 'important';\n\t\t} else {\n\t\t\treturn '';\n\t\t}\n\t}\n\tgetPropertyValue(key: string): string {\n\t\treturn this[key];\n\t}\n\tsetProperty(key: string, value: string, important: 'important' | '' | undefined) {\n\t\tthis[key] = value + (important === 'important' ? '!important' : '');\n\t\tthis.serialize_();\n\t}\n\tremoveProperty(key: string) {\n\t\tdelete this[key];\n\t\tthis.serialize_();\n\t}\n\tprivate serialize_() {\n\t\tthis.node.attributes.style = Object.keys(this).map(key => {\n\t\t\treturn `${key}: ${this[key]};`;\n\t\t}).join(' ');\n\t}\n\tinit() {\n\t\tconst keys = Object.keys(this);\n\t\tkeys.forEach(key => delete this[key]);\n\t\tif (this.node.attributes?.style) {\n\t\t\tconst regex: RegExp = /([^:]+):([^;]+);?\\s*/gm\n\t\t\tconst matches: RegExpMatchArray[] = [...this.node.attributes.style.matchAll(regex)];\n\t\t\tmatches.forEach((match: RegExpMatchArray) => {\n\t\t\t\tconst key: string = match[1];\n\t\t\t\tconst value: string = match[2];\n\t\t\t\tthis[key] = value;\n\t\t\t});\n\t\t}\n\t}\n\tconstructor(node: RxElement) {\n\t\tObject.defineProperty(this, 'node', {\n\t\t\tvalue: node,\n\t\t\twritable: false,\n\t\t\tenumerable: false\n\t\t});\n\t\tthis.init();\n\t}\n}\n\nexport class RxClassList extends Array<string> {\n\tnode: RxElement;\n\titem(index: number) {\n\t\treturn this[index];\n\t}\n\tcontains(name: string): boolean {\n\t\treturn this.indexOf(name) !== -1;\n\t}\n\tadd(...names: string[]) {\n\t\tnames.forEach(name => {\n\t\t\tif (this.indexOf(name) !== -1) {\n\t\t\t\tthis.push(name);\n\t\t\t}\n\t\t});\n\t\tthis.serialize_();\n\t}\n\tremove(...names: string[]) {\n\t\tnames.forEach(name => {\n\t\t\tconst index: number = this.indexOf(name);\n\t\t\tif (index !== -1) {\n\t\t\t\tthis.splice(index, 1);\n\t\t\t}\n\t\t});\n\t\tthis.serialize_();\n\t}\n\ttoggle(name: string, force?: boolean): boolean {\n\t\tconst index: number = this.indexOf(name);\n\t\tif (force === false) {\n\t\t\tthis.splice(index, 1);\n\t\t\tthis.serialize_();\n\t\t\treturn false;\n\t\t} else if (force === true) {\n\t\t\tthis.push(name);\n\t\t\tthis.serialize_();\n\t\t\treturn true;\n\t\t} else if (index !== -1) {\n\t\t\tthis.splice(index, 1);\n\t\t\tthis.serialize_();\n\t\t\treturn false;\n\t\t} else {\n\t\t\tthis.push(name);\n\t\t\tthis.serialize_();\n\t\t\treturn true;\n\t\t}\n\t}\n\treplace(oldClass: string, newClass: string) {\n\t\tconst index: number = this.indexOf(oldClass);\n\t\tif (index !== -1) {\n\t\t\tthis.splice(index, 1);\n\t\t}\n\t\tthis.push(newClass);\n\t\tthis.serialize_();\n\t}\n\tprivate serialize_() {\n\t\tthis.node.attributes.class = this.join(' ');\n\t}\n\tinit() {\n\t\tthis.length = 0;\n\t\tif (this.node.attributes?.class) {\n\t\t\tArray.prototype.push.apply(this, this.node.attributes.class.split(' ').map(name => name.trim()));\n\t\t}\n\t}\n\tconstructor(node: RxElement) {\n\t\tsuper();\n\t\tthis.node = node;\n\t\tthis.init();\n\t}\n}\n\nexport class RxElement extends RxNode {\n\tnodeName: string;\n\tchildNodes: RxNode[];\n\tattributes: { [key: string]: string | null } = {};\n\tstyle: RxStyle;\n\tclassList: RxClassList;\n\tget children(): RxElement[] {\n\t\tlet children: RxElement[] = [],\n\t\t\ti = 0,\n\t\t\tnode,\n\t\t\tnodes = this.childNodes;\n\t\tnode = nodes[i++];\n\t\twhile (node) {\n\t\t\tnode = nodes[i++];\n\t\t\tif (node.nodeType === RxNodeType.ELEMENT_NODE) {\n\t\t\t\tchildren.push(node as RxElement);\n\t\t\t}\n\t\t}\n\t\treturn children;\n\t}\n\tget childElementCount(): number {\n\t\tlet i = 0,\n\t\t\tcount = 0,\n\t\t\tnode,\n\t\t\tnodes = this.childNodes;\n\t\tnode = nodes[i++];\n\t\twhile (node) {\n\t\t\tif (node.nodeType === RxNodeType.ELEMENT_NODE) {\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\tnode = nodes[i++];\n\t\t}\n\t\treturn count;\n\t}\n\tget firstChild(): RxNode | null {\n\t\tlet node = null;\n\t\tif (this.childNodes.length) {\n\t\t\tnode = this.childNodes[0];\n\t\t}\n\t\treturn node;\n\t}\n\tget firstElementChild(): RxElement | null {\n\t\tfor (let node of this.childNodes) {\n\t\t\tif (isRxElement(node)) {\n\t\t\t\treturn node;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\tget lastChild(): RxNode | null {\n\t\tlet node = null;\n\t\tif (this.childNodes.length) {\n\t\t\tnode = this.childNodes[this.childNodes.length - 1];\n\t\t}\n\t\treturn node;\n\t}\n\tget lastElementChild(): RxElement | null {\n\t\tconst nodes = this.childNodes;\n\t\tfor (let i = nodes.length - 1; i > -1; i--) {\n\t\t\tconst node = nodes[i];\n\t\t\tif (isRxElement(node)) {\n\t\t\t\treturn node;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\tget previousSibling(): RxNode | null {\n\t\tlet node = null;\n\t\tif (this.parentNode) {\n\t\t\tconst index = this.parentNode.childNodes.indexOf(this);\n\t\t\tif (index > 0) {\n\t\t\t\tnode = this.parentNode.childNodes[index - 1];\n\t\t\t}\n\t\t}\n\t\treturn node;\n\t}\n\tget nextSibling(): RxNode | null {\n\t\tlet node = null;\n\t\tif (this.parentNode) {\n\t\t\tconst index = this.parentNode.childNodes.indexOf(this);\n\t\t\tif (index !== -1 && index < this.parentNode.childNodes.length - 1) {\n\t\t\t\tnode = this.parentNode.childNodes[index];\n\t\t\t}\n\t\t}\n\t\treturn node;\n\t}\n\tget wholeText() {\n\t\tlet nodeValue;\n\t\tif (this.nodeType === RxNodeType.TEXT_NODE) {\n\t\t\treturn this.nodeValue;\n\t\t}\n\t\treturn nodeValue;\n\t}\n\tget outerHTML(): string | null {\n\t\tlet html = null;\n\t\tif (this.parentNode) {\n\t\t\thtml = this.parentNode.serialize();\n\t\t}\n\t\treturn html;\n\t}\n\tset innerText(nodeValue: string | null) {\n\t\tthis.childNodes = [new RxText(this, nodeValue)];\n\t}\n\tget innerText(): string | null {\n\t\t// return this.childNodes.filter((n): n is RxText => isRxText(n)).map(n => n.innerText).join('');\n\t\treturn this.childNodes.filter((n): n is RxText | RxElement => isRxText(n) || isRxElement(n)).map(n => n.innerText).join('');\n\t}\n\tset textContent(nodeValue: string | null) {\n\t\tthis.innerText = String(nodeValue);\n\t}\n\tget textContent(): string | null {\n\t\treturn this.innerText;\n\t}\n\tget innerHTML(): string {\n\t\treturn this.childNodes.map(x => x.serialize()).join('');\n\t}\n\tset innerHTML(html: string) {\n\t\tconst doc = parse(html);\n\t\tconst childNodes = doc.childNodes.map(n => {\n\t\t\tn.parentNode = this;\n\t\t\treturn n;\n\t\t});\n\t\tthis.childNodes = childNodes;\n\t}\n\tconstructor(parentNode: RxElement | null = null, nodeName: string, attributes: { [key: string]: string | null } | null = null) {\n\t\tsuper(parentNode);\n\t\tthis.nodeType = RxNodeType.ELEMENT_NODE;\n\t\tthis.nodeName = nodeName;\n\t\tif (attributes && typeof attributes === 'object') {\n\t\t\tthis.attributes = attributes;\n\t\t}\n\t\tthis.style = new RxStyle(this);\n\t\tthis.classList = new RxClassList(this);\n\t\tthis.childNodes = [];\n\t\t/*\n\t\t\tif (SKIP.indexOf(nodeName) === -1) {\n\t\t\t\tconsole.log(parentNode.nodeName, '>', nodeName);\n\t\t}\n\t\t*/\n\t}\n\tappend(...nodesOrDOMStrings: (RxNode | string)[]) {\n\t\tnodesOrDOMStrings = nodesOrDOMStrings.map(nodeOrDomString => {\n\t\t\tlet node;\n\t\t\tif (typeof nodeOrDomString === 'string') {\n\t\t\t\tnode = new RxText(this, nodeOrDomString);\n\t\t\t} else {\n\t\t\t\tnode = nodeOrDomString;\n\t\t\t\tnode.parentNode = this;\n\t\t\t}\n\t\t\treturn node;\n\t\t});\n\t\tArray.prototype.push.apply(this.childNodes, nodesOrDOMStrings);\n\t\t/*\n\t\tfor (let nodeOrDomString of nodesOrDOMStrings) {\n\t\t\t\tlet node;\n\t\t\t\tif (typeof nodeOrDomString === 'string') {\n\t\t\t\t\tnode = new RxText(this, nodeOrDomString);\n\t\t\t\t} else {\n\t\t\t\t\tnode = nodeOrDomString;\n\t\t\t\t}\n\t\t\t\tthis.childNodes.push(node);\n\t\t}\n\t\t*/\n\t}\n\tprepend(...nodesOrDOMStrings: (RxNode | string)[]) {\n\t\tnodesOrDOMStrings = nodesOrDOMStrings.map(nodeOrDomString => {\n\t\t\tlet node;\n\t\t\tif (typeof nodeOrDomString === 'string') {\n\t\t\t\tnode = new RxText(this, nodeOrDomString);\n\t\t\t} else {\n\t\t\t\tnode = nodeOrDomString;\n\t\t\t\tnode.parentNode = this;\n\t\t\t}\n\t\t\treturn node;\n\t\t});\n\t\tArray.prototype.unshift.apply(this.childNodes, nodesOrDOMStrings);\n\t\t/*\n\t\t\tfor (let nodeOrDomString of nodesOrDOMStrings) {\n\t\t\t\tlet node;\n\t\t\t\tif (typeof nodeOrDomString === 'string') {\n\t\t\t\t\tnode = new RxText(this, nodeOrDomString);\n\t\t\t\t} else {\n\t\t\t\t\tnode = nodeOrDomString;\n\t\t\t\t}\n\t\t\t\tthis.childNodes.unshift(node);\n\t\t}\n\t\t*/\n\t}\n\treplaceChildren(...nodesOrDOMStrings: (RxNode | string)[]) {\n\t\tconst nodes: RxNode[] = nodesOrDOMStrings.map((nodeOrDomString) => {\n\t\t\tlet node: RxNode;\n\t\t\tif (typeof nodeOrDomString === 'string') {\n\t\t\t\tnode = new RxText(this, nodeOrDomString);\n\t\t\t} else {\n\t\t\t\tnode = nodeOrDomString as RxNode;\n\t\t\t\tnode.parentNode = this;\n\t\t\t}\n\t\t\treturn node;\n\t\t});\n\t\tthis.childNodes = nodes;\n\t}\n\tquerySelectorAll(selector: string): RxNode[] | null {\n\t\tconst queries = getQueries(selector);\n\t\tconst nodes = this.childNodes.filter(x => {\n\t\t\treturn true;\n\t\t});\n\t\tconsole.log(queries);\n\t\treturn nodes.length ? nodes : null;\n\t}\n\tquerySelector(selector: string): RxNode | null {\n\t\tconst queries = getQueries(selector);\n\t\tconst node = querySelector(queries, this.childNodes);\n\t\treturn node;\n\t}\n\thasAttribute(attribute: string): boolean {\n\t\treturn Object.keys(this.attributes).indexOf(attribute.toLowerCase()) !== -1;\n\t}\n\tgetAttribute(attribute: string): string | null {\n\t\treturn this.attributes[attribute.toLowerCase()] || null;\n\t}\n\tsetAttribute(attribute: string, value: any) {\n\t\tthis.attributes[attribute.toLowerCase()] = value.toString();\n\t\tif (attribute === 'style') {\n\t\t\tthis.style.init();\n\t\t} else if (attribute === 'class') {\n\t\t\tthis.classList.init();\n\t\t}\n\t}\n\tremoveAttribute(attribute: string) {\n\t\tdelete this.attributes[attribute];\n\t\tif (attribute === 'style') {\n\t\t\tthis.style.init();\n\t\t} else if (attribute === 'class') {\n\t\t\tthis.classList.init();\n\t\t}\n\t}\n\treplaceChild(newChild: RxNode, oldChild: RxNode): RxNode {\n\t\tconst index = this.childNodes.indexOf(oldChild);\n\t\tif (index !== -1) {\n\t\t\tthis.childNodes[index] = newChild;\n\t\t\tnewChild.parentNode = this;\n\t\t}\n\t\t// console.log('replaceChild', this, newChild, oldChild);\n\t\treturn oldChild;\n\t}\n\tremoveChild(child: RxNode): RxNode {\n\t\tif (!(child instanceof RxNode)) {\n\t\t\tthrow new Error(`Uncaught TypeError: Failed to execute 'removeChild' on 'Node': parameter 1 is not of type 'Node'.`);\n\t\t}\n\t\tconst index = this.childNodes.indexOf(child);\n\t\tif (index === -1) {\n\t\t\tthrow new Error(`Uncaught NotFoundError: Failed to execute 'removeChild' on 'Node': The node to be removed is not a child of this node.`);\n\t\t}\n\t\tthis.childNodes.splice(index, 1);\n\t\t// console.log('removeChild', this.childNodes.length);\n\t\treturn child;\n\t}\n\tinsertBefore(newNode: RxNode, referenceNode: RxNode | null = null): RxNode {\n\t\tconst index = referenceNode\n\t\t\t? this.childNodes.indexOf(referenceNode)\n\t\t\t: this.childNodes.length;\n\t\tif (index !== -1) {\n\t\t\tthis.childNodes.splice(index, 0, newNode);\n\t\t\tnewNode.parentNode = this;\n\t\t}\n\t\t// console.log('insertBefore', this, newNode, referenceNode);\n\t\treturn newNode;\n\t}\n\tcloneNode(deep: boolean = false) {\n\t\treturn cloneNode.apply(this, [this, deep]);\n\t}\n\taddListener(eventName: string, handler: (e: any) => {}) { }\n\tremoveListener(eventName: string, handler: (e: any) => {}) { }\n\tserialize(): string {\n\t\treturn `<${\n\t\t\tthis.nodeName\n\t\t\t}${this.serializeAttributes()}>${this.childNodes\n\t\t\t\t.map(x => x.serialize())\n\t\t\t\t.join('')}</${this.nodeName}>`;\n\t}\n\tserializeAttributes(): string {\n\t\tlet attributes = '';\n\t\tconst keys = Object.keys(this.attributes);\n\t\tif (keys.length) {\n\t\t\tattributes =\n\t\t\t\t' ' +\n\t\t\t\tkeys\n\t\t\t\t\t.map(k => {\n\t\t\t\t\t\treturn `${k}=\"${this.attributes[k]}\"`;\n\t\t\t\t\t})\n\t\t\t\t\t.join(' ');\n\t\t}\n\t\treturn attributes;\n\t}\n}\n\nexport class RxText extends RxNode {\n\tnodeValue: string;\n\tget outerHTML(): string | null {\n\t\tlet html = null;\n\t\tif (this.parentNode) {\n\t\t\thtml = this.parentNode.serialize();\n\t\t}\n\t\treturn html;\n\t}\n\tget wholeText(): string | null {\n\t\treturn this.nodeValue;\n\t}\n\tset innerText(nodeValue) {\n\t\tthis.nodeValue = String(nodeValue);\n\t}\n\tget innerText(): string | null {\n\t\treturn this.nodeValue;\n\t}\n\tset textContent(nodeValue) {\n\t\tthis.nodeValue = String(nodeValue);\n\t}\n\tget textContent(): string | null {\n\t\treturn this.nodeValue;\n\t}\n\tconstructor(parentNode: RxElement | null = null, nodeValue: any) {\n\t\tsuper(parentNode);\n\t\tthis.nodeType = RxNodeType.TEXT_NODE;\n\t\tthis.nodeValue = String(nodeValue);\n\t\t// console.log('RxText', nodeValue);\n\t}\n\tserialize(): string {\n\t\treturn this.nodeValue;\n\t}\n}\n\nexport class RxCData extends RxNode {\n\tnodeValue: string;\n\tget outerHTML(): string | null {\n\t\tlet html = null;\n\t\tif (this.parentNode) {\n\t\t\thtml = this.parentNode.serialize();\n\t\t}\n\t\treturn html;\n\t}\n\tget wholeText(): string | null {\n\t\treturn this.nodeValue;\n\t}\n\tset innerText(nodeValue) {\n\t\tthis.nodeValue = String(nodeValue);\n\t}\n\tget innerText(): string | null {\n\t\treturn this.nodeValue;\n\t}\n\tset textContent(nodeValue) {\n\t\tthis.nodeValue = String(nodeValue);\n\t}\n\tget textContent(): string | null {\n\t\treturn this.nodeValue;\n\t}\n\tconstructor(parentNode: RxElement | null = null, nodeValue: any) {\n\t\tsuper(parentNode);\n\t\tthis.nodeType = RxNodeType.CDATA_SECTION_NODE;\n\t\tthis.nodeValue = String(nodeValue);\n\t}\n\tserialize(): string {\n\t\treturn this.nodeValue;\n\t}\n}\n\nexport class RxComment extends RxNode {\n\tnodeValue: string;\n\tget outerHTML(): string | null {\n\t\tlet html = null;\n\t\tif (this.parentNode) {\n\t\t\thtml = this.parentNode.serialize();\n\t\t}\n\t\treturn html;\n\t}\n\tget wholeText(): string | null {\n\t\treturn this.nodeValue;\n\t}\n\tset innerText(nodeValue) {\n\t\tthis.nodeValue = String(nodeValue);\n\t}\n\tget innerText(): string | null {\n\t\treturn this.nodeValue;\n\t}\n\tset textContent(nodeValue) {\n\t\tthis.nodeValue = String(nodeValue);\n\t}\n\tget textContent(): string | null {\n\t\treturn this.nodeValue;\n\t}\n\tconstructor(parentNode: RxElement | null = null, nodeValue: any) {\n\t\tsuper(parentNode);\n\t\tthis.nodeType = RxNodeType.COMMENT_NODE;\n\t\tthis.nodeValue = String(nodeValue);\n\t}\n\tserialize(): string {\n\t\treturn `<!--${this.nodeValue}-->`;\n\t}\n}\n\nexport class RxProcessingInstruction extends RxNode {\n\tconstructor(parentNode: RxElement | null = null, nodeValue: any) {\n\t\tsuper(parentNode);\n\t\tthis.nodeType = RxNodeType.PROCESSING_INSTRUCTION_NODE;\n\t\tthis.nodeValue = String(nodeValue);\n\t}\n\tserialize(): string {\n\t\treturn `<${this.nodeValue}>`;\n\t}\n}\n\nexport class RxDocumentType extends RxNode {\n\tconstructor(parentNode: RxElement | null = null, nodeValue: any) {\n\t\tsuper(parentNode);\n\t\tthis.nodeType = RxNodeType.DOCUMENT_TYPE_NODE;\n\t\tthis.nodeValue = String(nodeValue);\n\t}\n\tserialize(): string {\n\t\treturn `<${this.nodeValue}>`;\n\t}\n}\n\nexport class RxDocumentFragment extends RxElement {\n\tconstructor() {\n\t\tsuper(null, '#document-fragment');\n\t\tthis.nodeType = RxNodeType.DOCUMENT_FRAGMENT_NODE;\n\t\tthis.childNodes = [];\n\t}\n}\n\nexport class RxDocument extends RxElement {\n\tget hidden(): true {\n\t\treturn true;\n\t}\n\tget visibilityState(): 'prerender' {\n\t\treturn 'prerender';\n\t}\n\tget doctype(): RxDocumentType | null {\n\t\treturn this.childNodes.find(x => isRxDocumentType(x)) as RxDocumentType;\n\t}\n\tget body(): RxElement | null {\n\t\treturn this.childNodes.find(x => isRxElement(x) && x.nodeName === 'body') as RxElement;\n\t}\n\tget head(): RxElement | null {\n\t\treturn this.childNodes.find(x => isRxElement(x) && x.nodeName === 'head') as RxElement;\n\t}\n\tget title(): string | null {\n\t\tconst title = this.childNodes.find(x => isRxElement(x) && x.nodeName === 'title') as RxElement;\n\t\tif (title) {\n\t\t\treturn title.innerText;\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}\n\tset title(nodeValue: string | null) {\n\t\tconst title = this.childNodes.find(x => isRxElement(x) && x.nodeName === 'title') as RxElement;\n\t\tif (title) {\n\t\t\ttitle.innerText = nodeValue;\n\t\t}\n\t}\n\tget documentElement(): RxElement | null {\n\t\treturn this.firstElementChild;\n\t}\n\tconstructor() {\n\t\tsuper(null, '#document');\n\t\tthis.nodeType = RxNodeType.DOCUMENT_NODE;\n\t\tthis.childNodes = [];\n\t}\n\tcreateAttribute() { }\n\t// Creates a new Attr object and returns it.\n\tcreateAttributeNS() { }\n\t// Creates a new attribute node in a given namespace and returns it.\n\tcreateCDATASection() { }\n\t// Creates a new CDATA node and returns it.\n\tcreateComment(nodeValue: string) {\n\t\treturn new RxComment(null, nodeValue);\n\t}\n\t// Creates a new comment node and returns it.\n\tcreateDocumentFragment() {\n\t\treturn new RxDocumentFragment();\n\t}\n\t// Creates a new document fragment.\n\tcreateElement(nodeName: string): RxElement {\n\t\treturn new RxElement(null, nodeName);\n\t}\n\t// Creates a new element with the given tag name.\n\tcreateElementNS(nodeName: string): RxElement {\n\t\treturn new RxElement(null, nodeName);\n\t}\n\t// Creates a new element with the given tag name and namespace URI.\n\tcreateEvent() { }\n\t// Creates an event object.\n\tcreateNodeIterator() { }\n\t// Creates a NodeIterator object.\n\tcreateProcessingInstruction(nodeValue: string) {\n\t\treturn new RxProcessingInstruction(null, nodeValue);\n\t}\n\t// Creates a new ProcessingInstruction object.\n\tcreateRange() { }\n\t// Creates a Range object.\n\tcreateTextNode(nodeValue: string) {\n\t\treturn new RxText(null, nodeValue);\n\t}\n\t// Creates a text node.\n\tcreateTouchList() { }\n\t// Creates a TouchList object.\n\tcreateTreeWalker() { }\n\t// Creates a TreeWalker object.\n\tserialize(): string {\n\t\treturn `${this.childNodes.map(x => x.serialize()).join('')}`;\n\t}\n}\n","export enum HttpEventType {\n\tSent,\n\tUploadProgress,\n\tResponseHeader,\n\tDownloadProgress,\n\tResponse,\n\tUser,\n\tResponseError,\n}\n\nexport interface HttpProgressEvent {\n\ttype: HttpEventType.DownloadProgress | HttpEventType.UploadProgress;\n\tloaded: number;\n\ttotal?: number;\n}\n\nexport interface HttpDownloadProgressEvent extends HttpProgressEvent {\n\ttype: HttpEventType.DownloadProgress;\n\tpartialText?: string;\n}\n\nexport interface HttpUploadProgressEvent extends HttpProgressEvent {\n\ttype: HttpEventType.UploadProgress;\n}\n\nexport interface HttpSentEvent {\n\ttype: HttpEventType.Sent;\n}\n\nexport interface HttpUserEvent<T> {\n\ttype: HttpEventType.User;\n}\n","export const Vars = {\n\tname: 'rxcomp-server',\n\tstatic: false,\n\tdevelopment: false,\n\tproduction: true,\n\thost: '',\n\tresource: '/',\n\tapi: '/api',\n};\n\n/*\nexport const STATIC = window.location.port === '40333' || window.location.host === 'actarian.github.io';\nexport const DEVELOPMENT = ['localhost', '127.0.0.1', '0.0.0.0'].indexOf(window.location.host.split(':')[0]) !== -1;\nexport const PRODUCTION = !DEVELOPMENT;\nexport const ENV = {\n\tNAME: 'ws-events',\n\tSTATIC,\n\tDEVELOPMENT,\n\tPRODUCTION,\n\tRESOURCE: '/Modules/Events/Client/docs/',\n\tSTATIC_RESOURCE: './',\n\tAPI: '/api',\n\tSTATIC_API: (DEVELOPMENT && !STATIC) ? '/Modules/Events/Client/docs/api' : './api',\n};\nexport function getApiUrl(url, useStatic) {\n\tconst base = (useStatic || STATIC) ? ENV.STATIC_API : ENV.API;\n\tconst json = (useStatic || STATIC) ? '.json' : '';\n\treturn `${base}${url}${json}`;\n}\nexport function getResourceRoot() {\n\treturn STATIC ? ENV.STATIC_RESOURCE : ENV.RESOURCE;\n}\nexport function getSlug(url) {\n\tif (!url) {\n\t\treturn url;\n\t}\n\tif (url.indexOf(`/${ENV.NAME}`) !== 0) {\n\t\treturn url;\n\t}\n\tif (STATIC) {\n\t\tconsole.log(url);\n\t\treturn url;\n\t}\n\turl = url.replace(`/${ENV.NAME}`, '');\n\turl = url.replace('.html', '');\n\treturn `/it/it${url}`;\n}\n*/\n","import { isPlatformServer, Module, ModuleError, Platform } from 'rxcomp';\nimport { from, Observable, Observer } from 'rxjs';\nimport { switchMap } from 'rxjs/operators';\nimport { Vars } from '../../test/js/vars';\nimport CacheService from '../cache/cache.service';\nimport { parse, RxDocument, RxElement, RxText } from '../nodes/nodes';\nconst fs = require('fs');\n\nexport interface IServerRequest {\n\turl: string;\n\ttemplate: string;\n\thost?: string;\n\tcharset?: string;\n}\n\nexport interface IServerResponse extends IServerRequest {\n\tserialize: () => string;\n\tbody?: string;\n\tstatusCode?: number;\n\tstatusMessage?: string;\n}\n\nexport interface IServerErrorResponse extends IServerRequest {\n\terror: Error;\n\tstatusCode?: number;\n\tstatusMessage?: string;\n}\n\nexport class ServerResponse implements IServerResponse {\n\ttemplate!: string;\n\turl!: string;\n\thost?: string;\n\tcharset?: string;\n\tserialize!: () => string;\n\tbody!: string;\n\tstatusCode?: number;\n\tstatusMessage?: string;\n\tconstructor(options?: IServerResponse) {\n\t\tif (options) {\n\t\t\tObject.assign(this, options);\n\t\t}\n\t}\n}\n\nexport class ServerErrorResponse implements IServerErrorResponse {\n\ttemplate!: string;\n\turl!: string;\n\thost?: string;\n\tcharset?: string;\n\terror!: Error;\n\tstatusCode?: number;\n\tstatusMessage?: string;\n\tconstructor(options?: IServerErrorResponse) {\n\t\tif (options) {\n\t\t\tObject.assign(this, options);\n\t\t}\n\t}\n}\n\nexport default class Server extends Platform {\n\n\t/**\n\t * @param moduleFactory\n\t * @description This method returns a Server compiled module\n\t */\n\tstatic bootstrap(moduleFactory?: typeof Module, template?: string) {\n\t\tif (!isPlatformServer) {\n\t\t\tthrow new ModuleError('missing platform server, node process not found');\n\t\t}\n\t\tif (!moduleFactory) {\n\t\t\tthrow new ModuleError('missing moduleFactory');\n\t\t}\n\t\tif (!moduleFactory.meta) {\n\t\t\tthrow new ModuleError('missing moduleFactory meta');\n\t\t}\n\t\tif (!moduleFactory.meta.bootstrap) {\n\t\t\tthrow new ModuleError('missing bootstrap');\n\t\t}\n\t\tif (!moduleFactory.meta.bootstrap.meta) {\n\t\t\tthrow new ModuleError('missing bootstrap meta');\n\t\t}\n\t\tif (!moduleFactory.meta.bootstrap.meta.selector) {\n\t\t\tthrow new ModuleError('missing bootstrap meta selector');\n\t\t}\n\t\tif (!template) {\n\t\t\tthrow new ModuleError('missing template');\n\t\t}\n\t\t/*\n\t\tif (typeof ((ReadableStream.prototype as any)[Symbol.asyncIterator]) === 'undefined') {\n\t\t\t(ReadableStream.prototype as any)[Symbol.asyncIterator] = async function* () {\n\t\t\t\tconst reader = this.getReader()\n\t\t\t\twhile (1) {\n\t\t\t\t\tconst r = await reader.read();\n\t\t\t\t\tif (r.done) {\n\t\t\t\t\t\treturn r.value;\n\t\t\t\t\t}\n\t\t\t\t\tyield r.value;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t*/\n\t\tconst document = this.resolveGlobals(template);\n\t\tconst meta = this.resolveMeta(moduleFactory);\n\t\tif (meta.node instanceof RxElement) {\n\t\t\tconst node: RxElement = meta.node as RxElement;\n\t\t\tconst nodeInnerHTML = meta.nodeInnerHTML;\n\t\t\tconst rxcomp_hydrate_ = {\n\t\t\t\tselector: moduleFactory.meta.bootstrap.meta.selector,\n\t\t\t\tinnerHTML: nodeInnerHTML,\n\t\t\t};\n\t\t\tconst scriptNode = new RxElement(null, 'script');\n\t\t\tconst scriptText = new RxText(null, `var rxcomp_hydrate_ = ${JSON.stringify(rxcomp_hydrate_)};`);\n\t\t\tscriptNode.append(scriptText);\n\t\t\tnode.parentNode?.insertBefore(scriptNode, node);\n\t\t}\n\t\tconst module = new moduleFactory();\n\t\tmodule.meta = meta;\n\t\tmeta.imports.forEach((moduleFactory: typeof Module) => {\n\t\t\tmoduleFactory.prototype.constructor.call(module);\n\t\t});\n\t\tconst instances = module.compile(meta.node, { document } as Window);\n\t\tmodule.instances = instances;\n\t\tconst root = instances[0];\n\t\troot.pushChanges();\n\t\treturn module;\n\t}\n\n\tstatic serialize(): string {\n\t\tconsole.log('Server.serialize');\n\t\tif (this.document instanceof RxDocument) {\n\t\t\tconst serialized = this.document.serialize();\n\t\t\t// console.log('serialized', serialized);\n\t\t\treturn serialized;\n\t\t} else {\n\t\t\tthrow new ModuleError('document is not an instance of RxDocument');\n\t\t}\n\t}\n\n\tprotected static document: Document | RxDocument;\n\n\tprotected static resolveGlobals(documentOrHtml: Document | string): Document | RxDocument {\n\t\tconst document: Document | RxDocument = typeof documentOrHtml === 'string' ? parse(documentOrHtml) : documentOrHtml;\n\t\tthis.document = document as Document;\n\t\tglobal.document = this.document;\n\t\treturn this.document;\n\t}\n\n\tstatic bootstrap$ = bootstrap$;\n\tstatic render$ = render$;\n\tstatic template$ = template$;\n\n}\n\nexport function bootstrap$(moduleFactory: typeof Module, request?: IServerRequest): Observable<ServerResponse> {\n\tif (request && request.host) {\n\t\tVars.host = request.host;\n\t}\n\treturn from(new Promise<ServerResponse>((resolve, reject) => {\n\t\tif (!request?.template) {\n\t\t\treturn reject(new Error('ServerError: missing template'));\n\t\t}\n\t\ttry {\n\t\t\t// const module = Server.bootstrap(moduleFactory, request.template);\n\t\t\tServer.bootstrap(moduleFactory, request.template);\n\t\t\tconst serialize = () => Server.serialize();\n\t\t\tresolve(new ServerResponse(Object.assign({ serialize }, request) as IServerResponse));\n\t\t} catch (error) {\n\t\t\treject(new ServerErrorResponse(Object.assign({ error }, request) as IServerErrorResponse));\n\t\t}\n\t}));\n}\n\nexport function render$(request: IServerRequest, renderRequest$: (request?: IServerRequest) => Observable<ServerResponse>): Observable<ServerResponse> {\n\treturn Observable.create(function (observer: Observer<ServerResponse>) {\n\t\tconst cached = CacheService.get('cached', request.url);\n\t\tconsole.log('cached', !!cached);\n\t\tif (cached) {\n\t\t\tobserver.next(cached);\n\t\t\treturn observer.complete();\n\t\t}\n\t\ttemplate$(request).pipe(\n\t\t\tswitchMap((template: string) => {\n\t\t\t\t// console.log('template!', template);\n\t\t\t\trequest.template = template;\n\t\t\t\treturn renderRequest$(request);\n\t\t\t})\n\t\t).subscribe(\n\t\t\t(success) => {\n\t\t\t\tCacheService.set('cached', request.url, success, 3600);\n\t\t\t\tobserver.next(success);\n\t\t\t\tobserver.complete();\n\t\t\t},\n\t\t\t(error) => {\n\t\t\t\tobserver.error(error);\n\t\t\t}\n\t\t);\n\t});\n}\n\nexport function template$(request: IServerRequest): Observable<string> {\n\treturn Observable.create(function (observer: Observer<string>) {\n\t\tconst template = CacheService.get('template', request.template);\n\t\tconsole.log('template', !!template);\n\t\tif (template) {\n\t\t\tobserver.next(template);\n\t\t\tobserver.complete();\n\t\t}\n\t\tfs.readFile(request.template, request.charset, function (error: NodeJS.ErrnoException, template: string) {\n\t\t\tif (error) {\n\t\t\t\tobserver.error(error);\n\t\t\t} else {\n\t\t\t\tCacheService.set('template', request.template, template);\n\t\t\t\tobserver.next(template);\n\t\t\t\tobserver.complete();\n\t\t\t}\n\t\t});\n\t});\n}\n","\nexport type IHttpHeaders = string | { [name: string]: string | string[] };\n\nexport class HttpHeaders implements Headers {\n\tprivate headers_: Map<string, string[]> = new Map<string, string[]>();\n\n\tconstructor(options?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined) {\n\t\tconst headers = this.headers_;\n\t\tif (options instanceof HttpHeaders) {\n\t\t\toptions.headers_.forEach((value, key) => {\n\t\t\t\theaders.set(key, value);\n\t\t\t});\n\t\t} else if (typeof (options as Headers)?.forEach === 'function') {\n\t\t\t(options as Headers).forEach((value, key) => {\n\t\t\t\theaders.set(key, value.split(', '));\n\t\t\t});\n\t\t} else if (typeof options === 'object') {\n\t\t\tObject.keys(options).forEach(key => {\n\t\t\t\tlet values: string | string[] = (options as any)[key];\n\t\t\t\tif (typeof values === 'string') {\n\t\t\t\t\tvalues = [values];\n\t\t\t\t}\n\t\t\t\tif (headers.has(key)) {\n\t\t\t\t\tvalues.forEach(value => this.append(key, value));\n\t\t\t\t} else {\n\t\t\t\t\theaders.set(key, values);\n\t\t\t\t}\n\t\t\t});\n\t\t} else if (typeof options === 'string') {\n\t\t\toptions.split('\\n').forEach(line => {\n\t\t\t\tconst index = line.indexOf(':');\n\t\t\t\tif (index > 0) {\n\t\t\t\t\tconst key = line.slice(0, index);;\n\t\t\t\t\tconst value = line.slice(index + 1).trim();\n\t\t\t\t\tif (headers.has(key)) {\n\t\t\t\t\t\tthis.append(key, value);\n\t\t\t\t\t} else {\n\t\t\t\t\t\theaders.set(key, [value]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\tif (!headers.has('Accept')) {\n\t\t\theaders.set('Accept', ['application/json', 'text/plain', '*/*']);\n\t\t}\n\t\tif (!headers.has('Content-Type')) {\n\t\t\theaders.set('Content-Type', ['application/json']);\n\t\t}\n\t}\n\n\thas(key: string): boolean {\n\t\treturn this.headers_.has(key);\n\t}\n\n\tget(key: string): string | null {\n\t\tconst values = this.headers_.get(key);\n\t\treturn values ? values.join(', ') : null;\n\t}\n\n\tset(key: string, value: string): HttpHeaders {\n\t\tconst clone = this.clone_();\n\t\tclone.headers_.set(key, value.split(', '));\n\t\treturn clone;\n\t}\n\n\tappend(key: string, value: string): HttpHeaders {\n\t\tconst clone = this.clone_();\n\t\tconst values: string[] = clone.headers_.has(key) ? clone.headers_.get(key) || [] : [];\n\t\tvalues.push(value);\n\t\tclone.headers_.set(key, values);\n\t\treturn clone;\n\t}\n\n\tdelete(key: string): HttpHeaders {\n\t\tconst clone = this.clone_();\n\t\tclone.headers_.delete(key);\n\t\treturn clone;\n\t}\n\n\tforEach(callback: (value: string, key: string, parent: Headers) => void, thisArg?: any): void {\n\t\tthis.headers_.forEach((v, k) => {\n\t\t\tcallback(v.join(', '), k, this);\n\t\t});\n\t}\n\n\tserialize(): Headers | string[][] | Record<string, string> | undefined {\n\t\tconst headers: string[][] = [];\n\t\tthis.forEach((value, key) => {\n\t\t\theaders.push([key, value]);\n\t\t});\n\t\treturn headers;\n\t}\n\n\tprivate clone_(): HttpHeaders {\n\t\tconst clone = new HttpHeaders();\n\t\tthis.headers_.forEach((value, key) => {\n\t\t\tclone.headers_.set(key, value);\n\t\t});\n\t\treturn clone;\n\t}\n\n}\n\n/*\nexport class HttpHeaders implements Headers {\n\n\tprivate headers: Map<string, string[]> = new Map<string, string[]>();;\n\tprivate normalizedNames: Map<string, string> = new Map();\n\n\tconstructor(headers?: IHttpHeaders) {\n\t\tif (typeof headers === 'string') {\n\t\t\theaders.split('\\n').forEach(line => {\n\t\t\t\tconst index = line.indexOf(':');\n\t\t\t\tif (index > 0) {\n\t\t\t\t\tconst name = line.slice(0, index);\n\t\t\t\t\tconst key = name.toLowerCase();\n\t\t\t\t\tconst value = line.slice(index + 1).trim();\n\t\t\t\t\tif (!this.normalizedNames.has(key)) {\n\t\t\t\t\t\tthis.normalizedNames.set(key, name);\n\t\t\t\t\t}\n\t\t\t\t\tif (this.headers.has(key)) {\n\t\t\t\t\t\tthis.headers.get(key)!.push(value);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.headers.set(key, [value]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t} else if (typeof headers === 'object') {\n\t\t\tObject.keys(headers).forEach(name => {\n\t\t\t\tlet values: string | string[] = headers[name];\n\t\t\t\tconst key = name.toLowerCase();\n\t\t\t\tif (typeof values === 'string') {\n\t\t\t\t\tvalues = [values];\n\t\t\t\t}\n\t\t\t\tif (values.length > 0) {\n\t\t\t\t\tthis.headers.set(key, values);\n\t\t\t\t\tif (!this.normalizedNames.has(key)) {\n\t\t\t\t\t\tthis.normalizedNames.set(key, name);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n\n\tappend(name: string, value: string): void {\n\t\tthis.applyUpdate({ name, value, operation: 'append' });\n\t}\n\n\tdelete(name: string): void {\n\t\tthis.applyUpdate({ name, operation: 'delete' });\n\t}\n\n\tget(name: string): string | null {\n\t\tconst values = this.headers.get(name.toLowerCase());\n\t\treturn values && values.length > 0 ? values[0] : null;\n\t}\n\n\thas(name: string): boolean {\n\t\t// this.init();\n\t\treturn this.headers.has(name.toLowerCase());\n\t}\n\n\tset(name: string, value: string | string[]): void {\n\t\tthis.applyUpdate({ name, value, operation: 'set' });\n\t}\n\n\t// forEach(callback: (name: string, values: string[]) => void):void {\n\t// \tthis.init();\n\t//\tArray.from(this.normalizedNames.keys()).forEach(key => callback(this.normalizedNames.get(key)!, this.headers.get(key)!));\n\t// }\n\n\tforEach(callback: (value: string, key: string, parent: Headers) => void, thisArg?: any): void {\n\t\tArray.from(this.normalizedNames.keys()).forEach(key => {\n\t\t\tconst value = this.headers.get(key)!;\n\t\t\tcallback((Array.isArray(value) ? value.join(',') : value), this.normalizedNames.get(key)!, this);\n\t\t});\n\t}\n\n\tserialize(): Headers | string[][] | Record<string, string> | undefined {\n\t\tconst headers: string[][] = [];\n\t\tObject.keys(this.headers.keys()).forEach(key => {\n\t\t\tconst value = this.headers.get(key);\n\t\t\tif (value) {\n\t\t\t\theaders.push([key, ...value]);\n\t\t\t}\n\t\t});\n\t\treturn headers;\n\t}\n\n\tprivate clone(update: any): HttpHeaders {\n\t\tconst headers: IHttpHeaders = {};\n\t\tObject.keys(this.headers.keys()).forEach(key => {\n\t\t\tconst value = this.headers.get(key);\n\t\t\tif (value) {\n\t\t\t\theaders[key] = value;\n\t\t\t}\n\t\t});\n\t\tthis.applyUpdate(update);\n\t\treturn new HttpHeaders(headers);\n\t}\n\n\tprivate applyUpdate(update: any): void {\n\t\tconst key = update.name.toLowerCase();\n\t\tswitch (update.operation) {\n\t\t\tcase 'appen':\n\t\t\tcase 'set':\n\t\t\t\tlet value = update.value!;\n\t\t\t\tif (typeof value === 'string') {\n\t\t\t\t\tvalue = [value];\n\t\t\t\t}\n\t\t\t\tif (value.length === 0) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (!this.normalizedNames.has(key)) {\n\t\t\t\t\tthis.normalizedNames.set(key, update.name);\n\t\t\t\t}\n\t\t\t\tconst base = (update.op === 'append' ? this.headers.get(key) : undefined) || [];\n\t\t\t\tbase.push(...value);\n\t\t\t\tthis.headers.set(key, base);\n\t\t\t\tbreak;\n\t\t\tcase 'delete':\n\t\t\t\tconst toDelete = update.value as string | undefined;\n\t\t\t\tif (!toDelete) {\n\t\t\t\t\tthis.headers.delete(key);\n\t\t\t\t\tthis.normalizedNames.delete(key);\n\t\t\t\t} else {\n\t\t\t\t\tlet existing = this.headers.get(key);\n\t\t\t\t\tif (!existing) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\texisting = existing.filter(value => toDelete.indexOf(value) === -1);\n\t\t\t\t\tif (existing.length === 0) {\n\t\t\t\t\t\tthis.headers.delete(key);\n\t\t\t\t\t\tthis.normalizedNames.delete(key);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.headers.set(key, existing);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n}\n*/\n\n/*\nexport class HttpHeaders {\n\n\tprivate headers!: Map<string, string[]>;\n\tprivate normalizedNames: Map<string, string> = new Map();\n\tprivate lazyInit!: HttpHeaders | Function | null;\n\tprivate lazyUpdate: Update[] | null = null;\n\n\tconstructor(headers?: string | { [name: string]: string | string[] }) {\n\t\tif (!headers) {\n\t\t\tthis.headers = new Map<string, string[]>();\n\t\t} else if (typeof headers === 'string') {\n\t\t\tthis.lazyInit = () => {\n\t\t\t\tthis.headers = new Map<string, string[]>();\n\t\t\t\theaders.split('\\n').forEach(line => {\n\t\t\t\t\tconst index = line.indexOf(':');\n\t\t\t\t\tif (index > 0) {\n\t\t\t\t\t\tconst name = line.slice(0, index);\n\t\t\t\t\t\tconst key = name.toLowerCase();\n\t\t\t\t\t\tconst value = line.slice(index + 1).trim();\n\t\t\t\t\t\tthis.maybeSetNormalizedName(name, key);\n\t\t\t\t\t\tif (this.headers.has(key)) {\n\t\t\t\t\t\t\tthis.headers.get(key)!.push(value);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthis.headers.set(key, [value]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t};\n\t\t} else {\n\t\t\tthis.lazyInit = () => {\n\t\t\t\tthis.headers = new Map<string, string[]>();\n\t\t\t\tObject.keys(headers).forEach(name => {\n\t\t\t\t\tlet values: string | string[] = headers[name];\n\t\t\t\t\tconst key = name.toLowerCase();\n\t\t\t\t\tif (typeof values === 'string') {\n\t\t\t\t\t\tvalues = [values];\n\t\t\t\t\t}\n\t\t\t\t\tif (values.length > 0) {\n\t\t\t\t\t\tthis.headers.set(key, values);\n\t\t\t\t\t\tthis.maybeSetNormalizedName(name, key);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t};\n\t\t}\n\t}\n\n\thas(name: string): boolean {\n\t\tthis.init();\n\t\treturn this.headers.has(name.toLowerCase());\n\t}\n\n\tget(name: string): string | null {\n\t\tthis.init();\n\t\tconst values = this.headers.get(name.toLowerCase());\n\t\treturn values && values.length > 0 ? values[0] : null;\n\t}\n\n\tkeys(): string[] {\n\t\tthis.init();\n\t\treturn Array.from(this.normalizedNames.values());\n\t}\n\n\tgetAll(name: string): string[] | null {\n\t\tthis.init();\n\t\treturn this.headers.get(name.toLowerCase()) || null;\n\t}\n\n\tappend(name: string, value: string | string[]): HttpHeaders {\n\t\treturn this.clone({ name, value, operation: 'a' });\n\t}\n\n\tset(name: string, value: string | string[]): HttpHeaders {\n\t\treturn this.clone({ name, value, operation: 's' });\n\t}\n\n\tdelete(name: string, value?: string | string[]): HttpHeaders {\n\t\treturn this.clone({ name, value, operation: 'd' });\n\t}\n\n\tprivate maybeSetNormalizedName(name: string, key: string): void {\n\t\tif (!this.normalizedNames.has(key)) {\n\t\t\tthis.normalizedNames.set(key, name);\n\t\t}\n\t}\n\n\tprivate init(): void {\n\t\tif (!!this.lazyInit) {\n\t\t\tif (this.lazyInit instanceof HttpHeaders) {\n\t\t\t\tthis.copyFrom(this.lazyInit);\n\t\t\t} else {\n\t\t\t\tthis.lazyInit();\n\t\t\t}\n\t\t\tthis.lazyInit = null;\n\t\t\tif (!!this.lazyUpdate) {\n\t\t\t\tthis.lazyUpdate.forEach(update => this.applyUpdate(update));\n\t\t\t\tthis.lazyUpdate = null;\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate copyFrom(other: HttpHeaders) {\n\t\tother.init();\n\t\tArray.from(other.headers.keys()).forEach(key => {\n\t\t\tthis.headers.set(key, other.headers.get(key)!);\n\t\t\tthis.normalizedNames.set(key, other.normalizedNames.get(key)!);\n\t\t});\n\t}\n\n\tprivate clone(update: Update): HttpHeaders {\n\t\tconst clone = new HttpHeaders();\n\t\tclone.lazyInit =\n\t\t\t(!!this.lazyInit && this.lazyInit instanceof HttpHeaders) ? this.lazyInit : this;\n\t\tclone.lazyUpdate = (this.lazyUpdate || []).concat([update]);\n\t\treturn clone;\n\t}\n\n\tprivate applyUpdate(update: Update): void {\n\t\tconst key = update.name.toLowerCase();\n\t\tswitch (update.operation) {\n\t\t\tcase 'a':\n\t\t\tcase 's':\n\t\t\t\tlet value = update.value!;\n\t\t\t\tif (typeof value === 'string') {\n\t\t\t\t\tvalue = [value];\n\t\t\t\t}\n\t\t\t\tif (value.length === 0) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tthis.maybeSetNormalizedName(update.name, key);\n\t\t\t\tconst base = (update.op === 'a' ? this.headers.get(key) : undefined) || [];\n\t\t\t\tbase.push(...value);\n\t\t\t\tthis.headers.set(key, base);\n\t\t\t\tbreak;\n\t\t\tcase 'd':\n\t\t\t\tconst toDelete = update.value as string | undefined;\n\t\t\t\tif (!toDelete) {\n\t\t\t\t\tthis.headers.delete(key);\n\t\t\t\t\tthis.normalizedNames.delete(key);\n\t\t\t\t} else {\n\t\t\t\t\tlet existing = this.headers.get(key);\n\t\t\t\t\tif (!existing) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\texisting = existing.filter(value => toDelete.indexOf(value) === -1);\n\t\t\t\t\tif (existing.length === 0) {\n\t\t\t\t\t\tthis.headers.delete(key);\n\t\t\t\t\t\tthis.normalizedNames.delete(key);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.headers.set(key, existing);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tforEach(fn: (name: string, values: string[]) => void) {\n\t\tthis.init();\n\t\tArray.from(this.normalizedNames.keys()).forEach(key => fn(this.normalizedNames.get(key)!, this.headers.get(key)!));\n\t}\n\n}\n*/\n","\n/*\nexport default class HttpErrorResponse extends Error {\n\tstatusCode?: number;\n\tstatusMessage?: string;\n}\n*/\n\nimport { HttpEventType } from './http-event';\nimport { HttpHeaders } from './http-headers';\nimport { HttpRequest } from './http-request';\nimport { IHttpHeaderResponse } from './http-response';\n\nexport interface IHttpJsonParseError {\n\terror: Error;\n\ttext: string;\n}\n\nexport interface IHttpErrorResponse<T> extends IHttpHeaderResponse<T> {\n\terror?: any | undefined;\n\tmessage?: string;\n\tname?: string;\n\trequest?: HttpRequest<T> | null;\n}\n\nexport class HttpErrorResponse<T> extends Error implements IHttpErrorResponse<T> {\n\treadonly headers!: HttpHeaders;\n\treadonly status: number = 0;\n\treadonly statusText: string = 'Unknown Error';\n\treadonly url: string | undefined;\n\treadonly ok: boolean = false;\n\treadonly type: HttpEventType.ResponseError = HttpEventType.ResponseError;\n\treadonly error: any | undefined;\n\treadonly message: string = 'Unknown Error';\n\treadonly name: string = 'HttpErrorResponse';\n\treadonly request!: HttpRequest<T> | null;\n\tconstructor(options?: IHttpErrorResponse<T>) {\n\t\tsuper(options?.message || 'Unknown Error');\n\t\tif (options) {\n\t\t\tthis.headers = new HttpHeaders(options.headers);\n\t\t\tthis.status = options.status || this.status;\n\t\t\tthis.statusText = options.statusText || this.statusText;\n\t\t\tthis.url = options.url || this.url;\n\t\t\tthis.error = options.error || this.error;\n\t\t\tthis.name = options.name || this.name;\n\t\t\tthis.request = options.request || null;\n\t\t}\n\t}\n\tclone<T>(options?: IHttpErrorResponse<T>): HttpErrorResponse<T> {\n\t\toptions = Object.assign({\n\t\t\theaders: this.headers,\n\t\t\tstatus: this.status,\n\t\t\tstatusText: this.statusText,\n\t\t\turl: this.url,\n\t\t\terror: this.error,\n\t\t\tmessage: this.message,\n\t\t\tname: this.name,\n\t\t\trequest: this.request,\n\t\t}, options || {});\n\t\tconst clone = new HttpErrorResponse<T>(options);\n\t\treturn clone;\n\t}\n}\n\n/*\nexport class HttpErrorResponse<T> extends HttpResponseBase implements Error {\n\treadonly name = 'HttpErrorResponse';\n\treadonly message: string;\n\treadonly error: any | null;\n\treadonly ok = false;\n\tconstructor(errorResponse: IHttpErrorResponse, response: HttpResponse<T> | null = null) {\n\t\tsuper(errorResponse, 0, 'Unknown Error');\n\t\tif (Error.captureStackTrace) {\n\t\t\tError.captureStackTrace(this, HttpErrorResponse);\n\t\t}\n\t\tif (this.status >= 200 && this.status < 300) {\n\t\t\tthis.message = `Http failure during parsing for ${errorResponse.url || '(unknown url)'}`;\n\t\t} else {\n\t\t\tthis.message = `Http failure response for ${errorResponse.url || '(unknown url)'}: ${errorResponse.status} ${errorResponse.statusText}`;\n\t\t}\n\t\tthis.error = errorResponse.error || null;\n\t}\n}\n*/\n","import { HttpEventType, HttpProgressEvent, HttpSentEvent, HttpUserEvent } from './http-event';\nimport { HttpHeaders } from './http-headers';\nimport { HttpBodyType } from './http-request';\n\nexport type HttpEvent<T> = HttpSentEvent | HttpHeaderResponse<T> | HttpResponse<T> | HttpProgressEvent | HttpUserEvent<T>;\n\nexport interface IHttpHeaderResponse<T> {\n\theaders?: HttpHeaders,\n\tstatus?: number,\n\tstatusText?: string,\n\turl?: string,\n\tok?: boolean;\n\ttype?: HttpEventType;\n}\n\nexport interface IHttpResponse<T> extends IHttpHeaderResponse<T> {\n\tbody?: HttpBodyType;\n}\n\nexport class HttpHeaderResponse<T> implements IHttpHeaderResponse<T> {\n\treadonly headers!: HttpHeaders;\n\treadonly status: number = 200;\n\treadonly statusText: string = 'OK';\n\treadonly url: string | undefined;\n\treadonly ok: boolean;\n\treadonly type: HttpEventType.ResponseHeader = HttpEventType.ResponseHeader;\n\tconstructor(options?: IHttpHeaderResponse<T>) {\n\t\tif (options) {\n\t\t\tthis.headers = new HttpHeaders(options.headers);\n\t\t\tthis.status = options.status || this.status;\n\t\t\tthis.statusText = options.statusText || this.statusText;\n\t\t\tthis.url = options.url || this.url;\n\t\t}\n\t\tthis.ok = this.status >= 200 && this.status < 300;\n\t}\n\tclone<T>(options?: IHttpHeaderResponse<T>): HttpHeaderResponse<T> {\n\t\toptions = Object.assign({\n\t\t\theaders: this.headers,\n\t\t\tstatus: this.status,\n\t\t\tstatusText: this.statusText,\n\t\t\turl: this.url,\n\t\t\tok: this.ok,\n\t\t\ttype: this.type,\n\t\t}, options || {});\n\t\tconst clone = new HttpHeaderResponse<T>(options);\n\t\treturn clone;\n\t}\n}\n\nexport class HttpResponse<T> implements IHttpResponse<T> {\n\treadonly headers!: HttpHeaders;\n\treadonly status: number = 200;\n\treadonly statusText: string = 'OK';\n\treadonly url: string | undefined;\n\treadonly ok: boolean;\n\treadonly type: HttpEventType.Response = HttpEventType.Response;\n\treadonly body: HttpBodyType = null;\n\tconstructor(options?: IHttpResponse<T>) {\n\t\tif (options) {\n\t\t\tthis.headers = new HttpHeaders(options.headers);\n\t\t\tthis.status = options.status || this.status;\n\t\t\tthis.statusText = options.statusText || this.statusText;\n\t\t\tthis.url = options.url || this.url;\n\t\t\tthis.body = options.body || this.body;\n\t\t}\n\t\tthis.ok = this.status >= 200 && this.status < 300;\n\t}\n\tclone<T>(options?: IHttpResponse<T>): HttpResponse<T> {\n\t\toptions = Object.assign({\n\t\t\theaders: this.headers,\n\t\t\tstatus: this.status,\n\t\t\tstatusText: this.statusText,\n\t\t\turl: this.url,\n\t\t\tok: this.ok,\n\t\t\ttype: this.type,\n\t\t\tbody: this.body,\n\t\t}, options || {});\n\t\tconst clone = new HttpResponse<T>(options);\n\t\treturn clone;\n\t}\n}\n\nexport abstract class HttpResponseBase<T> {\n\treadonly headers: HttpHeaders;\n\treadonly status: number = 200;\n\treadonly statusText: string = 'OK';\n\treadonly url: string | undefined;\n\treadonly ok: boolean;\n\treadonly type!: HttpEventType.Response | HttpEventType.ResponseHeader;\n\tconstructor(\n\t\toptions: IHttpHeaderResponse<T>,\n\t\tdefaultStatus: number = 200,\n\t\tdefaultStatusText: string = 'OK'\n\t) {\n\t\tthis.headers = options.headers || new HttpHeaders();\n\t\tthis.status = options.status !== undefined ? options.status : defaultStatus;\n\t\tthis.statusText = options.statusText || defaultStatusText;\n\t\tthis.url = options.url || undefined;\n\t\tthis.ok = this.status >= 200 && this.status < 300;\n\t}\n}\n\n/*\n// !!!\nexport default class HttpResponse {\n\tdata?: any;\n\turl: string = '';\n\tstatus: number = 0;\n\tstatusText: string = '';\n\tok: boolean = false;\n\tredirected: boolean = false;\n\tget static() {\n\t\treturn this.url!.indexOf('.json') === this.url!.length - 5;\n\t}\n\tconstructor(response: Response) {\n\t\tthis.data = null;\n\t\tif (response) {\n\t\t\tthis.url = response.url;\n\t\t\tthis.status = response.status;\n\t\t\tthis.statusText = response.statusText;\n\t\t\tthis.ok = response.ok;\n\t\t\tthis.redirected = response.redirected;\n\t\t}\n\t}\n}\n*/\n","import { isPlatformBrowser, nextError$ } from 'rxcomp';\nimport { from, Observable, of } from 'rxjs';\nimport { catchError, finalize } from 'rxjs/operators';\nimport { HttpErrorResponse, IHttpErrorResponse } from './http-error-response';\nimport { HttpHandler } from './http-handler';\nimport { HttpRequest } from './http-request';\nimport { HttpEvent, HttpResponse, IHttpResponse } from './http-response';\n\nexport class HttpFetchHandler implements HttpHandler {\n\n\tprivate response_: HttpResponse<any> | null = null;\n\n\thandle<T>(request: HttpRequest<any>): Observable<HttpEvent<T>> {\n\t\tif (!request.method) {\n\t\t\tthrow new Error(`missing method`);\n\t\t}\n\t\tconst requestInfo: RequestInfo = request.urlWithParams;\n\t\tconst requestInit: RequestInit = request.toInitRequest();\n\t\t// const fetchRequest: Request = request.toFetchRequest__();\n\t\t// console.log('fetchRequest', fetchRequest);\n\t\t// fetchRequest.headers.forEach((value, key) => console.log('HttpFetchHandler.handle', key, value));\n\t\t// request = request.clone({ headers: fetchRequest.headers });\n\t\t// console.log('HttpFetchHandler.handle', 'requestInfo', requestInfo, 'requestInit', requestInit);\n\t\treturn from(\n\t\t\tfetch(requestInfo, requestInit)\n\t\t\t\t// fetch(fetchRequest)\n\t\t\t\t.then((response: Response) => this.getProgress<T>(response, request))\n\t\t\t\t.then((response: Response | HttpResponse<T>) => this.getResponse<T>(response, request))\n\t\t).pipe(\n\t\t\tcatchError((error: Error) => {\n\t\t\t\tconst errorResponse: IHttpErrorResponse<T> = { error };\n\t\t\t\tif (this.response_) {\n\t\t\t\t\terrorResponse.headers = this.response_.headers;\n\t\t\t\t\terrorResponse.status = this.response_.status;\n\t\t\t\t\terrorResponse.statusText = this.response_.statusText;\n\t\t\t\t\terrorResponse.url = this.response_.url;\n\t\t\t\t\terrorResponse.request = request;\n\t\t\t\t}\n\t\t\t\tconst httpErrorResponse = new HttpErrorResponse<T>(errorResponse);\n\t\t\t\t// console.log('httpErrorResponse', httpErrorResponse);\n\t\t\t\tnextError$.next(httpErrorResponse);\n\t\t\t\treturn of(this.response_) as Observable<any>;\n\t\t\t\t// return throwError(httpErrorResponse);\n\t\t\t}),\n\t\t\tfinalize(() => {\n\t\t\t\tthis.response_ = null;\n\t\t\t})\n\t\t);\n\t}\n\n\t/*\n\tonProgress(value: Uint8Array, done: boolean, request, reader, progress) {\n\t\tconsole.log(\"value:\", value);\n\t\tif (value || done) {\n\t\t\tconsole.log(\"upload complete, request.bodyUsed:\", request.bodyUsed);\n\t\t\tprogress.value = progress.max;\n\t\t\treturn reader.closed.then(() => fileUpload);\n\t\t};\n\t\tconsole.log(\"upload progress:\", value);\n\t\tif (progress.value < file.size) {\n\t\t\tprogress.value += 1;\n\t\t}\n\t\treturn reader.read().then(({ value, done }) => this.onProgress(value, done, request, reader, progress));\n\t};\n\n\tgetProgress_(request) {\n\t\tconst uploadProgress = new ReadableStream({\n\t\t\tstart(controller) {\n\t\t\t\tconsole.log(\"starting upload, request.bodyUsed:\", request.bodyUsed);\n\t\t\t\tcontroller.enqueue(request.bodyUsed);\n\t\t\t},\n\t\t\tpull(controller) {\n\t\t\t\tif (request.bodyUsed) {\n\t\t\t\t\tcontroller.close();\n\t\t\t\t}\n\t\t\t\tcontroller.enqueue(request.bodyUsed);\n\t\t\t\tconsole.log(\"pull, request.bodyUsed:\", request.bodyUsed);\n\t\t\t},\n\t\t\tcancel(reason) {\n\t\t\t\tconsole.log(reason);\n\t\t\t}\n\t\t});\n\n\t\tconst [fileUpload, reader] = [\n\t\t\tupload(request).catch(e => {\n\t\t\t\treader.cancel();\n\t\t\t\tconsole.log(e);\n\t\t\t\tthrow e\n\t\t\t}), uploadProgress.getReader()\n\t\t];\n\t}\n\t*/\n\n\tgetProgress<T>(response: Response, request: HttpRequest<any>): Promise<Response | HttpResponse<T>> {\n\t\t// console.log('HttpFetchHandler.setProgress', request.reportProgress, response.body);\n\t\tconst clonedBody = response.clone().body;\n\t\tif (isPlatformBrowser && request.reportProgress && clonedBody) {\n\t\t\tconst reader: ReadableStreamDefaultReader<Uint8Array> = clonedBody.getReader();\n\t\t\tconst contentLength = response.headers && response.headers.has('Content-Length') ? +(response.headers.get('Content-Length') || 0) : 0;\n\t\t\treturn new Promise((resolve, reject) => {\n\t\t\t\t/*\n\t\t\t\tlet receivedLength = 0; // received that many bytes at the moment\n\t\t\t\tconst chunks: Uint8Array[] = []; // array of received binary chunks (comprises the body)\n\t\t\t\tconst getChunk = () => {\n\t\t\t\t\treturn reader.read().then(({ done, value }) => {\n\t\t\t\t\t\tif (!done) {\n\t\t\t\t\t\t\tif (value) {\n\t\t\t\t\t\t\t\tchunks.push(value);\n\t\t\t\t\t\t\t\treceivedLength += value.length || 0;\n\t\t\t\t\t\t\t\tconsole.log(`HttpFetchHandler.setProgress ${(receivedLength / contentLength * 100).toFixed(2)}% ${receivedLength} of ${contentLength}`);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tgetChunk();\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treader.cancel();\n\t\t\t\t\t\t\tresolve(response);\n\t\t\t\t\t\t\tif (false) {\n\t\t\t\t\t\t\t\t// Step 4: concatenate chunks into single Uint8Array\n\t\t\t\t\t\t\t\tconst chunksAll = new Uint8Array(receivedLength); // (4.1)\n\t\t\t\t\t\t\t\tlet position = 0;\n\t\t\t\t\t\t\t\tfor (let chunk of chunks) {\n\t\t\t\t\t\t\t\t\tchunksAll.set(chunk, position); // (4.2)\n\t\t\t\t\t\t\t\t\tposition += chunk.length;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// Step 5: decode into a string\n\t\t\t\t\t\t\t\tconst result = new TextDecoder(\"utf-8\").decode(chunksAll);\n\t\t\t\t\t\t\t\t// We're done!\n\t\t\t\t\t\t\t\tconst data = JSON.parse(result);\n\t\t\t\t\t\t\t\tconsole.log('HttpFetchHandler.setProgress data', data);\n\t\t\t\t\t\t\t\tresolve(response);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}).catch(error => {\n\t\t\t\t\t\treader.cancel();\n\t\t\t\t\t\treject(error);\n\t\t\t\t\t});\n\t\t\t\t};\n\t\t\t\tgetChunk();\n\t\t\t\t*/\n\t\t\t\tconst progress = { progress: 0, percent: 0, current: 0, total: 0 };\n\t\t\t\tconst onProgress = (value: Uint8Array | undefined, done: boolean): Promise<any> => {\n\t\t\t\t\tlet receivedLength = progress.current;\n\t\t\t\t\tif (!done) {\n\t\t\t\t\t\tif (value) {\n\t\t\t\t\t\t\treceivedLength += value.length || 0;\n\t\t\t\t\t\t\tprogress.total = contentLength;\n\t\t\t\t\t\t\tprogress.current = receivedLength;\n\t\t\t\t\t\t\tprogress.progress = receivedLength / contentLength;\n\t\t\t\t\t\t\tprogress.percent = progress.progress * 100;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// console.log('progress', progress);\n\t\t\t\t\t\treturn reader.read().then(({ value, done }) => onProgress(value, done));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tprogress.total = contentLength;\n\t\t\t\t\t\tprogress.current = contentLength;\n\t\t\t\t\t\tprogress.progress = 1;\n\t\t\t\t\t\tprogress.percent = 100;\n\t\t\t\t\t\t// console.log('progress', progress);\n\t\t\t\t\t\treturn reader.closed.then(() => response.clone());\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\treader.read()\n\t\t\t\t\t.then(({ value, done }) => onProgress(value, done))\n\t\t\t\t\t.then(response => {\n\t\t\t\t\t\tthis.response_ = new HttpResponse<T>(response as unknown as IHttpResponse<T>);\n\t\t\t\t\t\tif (typeof (response as any)[request.responseType] === 'function') {\n\t\t\t\t\t\t\treturn (response as any)[request.responseType]().then((json: any) => {\n\t\t\t\t\t\t\t\tthis.response_ = new HttpResponse<T>(Object.assign(this.response_, { body: json }) as IHttpResponse<T>);\n\t\t\t\t\t\t\t\tif (response.ok) {\n\t\t\t\t\t\t\t\t\treturn resolve(this.response_);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\treturn reject(this.response_);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn reject(this.response_);\n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\t\t\t\t\t.catch(err => console.log(\"upload error:\", err));\n\t\t\t});\n\t\t} else {\n\t\t\treturn Promise.resolve(response);\n\t\t}\n\t}\n\n\tgetResponse<T>(response: Response | HttpResponse<T>, request: HttpRequest<any>): Promise<HttpResponse<T>> {\n\t\tthis.response_ = new HttpResponse<T>(response as IHttpResponse<T>);\n\t\tif (isPlatformBrowser && request.reportProgress && response.body) {\n\t\t\treturn Promise.resolve(this.response_);\n\t\t} else {\n\t\t\treturn this.getResponseType(response as Response, request);\n\t\t}\n\t}\n\n\tgetResponseType<T>(response: Response, request: HttpRequest<any>): Promise<HttpResponse<T>> {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tthis.response_ = new HttpResponse<T>(response as unknown as IHttpResponse<T>);\n\t\t\tif (typeof (response as any)[request.responseType] === 'function') {\n\t\t\t\treturn (response as any)[request.responseType]().then((json: any) => {\n\t\t\t\t\tthis.response_ = new HttpResponse<T>(Object.assign(this.response_, { body: json }) as IHttpResponse<T>);\n\t\t\t\t\tif (response.ok) {\n\t\t\t\t\t\treturn resolve(this.response_);\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn reject(this.response_);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\treturn reject(this.response_);\n\t\t\t}\n\t\t});\n\t}\n\n\tgetReadableStream<T>(response: Response, request: HttpRequest<any>): ReadableStream {\n\t\tconst reader = response.body!.getReader();\n\t\tconst readableStream = new ReadableStream({\n\t\t\tstart(controller) {\n\t\t\t\t// console.log(\"starting upload, request.bodyUsed:\", request.bodyUsed);\n\t\t\t\t// controller.enqueue(request.bodyUsed);\n\t\t\t\t// The following function handles each data chunk\n\t\t\t\tconst push = function () {\n\t\t\t\t\t// \"done\" is a Boolean and value a \"Uint8Array\"\n\t\t\t\t\treader.read().then(({ done, value }) => {\n\t\t\t\t\t\t// Is there no more data to read?\n\t\t\t\t\t\tif (done) {\n\t\t\t\t\t\t\t// Tell the browser that we have finished sending data\n\t\t\t\t\t\t\tcontroller.close();\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Get the data and send it to the browser via the controller\n\t\t\t\t\t\tcontroller.enqueue(value);\n\t\t\t\t\t\tpush();\n\t\t\t\t\t});\n\t\t\t\t};\n\t\t\t\tpush();\n\t\t\t},\n\t\t\t/*\n\t\t\tpull(controller) {\n\t\t\t\tif (request.bodyUsed) {\n\t\t\t\t\tcontroller.close();\n\t\t\t\t}\n\t\t\t\tcontroller.enqueue(request.bodyUsed);\n\t\t\t\tconsole.log(\"pull, request.bodyUsed:\", request.bodyUsed);\n\t\t\t},\n\t\t\tcancel(reason) {\n\t\t\t\tconsole.log(reason);\n\t\t\t}\n\t\t\t*/\n\t\t});\n\t\treturn readableStream;\n\t}\n\n}\n","import { Observable } from 'rxjs';\nimport { HttpFetchHandler } from './http-fetch.handler';\nimport { HttpHandler } from './http-handler';\nimport { HttpRequest } from './http-request';\nimport { HttpEvent } from './http-response';\nimport { HttpXhrHandler } from './http-xhr.handler';\n\nexport interface HttpInterceptor {\n\tintercept(req: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>>;\n}\n\nexport class HttpInterceptorHandler implements HttpHandler {\n\tconstructor(private next: HttpHandler, private interceptor: HttpInterceptor) { }\n\thandle(req: HttpRequest<any>): Observable<HttpEvent<any>> {\n\t\treturn this.interceptor.intercept(req, this.next);\n\t}\n}\n\nexport const HttpInterceptors: HttpInterceptor[] = [];\n\nexport class NoopInterceptor implements HttpInterceptor {\n\tintercept(req: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {\n\t\treturn next.handle(req);\n\t}\n}\n\nexport const fetchHandler: HttpHandler = new HttpFetchHandler();\nexport const xhrHandler: HttpHandler = new HttpXhrHandler();\n\nexport class HttpInterceptingHandler implements HttpHandler {\n\tprivate chain: HttpHandler | null = null;\n\thandle(req: HttpRequest<any>): Observable<HttpEvent<any>> {\n\t\tif (this.chain === null) {\n\t\t\tconst interceptors = HttpInterceptors;\n\t\t\tthis.chain = interceptors.reduceRight((next, interceptor) => new HttpInterceptorHandler(next, interceptor), fetchHandler);\n\t\t}\n\t\treturn this.chain.handle(req);\n\t}\n}\n\nexport function interceptingHandler(handler: HttpHandler, interceptors: HttpInterceptor[] | null = []): HttpHandler {\n\tif (!interceptors) {\n\t\treturn handler;\n\t}\n\treturn interceptors.reduceRight((next, interceptor) => new HttpInterceptorHandler(next, interceptor), handler);\n}\n\nexport function jsonpCallbackContext(): Object {\n\tif (typeof window === 'object') {\n\t\treturn window;\n\t}\n\treturn {};\n}\n","\nexport interface IHttpParamEncoder {\n\tencodeKey(key: string): string;\n\tencodeValue(value: string): string;\n\tdecodeKey(key: string): string;\n\tdecodeValue(value: string): string;\n}\n\nexport class HttpUrlEncodingCodec implements IHttpParamEncoder {\n\tencodeKey(key: string): string {\n\t\treturn encodeParam_(key);\n\t}\n\tencodeValue(value: string): string {\n\t\treturn encodeParam_(value);\n\t}\n\tdecodeKey(key: string): string {\n\t\treturn decodeURIComponent(key);\n\t}\n\tdecodeValue(value: string) {\n\t\treturn decodeURIComponent(value);\n\t}\n}\n\nexport class HttpParams {\n\tprivate params_: Map<string, string[]> = new Map<string, string[]>();\n\tprivate encoder: IHttpParamEncoder;\n\n\tconstructor(options?: HttpParams | { [key: string]: any } | string | undefined, encoder: IHttpParamEncoder = new HttpUrlEncodingCodec()) {\n\t\tthis.encoder = encoder;\n\t\tconst params = this.params_;\n\t\tif (options instanceof HttpParams) {\n\t\t\toptions.params_.forEach((value, key) => {\n\t\t\t\tparams.set(key, value);\n\t\t\t});\n\t\t} else if (typeof options === 'object') {\n\t\t\tObject.keys(options).forEach(key => {\n\t\t\t\tconst value = options[key];\n\t\t\t\tparams.set(key, Array.isArray(value) ? value : [value]);\n\t\t\t});\n\t\t} else if (typeof options === 'string') {\n\t\t\tparseRawParams_(params, options, this.encoder);\n\t\t}\n\t\t// ?updates=null&cloneFrom=null&encoder=%5Bobject%20Object%5D&params_=%5Bobject%20Map%5D\n\t}\n\n\tkeys(): string[] {\n\t\treturn Array.from(this.params_.keys());\n\t}\n\n\thas(key: string): boolean {\n\t\treturn this.params_.has(key);\n\t}\n\n\tget(key: string): string | null {\n\t\tconst value = this.params_.get(key);\n\t\treturn value ? value[0] : null;\n\t}\n\n\tgetAll(key: string): string[] | null {\n\t\treturn this.params_.get(key) || null;\n\t}\n\n\tset(key: string, value: string): HttpParams {\n\t\tconst clone = this.clone_();\n\t\tclone.params_.set(key, [value]);\n\t\treturn clone;\n\t}\n\n\tappend(key: string, value: string): HttpParams {\n\t\tconst clone = this.clone_();\n\t\tif (clone.has(key)) {\n\t\t\tconst values = clone.params_.get(key) || [];\n\t\t\tvalues.push(value);\n\t\t\tclone.params_.set(key, values);\n\t\t} else {\n\t\t\tclone.params_.set(key, [value]);\n\t\t}\n\t\treturn clone;\n\t}\n\n\tdelete(key: string): HttpParams {\n\t\tconst clone = this.clone_();\n\t\tclone.params_.delete(key);\n\t\treturn clone;\n\t}\n\n\ttoString(): string {\n\t\treturn this.keys().map((key: string) => {\n\t\t\tconst values = this.params_.get(key);\n\t\t\treturn this.encoder.encodeKey(key) + (values ? '=' + values.map(x => this.encoder.encodeValue(x)).join('&') : '');\n\t\t}).filter(keyValue => keyValue !== '').join('&');\n\t}\n\n\tprivate clone_(): HttpParams {\n\t\tconst clone = new HttpParams(undefined, this.encoder);\n\t\tthis.params_.forEach((value, key) => {\n\t\t\tclone.params_.set(key, value);\n\t\t});\n\t\treturn clone;\n\t}\n}\n\nfunction parseRawParams_(params: Map<string, string[]>, queryString: string, encoder: IHttpParamEncoder): Map<string, string[]> {\n\tif (queryString.length > 0) {\n\t\tconst keyValueParams: string[] = queryString.split('&');\n\t\tkeyValueParams.forEach((keyValue: string) => {\n\t\t\tconst index = keyValue.indexOf('=');\n\t\t\tconst [key, value]: string[] = index == -1 ? [encoder.decodeKey(keyValue), ''] : [encoder.decodeKey(keyValue.slice(0, index)), encoder.decodeValue(keyValue.slice(index + 1))];\n\t\t\tconst values = params.get(key) || [];\n\t\t\tvalues.push(value);\n\t\t\tparams.set(key, values);\n\t\t});\n\t}\n\treturn params;\n}\n\nfunction encodeParam_(v: string): string {\n\treturn encodeURIComponent(v)\n\t\t.replace(/%40/gi, '@')\n\t\t.replace(/%3A/gi, ':')\n\t\t.replace(/%24/gi, '$')\n\t\t.replace(/%2C/gi, ',')\n\t\t.replace(/%3B/gi, ';')\n\t\t.replace(/%2B/gi, '+')\n\t\t.replace(/%3D/gi, '=')\n\t\t.replace(/%3F/gi, '?')\n\t\t.replace(/%2F/gi, '/');\n}\n","import { HttpHeaders } from './http-headers';\nimport { HttpParams } from './http-params';\n\nexport type HttpMethodType = 'GET' | 'POST' | 'PUT' | 'PATCH' | 'DELETE' | 'OPTIONS' | 'HEAD' | 'JSONP';\nexport type HttpMethodBodyType = 'POST' | 'PUT' | 'PATCH';\nexport type HttpMethodNoBodyType = 'GET' | 'DELETE' | 'OPTIONS' | 'HEAD' | 'JSONP';\nexport type HttpResponseType = 'arraybuffer' | 'blob' | 'json' | 'text';\nexport type HttpBodyType<T> = T | string | Blob | ArrayBufferView | ArrayBuffer | FormData | URLSearchParams | ReadableStream<Uint8Array> | null | undefined;\nexport type HttpObserveType = 'body' | 'events' | 'response';\n\nexport interface IHttpRequestInit<T> {\n\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined;\n\treportProgress?: boolean;\n\tparams?: HttpParams | { [key: string]: any } | string | undefined;\n\tresponseType?: HttpResponseType;\n\twithCredentials?: boolean;\n\tobserve?: HttpObserveType;\n\tbody?: HttpBodyType<T>;\n}\n\nexport interface IHttpRequest<T> extends IHttpRequestInit<T> {\n\tmethod?: HttpMethodType,\n\turl?: string,\n}\n\nexport class HttpRequest<T> {\n\treadonly body: HttpBodyType<T>;\n\treadonly headers!: HttpHeaders;\n\treadonly reportProgress: boolean = false;\n\treadonly withCredentials: boolean = false;\n\treadonly observe: HttpObserveType = 'body';\n\treadonly responseType: HttpResponseType = 'json';\n\treadonly method: HttpMethodType;\n\treadonly params!: HttpParams;\n\treadonly urlWithParams: string;\n\tconstructor(method: HttpMethodNoBodyType, url: string, options?: IHttpRequestInit<T>);\n\tconstructor(method: HttpMethodBodyType, url: string, body: HttpBodyType<T>, options?: IHttpRequestInit<T>);\n\tconstructor(method: HttpMethodType, url: string, body: HttpBodyType<T>, options?: IHttpRequestInit<T>);\n\tconstructor(method: HttpMethodType, readonly url: string, third?: HttpBodyType<T> | IHttpRequestInit<T> | null, fourth?: IHttpRequestInit<T>) {\n\t\t// !!! remove, rethink\n\t\tconst isStaticFile: boolean = /\\.(json|xml|txt)(\\?.*)?$/.test(url);\n\t\tthis.method = isStaticFile ? 'GET' : method.toUpperCase() as HttpMethodType;\n\t\tlet options: IHttpRequestInit<T> | undefined;\n\t\tif (methodHasBody(this.method) || !!fourth) {\n\t\t\tthis.body = (third !== undefined) ? third as HttpBodyType<T> : null;\n\t\t\toptions = fourth;\n\t\t} else {\n\t\t\toptions = third as IHttpRequestInit<T>;\n\t\t}\n\t\tif (options) {\n\t\t\tthis.reportProgress = !!options.reportProgress;\n\t\t\tthis.withCredentials = !!options.withCredentials;\n\t\t\tthis.observe = options.observe || this.observe;\n\t\t\tif (options.responseType) {\n\t\t\t\tthis.responseType = options.responseType;\n\t\t\t}\n\t\t\tif (options.headers) {\n\t\t\t\tthis.headers = new HttpHeaders(options.headers);\n\t\t\t}\n\t\t\tif (options.params) {\n\t\t\t\tthis.params = new HttpParams(options.params);\n\t\t\t}\n\t\t}\n\t\tif (!this.headers) {\n\t\t\tthis.headers = new HttpHeaders();\n\t\t}\n\t\tif (!this.params) {\n\t\t\tthis.params = new HttpParams();\n\t\t}\n\t\tconst params = this.params.toString();\n\t\tconst index = url.indexOf('?');\n\t\tconst sep: string = index === -1 ? '?' : (index < url.length - 1 ? '&' : '');\n\t\tthis.urlWithParams = url + (params.length ? sep + params : params);\n\t}\n\tserializeBody(): ArrayBuffer | Blob | FormData | string | null {\n\t\tif (this.body === null) {\n\t\t\treturn null;\n\t\t}\n\t\tif (isArrayBuffer(this.body) || isBlob(this.body) || isFormData(this.body) ||\n\t\t\ttypeof this.body === 'string') {\n\t\t\treturn this.body;\n\t\t}\n\t\tif (this.body instanceof HttpParams) {\n\t\t\treturn (<any>this.body).toString();\n\t\t}\n\t\tif (typeof this.body === 'object' || typeof this.body === 'boolean' || Array.isArray(this.body)) {\n\t\t\treturn JSON.stringify(this.body);\n\t\t}\n\t\treturn (this.body as any).toString();\n\t}\n\tdetectContentTypeHeader(): string | null {\n\t\tif (this.body === null) {\n\t\t\treturn null;\n\t\t}\n\t\tif (isFormData(this.body)) {\n\t\t\treturn null;\n\t\t}\n\t\tif (isBlob(this.body)) {\n\t\t\treturn this.body.type || null;\n\t\t}\n\t\tif (isArrayBuffer(this.body)) {\n\t\t\treturn null;\n\t\t}\n\t\tif (typeof this.body === 'string') {\n\t\t\treturn 'text/plain';\n\t\t}\n\t\tif (this.body instanceof HttpParams) {\n\t\t\treturn 'application/x-www-form-urlencoded;charset=UTF-8';\n\t\t}\n\t\tif (typeof this.body === 'object' || typeof this.body === 'number' ||\n\t\t\tArray.isArray(this.body)) {\n\t\t\treturn 'application/json';\n\t\t}\n\t\treturn null;\n\t}\n\ttoInitRequest(): RequestInit {\n\t\treturn {\n\t\t\tmethod: this.method,\n\t\t\theaders: this.headers.serialize(),\n\t\t\tbody: this.serializeBody(),\n\t\t\tmode: 'same-origin', // 'cors' | 'navigate' | 'no-cors' | 'same-origin',\n\t\t\tcredentials: 'same-origin',\n\t\t\tcache: 'default', // 'default' | 'force-cache' | 'no-cache' | 'no-store' | 'only-if-cached' | 'reload',\n\t\t\tredirect: 'error', // 'error' | 'follow' | 'manual';\n\t\t\t// referrer: '',\n\t\t\t// integrity: '',\n\t\t\t// keepalive: false,\n\t\t\t// referrerPolicy: ''; // '' | 'no-referrer' | 'no-referrer-when-downgrade' | 'origin' | 'origin-when-cross-origin' | 'same-origin' | 'strict-origin' | 'strict-origin-when-cross-origin' | 'unsafe-url',\n\t\t\t// signal: null,\n\t\t\t// window,\n\t\t\t// method: The request method, e.g., GET, POST. The default is GET.\n\t\t\t// headers: Any headers you want to add to your request, contained within a Headers object or an object literal with ByteString values.\n\t\t\t// body: Any body that you want to add to your request: this can be a Blob, BufferSource, FormData, URLSearchParams, USVString, or ReadableStream object. Note that a request using the GET or HEAD method cannot have a body.\n\t\t\t// mode: The mode you want to use for the request, e.g., cors, no-cors, same-origin, or navigate. The default is cors.\n\t\t\t// credentials: The request credentials you want to use for the request: omit, same-origin, or include. The default is same-origin.\n\t\t\t// cache: The cache mode you want to use for the request.\n\t\t\t// redirect: The redirect mode to use: follow, error, or manual. The default is follow.\n\t\t\t// referrer: A USVString specifying no-referrer, client, or a URL. The default is about:client.\n\t\t\t// integrity: Contains the subresource integrity value of the request (e.g., sha256-BpfBw7ivV8q2jLiT13fxDYAe2tJllusRSZ273h2nFSE=).\n\t\t}\n\t}\n\ttoFetchRequest__(): Request {\n\t\treturn new Request(this.urlWithParams, this.toInitRequest());\n\t\t/*\n\t\tRequest.cache Read only\n\t\tContains the cache mode of the request (e.g., default, reload, no-cache).\n\t\tRequest.context Read only\n\t\tContains the context of the request (e.g., audio, image, iframe, etc.)\n\t\tRequest.credentials Read only\n\t\tContains the credentials of the request (e.g., omit, same-origin, include). The default is same-origin.\n\t\tRequest.destination Read only\n\t\tReturns a string from the RequestDestination enum describing the request's destination. This is a string indicating the type of content being requested.\n\t\tRequest.headers Read only\n\t\tContains the associated Headers object of the request.\n\t\tRequest.integrity Read only\n\t\tContains the subresource integrity value of the request (e.g., sha256-BpfBw7ivV8q2jLiT13fxDYAe2tJllusRSZ273h2nFSE=).\n\t\tRequest.method Read only\n\t\tContains the request's method (GET, POST, etc.)\n\t\tRequest.mode Read only\n\t\tContains the mode of the request (e.g., cors, no-cors, same-origin, navigate.)\n\t\tRequest.redirect Read only\n\t\tContains the mode for how redirects are handled. It may be one of follow, error, or manual.\n\t\tRequest.referrer Read only\n\t\tContains the referrer of the request (e.g., client).\n\t\tRequest.referrerPolicy Read only\n\t\tContains the referrer policy of the request (e.g., no-referrer).\n\t\tRequest.url Read only\n\t\tContains the URL of the request.\n\t\tRequest implements Body, so it also inherits the following properties:\n\t\tbody Read only\n\t\tA simple getter used to expose a ReadableStream of the body contents.\n\t\tbodyUsed Read only\n\t\tStores a Boolean that declares whether the body has been used in a response yet.\n\t\t*/\n\t}\n\tclone<T>(options?: IHttpRequest<T>): HttpRequest<T> {\n\t\toptions = Object.assign({\n\t\t\theaders: this.headers,\n\t\t\treportProgress: this.reportProgress,\n\t\t\tparams: this.params,\n\t\t\tresponseType: this.responseType,\n\t\t\twithCredentials: this.withCredentials,\n\t\t\tobserve: this.observe,\n\t\t\tbody: this.body,\n\t\t\turl: this.url,\n\t\t\tmethod: this.method,\n\t\t}, options || {}) as IHttpRequestInit<T>;\n\t\tconst clone = new HttpRequest<T>(this.method as HttpMethodBodyType, this.url, this.body as HttpBodyType<T>, options);\n\t\treturn clone;\n\t}\n}\n\nfunction methodHasBody(method: string): boolean {\n\tswitch (method) {\n\t\tcase 'DELETE':\n\t\tcase 'GET':\n\t\tcase 'HEAD':\n\t\tcase 'OPTIONS':\n\t\tcase 'JSONP':\n\t\t\treturn false;\n\t\tdefault:\n\t\t\treturn true;\n\t}\n}\n\nfunction isArrayBuffer(value: any): value is ArrayBuffer {\n\treturn typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer;\n}\n\nfunction isBlob(value: any): value is Blob {\n\treturn typeof Blob !== 'undefined' && value instanceof Blob;\n}\n\nfunction isFormData(value: any): value is FormData {\n\treturn typeof FormData !== 'undefined' && value instanceof FormData;\n}\n","import { BehaviorSubject, Observable, of, throwError } from 'rxjs';\nimport { catchError, concatMap, filter, finalize, map } from 'rxjs/operators';\nimport { HttpErrorResponse, IHttpErrorResponse } from './http-error-response';\nimport { HttpHeaders } from './http-headers';\nimport { HttpInterceptingHandler } from './http-interceptor';\nimport { HttpParams } from './http-params';\nimport { HttpBodyType, HttpMethodType, HttpRequest, IHttpRequestInit } from './http-request';\nimport { HttpEvent, HttpResponse } from './http-response';\n\nexport default class HttpClient {\n\n\tstatic pendingRequests$: BehaviorSubject<number> = new BehaviorSubject<number>(0);\n\n\tstatic incrementPendingRequest() {\n\t\tHttpClient.pendingRequests$.next(HttpClient.pendingRequests$.getValue() + 1);\n\t}\n\n\tstatic decrementPendingRequest() {\n\t\tHttpClient.pendingRequests$.next(HttpClient.pendingRequests$.getValue() - 1);\n\t}\n\n\t// static handler: HttpHandler = new HttpFetchHandler();\n\tstatic handler: HttpInterceptingHandler = new HttpInterceptingHandler();\n\n\tstatic request$<T>(first: HttpMethodType | HttpRequest<T>, url?: string, options: IHttpRequestInit<T> = {}): Observable<HttpEvent<any> | HttpResponse<T> | HttpBodyType<T>> {\n\t\tlet request: HttpRequest<T>;\n\t\tif (first instanceof HttpRequest) {\n\t\t\trequest = first;\n\t\t} else {\n\t\t\tlet headers: HttpHeaders | undefined = undefined;\n\t\t\tif (options.headers instanceof HttpHeaders) {\n\t\t\t\theaders = options.headers;\n\t\t\t} else {\n\t\t\t\theaders = new HttpHeaders(options.headers);\n\t\t\t}\n\t\t\tlet params: HttpParams | undefined = undefined;\n\t\t\tif (options.params) {\n\t\t\t\tparams = new HttpParams(options.params);\n\t\t\t}\n\t\t\trequest = new HttpRequest(first, url!, (options.body !== undefined ? options.body : null), {\n\t\t\t\theaders,\n\t\t\t\tparams,\n\t\t\t\treportProgress: options.reportProgress,\n\t\t\t\tresponseType: options.responseType || 'json',\n\t\t\t\twithCredentials: options.withCredentials,\n\t\t\t});\n\t\t}\n\t\t// console.log('HttpClient.request$', request);\n\t\tHttpClient.incrementPendingRequest();\n\t\tconst events$: Observable<HttpEvent<any>> = of(request).pipe(\n\t\t\tconcatMap((request: HttpRequest<T>) => this.handler.handle(request)),\n\t\t\t// tap((response: HttpEvent<any>) => console.log('HttpClient.response', response)),\n\t\t\tfinalize(() => HttpClient.decrementPendingRequest())\n\t\t);\n\t\tif (first instanceof HttpRequest || options.observe === 'events') {\n\t\t\treturn events$.pipe(\n\t\t\t\tcatchError(error => {\n\t\t\t\t\tconsole.log('error', error);\n\t\t\t\t\treturn throwError(this.getError(error, null, request));\n\t\t\t\t}),\n\t\t\t);\n\t\t}\n\t\tconst response$: Observable<HttpResponse<T>> = <Observable<HttpResponse<T>>>events$.pipe(\n\t\t\tfilter((event: HttpEvent<any>) => event instanceof HttpResponse),\n\t\t);\n\t\tlet response_: HttpResponse<T>;\n\t\tconst observe$: Observable<HttpResponse<T> | HttpBodyType<T>> = response$.pipe(\n\t\t\tmap((response: HttpResponse<T>) => {\n\t\t\t\tresponse_ = response;\n\t\t\t\tswitch (options.observe || 'body') {\n\t\t\t\t\tcase 'body':\n\t\t\t\t\t\tswitch (request.responseType) {\n\t\t\t\t\t\t\tcase 'arraybuffer':\n\t\t\t\t\t\t\t\tif (response.body !== null && !(response.body instanceof ArrayBuffer)) {\n\t\t\t\t\t\t\t\t\tthrow new Error('Response is not an ArrayBuffer.');\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\treturn response.body;\n\t\t\t\t\t\t\tcase 'blob':\n\t\t\t\t\t\t\t\tif (response.body !== null && !(response.body instanceof Blob)) {\n\t\t\t\t\t\t\t\t\tthrow new Error('Response is not a Blob.');\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\treturn response.body;\n\t\t\t\t\t\t\tcase 'text':\n\t\t\t\t\t\t\t\tif (response.body !== null && typeof response.body !== 'string') {\n\t\t\t\t\t\t\t\t\tthrow new Error('Response is not a string.');\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\treturn response.body;\n\t\t\t\t\t\t\tcase 'json':\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\treturn response.body;\n\t\t\t\t\t\t}\n\t\t\t\t\tcase 'response':\n\t\t\t\t\t\treturn response;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tthrow new Error(`Unreachable: unhandled observe type ${options.observe}}`);\n\t\t\t\t}\n\t\t\t}),\n\t\t\tcatchError(error => {\n\t\t\t\tconsole.log('error', error);\n\t\t\t\treturn throwError(this.getError(error, response_, request));\n\t\t\t}),\n\t\t)\n\t\treturn observe$;\n\t\tswitch (options.observe || 'body') {\n\t\t\tcase 'body':\n\t\t\t\tswitch (request.responseType) {\n\t\t\t\t\tcase 'arraybuffer':\n\t\t\t\t\t\treturn response$.pipe(map((response: HttpResponse<T>) => {\n\t\t\t\t\t\t\tif (response.body !== null && !(response.body instanceof ArrayBuffer)) {\n\t\t\t\t\t\t\t\tthrow new Error('Response is not an ArrayBuffer.');\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn response.body;\n\t\t\t\t\t\t}));\n\t\t\t\t\tcase 'blob':\n\t\t\t\t\t\treturn response$.pipe(map((response: HttpResponse<T>) => {\n\t\t\t\t\t\t\tif (response.body !== null && !(response.body instanceof Blob)) {\n\t\t\t\t\t\t\t\tthrow new Error('Response is not a Blob.');\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn response.body;\n\t\t\t\t\t\t}));\n\t\t\t\t\tcase 'text':\n\t\t\t\t\t\treturn response$.pipe(map((response: HttpResponse<T>) => {\n\t\t\t\t\t\t\tif (response.body !== null && typeof response.body !== 'string') {\n\t\t\t\t\t\t\t\tthrow new Error('Response is not a string.');\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn response.body;\n\t\t\t\t\t\t}));\n\t\t\t\t\tcase 'json':\n\t\t\t\t\tdefault:\n\t\t\t\t\t\treturn response$.pipe(map((response: HttpResponse<T>) => response.body));\n\t\t\t\t}\n\t\t\tcase 'response':\n\t\t\t\treturn response$;\n\t\t\tdefault:\n\t\t\t\tthrow new Error(`Unreachable: unhandled observe type ${options.observe}}`);\n\t\t}\n\t}\n\n\tstatic delete$<T>(url: string, options?: IHttpRequestInit<T>): Observable<T>;\n\tstatic delete$<T>(url: string, options: IHttpRequestInit<T> = {}): Observable<HttpEvent<any> | HttpResponse<T> | HttpBodyType<T>> {\n\t\treturn this.request$<T>('DELETE', url, options);\n\t}\n\n\tstatic get$<T>(url: string, options?: IHttpRequestInit<T>): Observable<T>;\n\tstatic get$<T>(url: string, options: IHttpRequestInit<T> = {}): Observable<HttpEvent<any> | HttpResponse<T> | HttpBodyType<T>> {\n\t\treturn this.request$<T>('GET', url, options);\n\t}\n\n\tstatic head$<T>(url: string, options?: IHttpRequestInit<T>): Observable<T>;\n\tstatic head$<T>(url: string, options: IHttpRequestInit<T> = {}): Observable<HttpEvent<any> | HttpResponse<T> | HttpBodyType<T>> {\n\t\treturn this.request$<T>('HEAD', url, options);\n\t}\n\n\tstatic jsonp$<T>(url: string, callbackParam: string): Observable<T>;\n\tstatic jsonp$<T>(url: string, callbackParam: string): Observable<HttpEvent<any> | HttpResponse<T> | HttpBodyType<T>> {\n\t\treturn this.request$<T>('JSONP', url, {\n\t\t\tparams: new HttpParams().append(callbackParam, 'JSONP_CALLBACK'),\n\t\t\tobserve: 'body',\n\t\t\tresponseType: 'json',\n\t\t});\n\t}\n\n\tstatic options$<T>(url: string, options?: IHttpRequestInit<T>): Observable<T>;\n\tstatic options$<T>(url: string, options: IHttpRequestInit<T> = {}): Observable<HttpEvent<any> | HttpResponse<T> | HttpBodyType<T>> {\n\t\treturn this.request$<T>('OPTIONS', url, options);\n\t}\n\n\tstatic patch$<T>(url: string, body: any | null, options?: IHttpRequestInit<T>): Observable<T>;\n\tstatic patch$<T>(url: string, body: any | null, options: IHttpRequestInit<T> = {}): Observable<HttpEvent<any> | HttpResponse<T> | HttpBodyType<T>> {\n\t\treturn this.request$<T>('PATCH', url, optionsWithBody_<T>(options, body));\n\t}\n\n\tstatic post$<T>(url: string, body: any | null, options?: IHttpRequestInit<T>): Observable<T>;\n\tstatic post$<T>(url: string, body: any | null, options: IHttpRequestInit<T> = {}): Observable<HttpEvent<any> | HttpResponse<T> | HttpBodyType<T>> {\n\t\treturn this.request$<T>('POST', url, optionsWithBody_<T>(options, body));\n\t}\n\n\tstatic put$<T>(url: string, body: any | null, options?: IHttpRequestInit<T>): Observable<T>;\n\tstatic put$<T>(url: string, body: any | null, options: IHttpRequestInit<T> = {}): Observable<HttpEvent<any> | HttpResponse<T> | HttpBodyType<T>> {\n\t\treturn this.request$<T>('PUT', url, optionsWithBody_<T>(options, body));\n\t}\n\n\tstatic getError<T>(error: any, response: HttpResponse<T> | null, request: HttpRequest<T> | null): HttpErrorResponse<T> {\n\t\tif (!error.status) {\n\t\t\terror.statusCode = response?.status || 0;\n\t\t}\n\t\tif (!error.statusMessage) {\n\t\t\terror.statusMessage = response?.statusText || 'Unknown Error';\n\t\t}\n\t\tconst options: IHttpErrorResponse<T> = {\n\t\t\terror,\n\t\t\tstatus: error.status,\n\t\t\tstatusText: error.statusText,\n\t\t\tmessage: error.message,\n\t\t\trequest,\n\t\t};\n\t\tif (response) {\n\t\t\toptions.headers = response.headers;\n\t\t\toptions.status = options.status || response.status;\n\t\t\toptions.statusText = options.statusText || response.statusText;\n\t\t\toptions.url = response.url;\n\t\t}\n\t\treturn new HttpErrorResponse<T>(options);\n\t}\n\n}\n\nfunction optionsWithBody_<T>(options: IHttpRequestInit<T>, body: T | null): IHttpRequestInit<T> {\n\treturn Object.assign({}, options, { body });\n}\n\n/*\n\nexport class HttpClient {\n\n\tconstructor(private handler: HttpHandler) { }\n\n\trequest<R>(request: HttpRequest<any>): Observable<HttpEvent<R>>;\n\trequest(method: string, url: string, options: {\n\t\tbody?: any,\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined,\n\t\tobserve?: 'body',\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\n\t\treportProgress?: boolean, responseType: 'arraybuffer',\n\t\twithCredentials?: boolean,\n\t}): Observable<ArrayBuffer>;\n\trequest(method: string, url: string, options: {\n\t\tbody?: any,\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined,\n\t\tobserve?: 'body',\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\n\t\treportProgress?: boolean, responseType: 'blob',\n\t\twithCredentials?: boolean,\n\t}): Observable<Blob>;\n\trequest(method: string, url: string, options: {\n\t\tbody?: any,\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined,\n\t\tobserve?: 'body',\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\n\t\treportProgress?: boolean, responseType: 'text',\n\t\twithCredentials?: boolean,\n\t}): Observable<string>;\n\trequest(method: string, url: string, options: {\n\t\tbody?: any,\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined,\n\t\tparams?: HttpParams | { [param: string]: string | string[] }, observe: 'events',\n\t\treportProgress?: boolean, responseType: 'arraybuffer',\n\t\twithCredentials?: boolean,\n\t}): Observable<HttpEvent<ArrayBuffer>>;\n\trequest(method: string, url: string, options: {\n\t\tbody?: any,\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined, observe: 'events',\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\n\t\treportProgress?: boolean, responseType: 'blob',\n\t\twithCredentials?: boolean,\n\t}): Observable<HttpEvent<Blob>>;\n\trequest(method: string, url: string, options: {\n\t\tbody?: any,\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined, observe: 'events',\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\n\t\treportProgress?: boolean, responseType: 'text',\n\t\twithCredentials?: boolean,\n\t}): Observable<HttpEvent<string>>;\n\trequest(method: string, url: string, options: {\n\t\tbody?: any,\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined,\n\t\treportProgress?: boolean, observe: 'events',\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\n\t\tresponseType?: 'json',\n\t\twithCredentials?: boolean,\n\t}): Observable<HttpEvent<any>>;\n\trequest<R>(method: string, url: string, options: {\n\t\tbody?: any,\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined,\n\t\treportProgress?: boolean, observe: 'events',\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\n\t\tresponseType?: 'json',\n\t\twithCredentials?: boolean,\n\t}): Observable<HttpEvent<R>>;\n\trequest(method: string, url: string, options: {\n\t\tbody?: any,\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined, observe: 'response',\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\n\t\treportProgress?: boolean, responseType: 'arraybuffer',\n\t\twithCredentials?: boolean,\n\t}): Observable<HttpResponse<ArrayBuffer>>;\n\trequest(method: string, url: string, options: {\n\t\tbody?: any,\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined, observe: 'response',\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\n\t\treportProgress?: boolean, responseType: 'blob',\n\t\twithCredentials?: boolean,\n\t}): Observable<HttpResponse<Blob>>;\n\trequest(method: string, url: string, options: {\n\t\tbody?: any,\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined, observe: 'response',\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\n\t\treportProgress?: boolean, responseType: 'text',\n\t\twithCredentials?: boolean,\n\t}): Observable<HttpResponse<string>>;\n\trequest(method: string, url: string, options: {\n\t\tbody?: any,\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined,\n\t\treportProgress?: boolean, observe: 'response',\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\n\t\tresponseType?: 'json',\n\t\twithCredentials?: boolean,\n\t}): Observable<HttpResponse<Object>>;\n\trequest<R>(method: string, url: string, options: {\n\t\tbody?: any,\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined,\n\t\treportProgress?: boolean, observe: 'response',\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\n\t\tresponseType?: 'json',\n\t\twithCredentials?: boolean,\n\t}): Observable<HttpResponse<R>>;\n\trequest(method: string, url: string, options?: {\n\t\tbody?: any,\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined,\n\t\tobserve?: 'body',\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\n\t\tresponseType?: 'json',\n\t\treportProgress?: boolean,\n\t\twithCredentials?: boolean,\n\t}): Observable<Object>;\n\trequest<R>(method: string, url: string, options?: {\n\t\tbody?: any,\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined,\n\t\tobserve?: 'body',\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\n\t\tresponseType?: 'json',\n\t\treportProgress?: boolean,\n\t\twithCredentials?: boolean,\n\t}): Observable<R>;\n\trequest(method: string, url: string, options?: {\n\t\tbody?: any,\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined,\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\n\t\tobserve?: HttpObserve,\n\t\treportProgress?: boolean,\n\t\tresponseType?: 'arraybuffer' | 'blob' | 'json' | 'text',\n\t\twithCredentials?: boolean,\n\t}): Observable<any>;\n\trequest(first: string | HttpRequest<any>, url?: string, options: {\n\t\tbody?: any,\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined,\n\t\tobserve?: HttpObserveType,\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\n\t\treportProgress?: boolean,\n\t\tresponseType?: 'arraybuffer' | 'blob' | 'json' | 'text',\n\t\twithCredentials?: boolean,\n\t} = {}): Observable<any> {\n\t\tlet request: HttpRequest<any>;\n\t\tif (first instanceof HttpRequest) {\n\t\t\trequest = first;\n\t\t} else {\n\t\t\tlet headers: HttpHeaders | undefined = undefined;\n\t\t\tif (options.headers instanceof HttpHeaders) {\n\t\t\t\theaders = options.headers;\n\t\t\t} else {\n\t\t\t\theaders = new HttpHeaders(options.headers);\n\t\t\t}\n\t\t\tlet params: HttpParams | undefined = undefined;\n\t\t\tif (!!options.params) {\n\t\t\t\tif (options.params instanceof HttpParams) {\n\t\t\t\t\tparams = options.params;\n\t\t\t\t} else {\n\t\t\t\t\tparams = new HttpParams({ fromObject: options.params } as HttpParamsOptions);\n\t\t\t\t}\n\t\t\t}\n\t\t\trequest = new HttpRequest(first, url!, (options.body !== undefined ? options.body : null), {\n\t\t\t\theaders,\n\t\t\t\tparams,\n\t\t\t\treportProgress: options.reportProgress,\n\t\t\t\tresponseType: options.responseType || 'json',\n\t\t\t\twithCredentials: options.withCredentials,\n\t\t\t});\n\t\t}\n\t\tconst events$: Observable<HttpEvent<any>> = of(request).pipe(concatMap((request: HttpRequest<any>) => this.handler.handle(request)));\n\t\tif (first instanceof HttpRequest || options.observe === 'events') {\n\t\t\treturn events$;\n\t\t}\n\t\tconst response$: Observable<HttpResponse<any>> = <Observable<HttpResponse<any>>>events$.pipe(\n\t\t\tfilter((event: HttpEvent<any>) => event instanceof HttpResponse),\n\t\t);\n\t\tswitch (options.observe || 'body') {\n\t\t\tcase 'body':\n\t\t\t\tswitch (request.responseType) {\n\t\t\t\t\tcase 'arraybuffer':\n\t\t\t\t\t\treturn response$.pipe(map((res: HttpResponse<any>) => {\n\t\t\t\t\t\t\tif (res.body !== null && !(res.body instanceof ArrayBuffer)) {\n\t\t\t\t\t\t\t\tthrow new Error('Response is not an ArrayBuffer.');\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn res.body;\n\t\t\t\t\t\t}));\n\t\t\t\t\tcase 'blob':\n\t\t\t\t\t\treturn response$.pipe(map((res: HttpResponse<any>) => {\n\t\t\t\t\t\t\tif (res.body !== null && !(res.body instanceof Blob)) {\n\t\t\t\t\t\t\t\tthrow new Error('Response is not a Blob.');\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn res.body;\n\t\t\t\t\t\t}));\n\t\t\t\t\tcase 'text':\n\t\t\t\t\t\treturn response$.pipe(map((res: HttpResponse<any>) => {\n\t\t\t\t\t\t\tif (res.body !== null && typeof res.body !== 'string') {\n\t\t\t\t\t\t\t\tthrow new Error('Response is not a string.');\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn res.body;\n\t\t\t\t\t\t}));\n\t\t\t\t\tcase 'json':\n\t\t\t\t\tdefault:\n\t\t\t\t\t\treturn response$.pipe(map((res: HttpResponse<any>) => res.body));\n\t\t\t\t}\n\t\t\tcase 'response':\n\t\t\t\treturn response$;\n\t\t\tdefault:\n\t\t\t\tthrow new Error(`Unreachable: unhandled observe type ${options.observe}}`);\n\t\t}\n\t}\n\n\tdelete(url: string, options: {\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined,\n\t\tobserve?: 'body',\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\n\t\treportProgress?: boolean, responseType: 'arraybuffer',\n\t\twithCredentials?: boolean,\n\t}): Observable<ArrayBuffer>;\n\tdelete(url: string, options: {\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined,\n\t\tobserve?: 'body',\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\n\t\treportProgress?: boolean, responseType: 'blob',\n\t\twithCredentials?: boolean,\n\t}): Observable<Blob>;\n\tdelete(url: string, options: {\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined,\n\t\tobserve?: 'body',\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\n\t\treportProgress?: boolean, responseType: 'text',\n\t\twithCredentials?: boolean,\n\t}): Observable<string>;\n\n\n\tdelete(url: string, options: {\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined, observe: 'events',\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\n\t\treportProgress?: boolean, responseType: 'arraybuffer',\n\t\twithCredentials?: boolean,\n\t}): Observable<HttpEvent<ArrayBuffer>>;\n\n\n\tdelete(url: string, options: {\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined, observe: 'events',\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\n\t\treportProgress?: boolean, responseType: 'blob',\n\t\twithCredentials?: boolean,\n\t}): Observable<HttpEvent<Blob>>;\n\n\tdelete(url: string, options: {\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined, observe: 'events',\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\n\t\treportProgress?: boolean, responseType: 'text',\n\t\twithCredentials?: boolean,\n\t}): Observable<HttpEvent<string>>;\n\n\tdelete(url: string, options: {\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined, observe: 'events',\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\n\t\treportProgress?: boolean,\n\t\tresponseType?: 'json',\n\t\twithCredentials?: boolean,\n\t}): Observable<HttpEvent<Object>>;\n\n\n\tdelete<T>(url: string, options: {\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined, observe: 'events',\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\n\t\treportProgress?: boolean,\n\t\tresponseType?: 'json',\n\t\twithCredentials?: boolean,\n\t}): Observable<HttpEvent<T>>;\n\n\n\tdelete(url: string, options: {\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined, observe: 'response',\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\n\t\treportProgress?: boolean, responseType: 'arraybuffer',\n\t\twithCredentials?: boolean,\n\t}): Observable<HttpResponse<ArrayBuffer>>;\n\n\n\tdelete(url: string, options: {\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined, observe: 'response',\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\n\t\treportProgress?: boolean, responseType: 'blob',\n\t\twithCredentials?: boolean,\n\t}): Observable<HttpResponse<Blob>>;\n\n\n\tdelete(url: string, options: {\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined, observe: 'response',\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\n\t\treportProgress?: boolean, responseType: 'text',\n\t\twithCredentials?: boolean,\n\t}): Observable<HttpResponse<string>>;\n\n\n\tdelete(url: string, options: {\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined, observe: 'response',\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\n\t\treportProgress?: boolean,\n\t\tresponseType?: 'json',\n\t\twithCredentials?: boolean,\n\t}): Observable<HttpResponse<Object>>;\n\n\n\tdelete<T>(url: string, options: {\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined, observe: 'response',\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\n\t\treportProgress?: boolean,\n\t\tresponseType?: 'json',\n\t\twithCredentials?: boolean,\n\t}): Observable<HttpResponse<T>>;\n\n\n\tdelete(url: string, options?: {\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined,\n\t\tobserve?: 'body',\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\n\t\treportProgress?: boolean,\n\t\tresponseType?: 'json',\n\t\twithCredentials?: boolean,\n\t}): Observable<Object>;\n\n\n\tdelete<T>(url: string, options?: {\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined,\n\t\tobserve?: 'body',\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\n\t\treportProgress?: boolean,\n\t\tresponseType?: 'json',\n\t\twithCredentials?: boolean,\n\t}): Observable<T>;\n\n\n\tdelete(url: string, options: {\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined,\n\t\tobserve?: HttpObserveType,\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\n\t\treportProgress?: boolean,\n\t\tresponseType?: 'arraybuffer' | 'blob' | 'json' | 'text',\n\t\twithCredentials?: boolean,\n\t} = {}): Observable<any> {\n\t\treturn this.request<any>('DELETE', url, options as any);\n\t}\n\n\n\n\tget(url: string, options: {\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined,\n\t\tobserve?: 'body',\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\n\t\treportProgress?: boolean, responseType: 'arraybuffer',\n\t\twithCredentials?: boolean,\n\t}): Observable<ArrayBuffer>;\n\n\n\tget(url: string, options: {\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined,\n\t\tobserve?: 'body',\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\n\t\treportProgress?: boolean, responseType: 'blob',\n\t\twithCredentials?: boolean,\n\t}): Observable<Blob>;\n\n\n\tget(url: string, options: {\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined,\n\t\tobserve?: 'body',\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\n\t\treportProgress?: boolean, responseType: 'text',\n\t\twithCredentials?: boolean,\n\t}): Observable<string>;\n\n\n\tget(url: string, options: {\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined, observe: 'events',\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\n\t\treportProgress?: boolean, responseType: 'arraybuffer',\n\t\twithCredentials?: boolean,\n\t}): Observable<HttpEvent<ArrayBuffer>>;\n\n\n\tget(url: string, options: {\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined, observe: 'events',\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\n\t\treportProgress?: boolean, responseType: 'blob',\n\t\twithCredentials?: boolean,\n\t}): Observable<HttpEvent<Blob>>;\n\n\n\tget(url: string, options: {\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined, observe: 'events',\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\n\t\treportProgress?: boolean, responseType: 'text',\n\t\twithCredentials?: boolean,\n\t}): Observable<HttpEvent<string>>;\n\n\n\tget(url: string, options: {\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined, observe: 'events',\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\n\t\treportProgress?: boolean,\n\t\tresponseType?: 'json',\n\t\twithCredentials?: boolean,\n\t}): Observable<HttpEvent<Object>>;\n\n\n\tget<T>(url: string, options: {\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined, observe: 'events',\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\n\t\treportProgress?: boolean,\n\t\tresponseType?: 'json',\n\t\twithCredentials?: boolean,\n\t}): Observable<HttpEvent<T>>;\n\n\n\tget(url: string, options: {\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined, observe: 'response',\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\n\t\treportProgress?: boolean, responseType: 'arraybuffer',\n\t\twithCredentials?: boolean,\n\t}): Observable<HttpResponse<ArrayBuffer>>;\n\n\n\tget(url: string, options: {\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined, observe: 'response',\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\n\t\treportProgress?: boolean, responseType: 'blob',\n\t\twithCredentials?: boolean,\n\t}): Observable<HttpResponse<Blob>>;\n\n\n\tget(url: string, options: {\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined, observe: 'response',\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\n\t\treportProgress?: boolean, responseType: 'text',\n\t\twithCredentials?: boolean,\n\t}): Observable<HttpResponse<string>>;\n\n\n\tget(url: string, options: {\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined, observe: 'response',\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\n\t\treportProgress?: boolean,\n\t\tresponseType?: 'json',\n\t\twithCredentials?: boolean,\n\t}): Observable<HttpResponse<Object>>;\n\n\n\tget<T>(url: string, options: {\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined, observe: 'response',\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\n\t\treportProgress?: boolean,\n\t\tresponseType?: 'json',\n\t\twithCredentials?: boolean,\n\t}): Observable<HttpResponse<T>>;\n\n\n\tget(url: string, options?: {\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined,\n\t\tobserve?: 'body',\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\n\t\treportProgress?: boolean,\n\t\tresponseType?: 'json',\n\t\twithCredentials?: boolean,\n\t}): Observable<Object>;\n\n\n\tget<T>(url: string, options?: {\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined,\n\t\tobserve?: 'body',\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\n\t\treportProgress?: boolean,\n\t\tresponseType?: 'json',\n\t\twithCredentials?: boolean,\n\t}): Observable<T>;\n\n\n\tget(url: string, options: {\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined,\n\t\tobserve?: HttpObserveType,\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\n\t\treportProgress?: boolean,\n\t\tresponseType?: 'arraybuffer' | 'blob' | 'json' | 'text',\n\t\twithCredentials?: boolean,\n\t} = {}): Observable<any> {\n\t\treturn this.request<any>('GET', url, options as any);\n\t}\n\n\n\n\thead(url: string, options: {\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined,\n\t\tobserve?: 'body',\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\n\t\treportProgress?: boolean, responseType: 'arraybuffer',\n\t\twithCredentials?: boolean,\n\t}): Observable<ArrayBuffer>;\n\n\n\n\thead(url: string, options: {\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined,\n\t\tobserve?: 'body',\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\n\t\treportProgress?: boolean, responseType: 'blob',\n\t\twithCredentials?: boolean,\n\t}): Observable<Blob>;\n\n\n\thead(url: string, options: {\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined,\n\t\tobserve?: 'body',\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\n\t\treportProgress?: boolean, responseType: 'text',\n\t\twithCredentials?: boolean,\n\t}): Observable<string>;\n\n\n\thead(url: string, options: {\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined, observe: 'events',\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\n\t\treportProgress?: boolean, responseType: 'arraybuffer',\n\t\twithCredentials?: boolean,\n\t}): Observable<HttpEvent<ArrayBuffer>>;\n\n\n\thead(url: string, options: {\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined, observe: 'events',\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\n\t\treportProgress?: boolean, responseType: 'blob',\n\t\twithCredentials?: boolean,\n\t}): Observable<HttpEvent<Blob>>;\n\n\n\thead(url: string, options: {\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined, observe: 'events',\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\n\t\treportProgress?: boolean, responseType: 'text',\n\t\twithCredentials?: boolean,\n\t}): Observable<HttpEvent<string>>;\n\n\n\thead(url: string, options: {\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined, observe: 'events',\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\n\t\treportProgress?: boolean,\n\t\tresponseType?: 'json',\n\t\twithCredentials?: boolean,\n\t}): Observable<HttpEvent<Object>>;\n\n\n\thead<T>(url: string, options: {\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined, observe: 'events',\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\n\t\treportProgress?: boolean,\n\t\tresponseType?: 'json',\n\t\twithCredentials?: boolean,\n\t}): Observable<HttpEvent<T>>;\n\n\n\thead(url: string, options: {\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined, observe: 'response',\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\n\t\treportProgress?: boolean, responseType: 'arraybuffer',\n\t\twithCredentials?: boolean,\n\t}): Observable<HttpResponse<ArrayBuffer>>;\n\n\n\thead(url: string, options: {\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined, observe: 'response',\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\n\t\treportProgress?: boolean, responseType: 'blob',\n\t\twithCredentials?: boolean,\n\t}): Observable<HttpResponse<Blob>>;\n\n\n\thead(url: string, options: {\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined, observe: 'response',\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\n\t\treportProgress?: boolean, responseType: 'text',\n\t\twithCredentials?: boolean,\n\t}): Observable<HttpResponse<string>>;\n\n\n\thead(url: string, options: {\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined, observe: 'response',\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\n\t\treportProgress?: boolean,\n\t\tresponseType?: 'json',\n\t\twithCredentials?: boolean,\n\t}): Observable<HttpResponse<Object>>;\n\n\n\thead<T>(url: string, options: {\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined, observe: 'response',\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\n\t\treportProgress?: boolean,\n\t\tresponseType?: 'json',\n\t\twithCredentials?: boolean,\n\t}): Observable<HttpResponse<T>>;\n\n\n\thead(url: string, options?: {\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined,\n\t\tobserve?: 'body',\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\n\t\treportProgress?: boolean,\n\t\tresponseType?: 'json',\n\t\twithCredentials?: boolean,\n\t}): Observable<Object>;\n\n\n\thead<T>(url: string, options?: {\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined,\n\t\tobserve?: 'body',\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\n\t\treportProgress?: boolean,\n\t\tresponseType?: 'json',\n\t\twithCredentials?: boolean,\n\t}): Observable<T>;\n\n\n\thead(url: string, options: {\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined,\n\t\tobserve?: HttpObserveType,\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\n\t\treportProgress?: boolean,\n\t\tresponseType?: 'arraybuffer' | 'blob' | 'json' | 'text',\n\t\twithCredentials?: boolean,\n\t} = {}): Observable<any> {\n\t\treturn this.request<any>('HEAD', url, options as any);\n\t}\n\n\n\tjsonp(url: string, callbackParam: string): Observable<Object>;\n\n\n\tjsonp<T>(url: string, callbackParam: string): Observable<T>;\n\n\n\tjsonp<T>(url: string, callbackParam: string): Observable<T> {\n\t\treturn this.request<any>('JSONP', url, {\n\t\t\tparams: new HttpParams().append(callbackParam, 'JSONP_CALLBACK'),\n\t\t\tobserve: 'body',\n\t\t\tresponseType: 'json',\n\t\t});\n\t}\n\n\n\toptions(url: string, options: {\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined,\n\t\tobserve?: 'body',\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\n\t\treportProgress?: boolean, responseType: 'arraybuffer',\n\t\twithCredentials?: boolean,\n\t}): Observable<ArrayBuffer>;\n\n\n\toptions(url: string, options: {\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined,\n\t\tobserve?: 'body',\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\n\t\treportProgress?: boolean, responseType: 'blob',\n\t\twithCredentials?: boolean,\n\t}): Observable<Blob>;\n\n\n\toptions(url: string, options: {\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined,\n\t\tobserve?: 'body',\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\n\t\treportProgress?: boolean, responseType: 'text',\n\t\twithCredentials?: boolean,\n\t}): Observable<string>;\n\n\n\toptions(url: string, options: {\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined, observe: 'events',\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\n\t\treportProgress?: boolean, responseType: 'arraybuffer',\n\t\twithCredentials?: boolean,\n\t}): Observable<HttpEvent<ArrayBuffer>>;\n\n\n\toptions(url: string, options: {\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined, observe: 'events',\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\n\t\treportProgress?: boolean, responseType: 'blob',\n\t\twithCredentials?: boolean,\n\t}): Observable<HttpEvent<Blob>>;\n\n\n\toptions(url: string, options: {\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined, observe: 'events',\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\n\t\treportProgress?: boolean, responseType: 'text',\n\t\twithCredentials?: boolean,\n\t}): Observable<HttpEvent<string>>;\n\n\n\toptions(url: string, options: {\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined, observe: 'events',\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\n\t\treportProgress?: boolean,\n\t\tresponseType?: 'json',\n\t\twithCredentials?: boolean,\n\t}): Observable<HttpEvent<Object>>;\n\n\n\toptions<T>(url: string, options: {\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined, observe: 'events',\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\n\t\treportProgress?: boolean,\n\t\tresponseType?: 'json',\n\t\twithCredentials?: boolean,\n\t}): Observable<HttpEvent<T>>;\n\n\n\toptions(url: string, options: {\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined, observe: 'response',\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\n\t\treportProgress?: boolean, responseType: 'arraybuffer',\n\t\twithCredentials?: boolean,\n\t}): Observable<HttpResponse<ArrayBuffer>>;\n\n\n\toptions(url: string, options: {\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined, observe: 'response',\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\n\t\treportProgress?: boolean, responseType: 'blob',\n\t\twithCredentials?: boolean,\n\t}): Observable<HttpResponse<Blob>>;\n\n\n\toptions(url: string, options: {\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined, observe: 'response',\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\n\t\treportProgress?: boolean, responseType: 'text',\n\t\twithCredentials?: boolean,\n\t}): Observable<HttpResponse<string>>;\n\n\n\toptions(url: string, options: {\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined, observe: 'response',\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\n\t\treportProgress?: boolean,\n\t\tresponseType?: 'json',\n\t\twithCredentials?: boolean,\n\t}): Observable<HttpResponse<Object>>;\n\n\n\toptions<T>(url: string, options: {\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined, observe: 'response',\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\n\t\treportProgress?: boolean,\n\t\tresponseType?: 'json',\n\t\twithCredentials?: boolean,\n\t}): Observable<HttpResponse<T>>;\n\n\n\toptions(url: string, options?: {\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined,\n\t\tobserve?: 'body',\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\n\t\treportProgress?: boolean,\n\t\tresponseType?: 'json',\n\t\twithCredentials?: boolean,\n\t}): Observable<Object>;\n\n\n\toptions<T>(url: string, options?: {\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined,\n\t\tobserve?: 'body',\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\n\t\treportProgress?: boolean,\n\t\tresponseType?: 'json',\n\t\twithCredentials?: boolean,\n\t}): Observable<T>;\n\n\n\toptions(url: string, options: {\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined,\n\t\tobserve?: HttpObserveType,\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\n\t\treportProgress?: boolean,\n\t\tresponseType?: 'arraybuffer' | 'blob' | 'json' | 'text',\n\t\twithCredentials?: boolean,\n\t} = {}): Observable<any> {\n\t\treturn this.request<any>('OPTIONS', url, options as any);\n\t}\n\n\n\tpatch$(url: string, body: any | null, options: {\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined,\n\t\tobserve?: 'body',\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\n\t\treportProgress?: boolean, responseType: 'arraybuffer',\n\t\twithCredentials?: boolean,\n\t}): Observable<ArrayBuffer>;\n\n\n\tpatch$(url: string, body: any | null, options: {\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined,\n\t\tobserve?: 'body',\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\n\t\treportProgress?: boolean, responseType: 'blob',\n\t\twithCredentials?: boolean,\n\t}): Observable<Blob>;\n\n\n\tpatch$(url: string, body: any | null, options: {\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined,\n\t\tobserve?: 'body',\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\n\t\treportProgress?: boolean, responseType: 'text',\n\t\twithCredentials?: boolean,\n\t}): Observable<string>;\n\n\n\n\tpatch$(url: string, body: any | null, options: {\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined, observe: 'events',\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\n\t\treportProgress?: boolean, responseType: 'arraybuffer',\n\t\twithCredentials?: boolean,\n\t}): Observable<HttpEvent<ArrayBuffer>>;\n\n\n\tpatch$(url: string, body: any | null, options: {\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined, observe: 'events',\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\n\t\treportProgress?: boolean, responseType: 'blob',\n\t\twithCredentials?: boolean,\n\t}): Observable<HttpEvent<Blob>>;\n\n\n\tpatch$(url: string, body: any | null, options: {\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined, observe: 'events',\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\n\t\treportProgress?: boolean, responseType: 'text',\n\t\twithCredentials?: boolean,\n\t}): Observable<HttpEvent<string>>;\n\n\n\tpatch$(url: string, body: any | null, options: {\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined, observe: 'events',\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\n\t\treportProgress?: boolean,\n\t\tresponseType?: 'json',\n\t\twithCredentials?: boolean,\n\t}): Observable<HttpEvent<Object>>;\n\n\n\tpatch<T>(url: string, body: any | null, options: {\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined, observe: 'events',\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\n\t\treportProgress?: boolean,\n\t\tresponseType?: 'json',\n\t\twithCredentials?: boolean,\n\t}): Observable<HttpEvent<T>>;\n\n\n\tpatch$(url: string, body: any | null, options: {\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined, observe: 'response',\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\n\t\treportProgress?: boolean, responseType: 'arraybuffer',\n\t\twithCredentials?: boolean,\n\t}): Observable<HttpResponse<ArrayBuffer>>;\n\n\n\tpatch$(url: string, body: any | null, options: {\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined, observe: 'response',\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\n\t\treportProgress?: boolean, responseType: 'blob',\n\t\twithCredentials?: boolean,\n\t}): Observable<HttpResponse<Blob>>;\n\n\n\tpatch$(url: string, body: any | null, options: {\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined, observe: 'response',\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\n\t\treportProgress?: boolean, responseType: 'text',\n\t\twithCredentials?: boolean,\n\t}): Observable<HttpResponse<string>>;\n\n\n\tpatch$(url: string, body: any | null, options: {\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined, observe: 'response',\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\n\t\treportProgress?: boolean,\n\t\tresponseType?: 'json',\n\t\twithCredentials?: boolean,\n\t}): Observable<HttpResponse<Object>>;\n\n\n\tpatch<T>(url: string, body: any | null, options: {\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined, observe: 'response',\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\n\t\treportProgress?: boolean,\n\t\tresponseType?: 'json',\n\t\twithCredentials?: boolean,\n\t}): Observable<HttpResponse<T>>;\n\n\n\tpatch$(url: string, body: any | null, options?: {\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined,\n\t\tobserve?: 'body',\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\n\t\treportProgress?: boolean,\n\t\tresponseType?: 'json',\n\t\twithCredentials?: boolean,\n\t}): Observable<Object>;\n\n\n\tpatch<T>(url: string, body: any | null, options?: {\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined,\n\t\tobserve?: 'body',\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\n\t\treportProgress?: boolean,\n\t\tresponseType?: 'json',\n\t\twithCredentials?: boolean,\n\t}): Observable<T>;\n\n\n\tpatch$(url: string, body: any | null, options: {\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined,\n\t\tobserve?: HttpObserveType,\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\n\t\treportProgress?: boolean,\n\t\tresponseType?: 'arraybuffer' | 'blob' | 'json' | 'text',\n\t\twithCredentials?: boolean,\n\t} = {}): Observable<any> {\n\t\treturn this.request<any>('PATCH', url, optionsWithBody_<T>(options, body));\n\t}\n\n\n\tpost$(url: string, body: any | null, options: {\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined,\n\t\tobserve?: 'body',\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\n\t\treportProgress?: boolean, responseType: 'arraybuffer',\n\t\twithCredentials?: boolean,\n\t}): Observable<ArrayBuffer>;\n\n\n\tpost$(url: string, body: any | null, options: {\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined,\n\t\tobserve?: 'body',\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\n\t\treportProgress?: boolean, responseType: 'blob',\n\t\twithCredentials?: boolean,\n\t}): Observable<Blob>;\n\n\n\tpost$(url: string, body: any | null, options: {\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined,\n\t\tobserve?: 'body',\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\n\t\treportProgress?: boolean, responseType: 'text',\n\t\twithCredentials?: boolean,\n\t}): Observable<string>;\n\n\n\tpost$(url: string, body: any | null, options: {\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined, observe: 'events',\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\n\t\treportProgress?: boolean, responseType: 'arraybuffer',\n\t\twithCredentials?: boolean,\n\t}): Observable<HttpEvent<ArrayBuffer>>;\n\n\n\tpost$(url: string, body: any | null, options: {\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined, observe: 'events',\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\n\t\treportProgress?: boolean, responseType: 'blob',\n\t\twithCredentials?: boolean,\n\t}): Observable<HttpEvent<Blob>>;\n\n\n\tpost$(url: string, body: any | null, options: {\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined, observe: 'events',\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\n\t\treportProgress?: boolean, responseType: 'text',\n\t\twithCredentials?: boolean,\n\t}): Observable<HttpEvent<string>>;\n\n\n\tpost$(url: string, body: any | null, options: {\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined, observe: 'events',\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\n\t\treportProgress?: boolean,\n\t\tresponseType?: 'json',\n\t\twithCredentials?: boolean,\n\t}): Observable<HttpEvent<Object>>;\n\n\n\tpost<T>(url: string, body: any | null, options: {\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined, observe: 'events',\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\n\t\treportProgress?: boolean,\n\t\tresponseType?: 'json',\n\t\twithCredentials?: boolean,\n\t}): Observable<HttpEvent<T>>;\n\n\n\tpost$(url: string, body: any | null, options: {\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined, observe: 'response',\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\n\t\treportProgress?: boolean, responseType: 'arraybuffer',\n\t\twithCredentials?: boolean,\n\t}): Observable<HttpResponse<ArrayBuffer>>;\n\n\n\tpost$(url: string, body: any | null, options: {\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined, observe: 'response',\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\n\t\treportProgress?: boolean, responseType: 'blob',\n\t\twithCredentials?: boolean,\n\t}): Observable<HttpResponse<Blob>>;\n\n\n\tpost$(url: string, body: any | null, options: {\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined, observe: 'response',\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\n\t\treportProgress?: boolean, responseType: 'text',\n\t\twithCredentials?: boolean,\n\t}): Observable<HttpResponse<string>>;\n\n\n\tpost$(url: string, body: any | null, options: {\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined, observe: 'response',\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\n\t\treportProgress?: boolean,\n\t\tresponseType?: 'json',\n\t\twithCredentials?: boolean,\n\t}): Observable<HttpResponse<Object>>;\n\n\n\tpost<T>(url: string, body: any | null, options: {\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined, observe: 'response',\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\n\t\treportProgress?: boolean,\n\t\tresponseType?: 'json',\n\t\twithCredentials?: boolean,\n\t}): Observable<HttpResponse<T>>;\n\n\n\tpost$(url: string, body: any | null, options?: {\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined,\n\t\tobserve?: 'body',\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\n\t\treportProgress?: boolean,\n\t\tresponseType?: 'json',\n\t\twithCredentials?: boolean,\n\t}): Observable<Object>;\n\n\n\tpost<T>(url: string, body: any | null, options?: {\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined,\n\t\tobserve?: 'body',\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\n\t\treportProgress?: boolean,\n\t\tresponseType?: 'json',\n\t\twithCredentials?: boolean,\n\t}): Observable<T>;\n\n\n\tpost$(url: string, body: any | null, options: {\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined,\n\t\tobserve?: HttpObserveType,\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\n\t\treportProgress?: boolean,\n\t\tresponseType?: 'arraybuffer' | 'blob' | 'json' | 'text',\n\t\twithCredentials?: boolean,\n\t} = {}): Observable<any> {\n\t\treturn this.request<any>('POST', url, optionsWithBody_<T>(options, body));\n\t}\n\n\n\tput(url: string, body: any | null, options: {\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined,\n\t\tobserve?: 'body',\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\n\t\treportProgress?: boolean, responseType: 'arraybuffer',\n\t\twithCredentials?: boolean,\n\t}): Observable<ArrayBuffer>;\n\n\n\tput(url: string, body: any | null, options: {\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined,\n\t\tobserve?: 'body',\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\n\t\treportProgress?: boolean, responseType: 'blob',\n\t\twithCredentials?: boolean,\n\t}): Observable<Blob>;\n\n\n\tput(url: string, body: any | null, options: {\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined,\n\t\tobserve?: 'body',\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\n\t\treportProgress?: boolean, responseType: 'text',\n\t\twithCredentials?: boolean,\n\t}): Observable<string>;\n\n\n\tput(url: string, body: any | null, options: {\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined, observe: 'events',\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\n\t\treportProgress?: boolean, responseType: 'arraybuffer',\n\t\twithCredentials?: boolean,\n\t}): Observable<HttpEvent<ArrayBuffer>>;\n\n\n\tput(url: string, body: any | null, options: {\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined, observe: 'events',\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\n\t\treportProgress?: boolean, responseType: 'blob',\n\t\twithCredentials?: boolean,\n\t}): Observable<HttpEvent<Blob>>;\n\n\n\tput(url: string, body: any | null, options: {\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined, observe: 'events',\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\n\t\treportProgress?: boolean, responseType: 'text',\n\t\twithCredentials?: boolean,\n\t}): Observable<HttpEvent<string>>;\n\n\n\tput(url: string, body: any | null, options: {\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined, observe: 'events',\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\n\t\treportProgress?: boolean,\n\t\tresponseType?: 'json',\n\t\twithCredentials?: boolean,\n\t}): Observable<HttpEvent<Object>>;\n\n\n\tput<T>(url: string, body: any | null, options: {\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined, observe: 'events',\n\t\tresponseType?: 'json',\n\t\twithCredentials?: boolean,\n\t}): Observable<HttpEvent<T>>;\n\n\n\tput(url: string, body: any | null, options: {\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined, observe: 'response',\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\n\t\treportProgress?: boolean, responseType: 'arraybuffer',\n\t\twithCredentials?: boolean,\n\t}): Observable<HttpResponse<ArrayBuffer>>;\n\n\n\tput(url: string, body: any | null, options: {\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined, observe: 'response',\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\n\t\treportProgress?: boolean, responseType: 'blob',\n\t\twithCredentials?: boolean,\n\t}): Observable<HttpResponse<Blob>>;\n\n\n\tput(url: string, body: any | null, options: {\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined, observe: 'response',\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\n\t\treportProgress?: boolean, responseType: 'text',\n\t\twithCredentials?: boolean,\n\t}): Observable<HttpResponse<string>>;\n\n\n\tput(url: string, body: any | null, options: {\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined, observe: 'response',\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\n\t\treportProgress?: boolean,\n\t\tresponseType?: 'json',\n\t\twithCredentials?: boolean,\n\t}): Observable<HttpResponse<Object>>;\n\n\n\tput<T>(url: string, body: any | null, options: {\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined, observe: 'response',\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\n\t\treportProgress?: boolean,\n\t\tresponseType?: 'json',\n\t\twithCredentials?: boolean,\n\t}): Observable<HttpResponse<T>>;\n\n\n\tput(url: string, body: any | null, options?: {\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined,\n\t\tobserve?: 'body',\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\n\t\treportProgress?: boolean,\n\t\tresponseType?: 'json',\n\t\twithCredentials?: boolean,\n\t}): Observable<Object>;\n\n\n\tput<T>(url: string, body: any | null, options?: {\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined,\n\t\tobserve?: 'body',\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\n\t\treportProgress?: boolean,\n\t\tresponseType?: 'json',\n\t\twithCredentials?: boolean,\n\t}): Observable<T>;\n\n\n\tput(url: string, body: any | null, options: {\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined,\n\t\tobserve?: HttpObserveType,\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\n\t\treportProgress?: boolean,\n\t\tresponseType?: 'arraybuffer' | 'blob' | 'json' | 'text',\n\t\twithCredentials?: boolean,\n\t} = {}): Observable<any> {\n\t\treturn this.request<any>('PUT', url, optionsWithBody_<T>(options, body));\n\t}\n}\n\n*/\n","import { Component, errors$, IFactoryMeta } from 'rxcomp';\nimport { EMPTY, Observable } from 'rxjs';\nimport { first, takeUntil, tap } from 'rxjs/operators';\nimport HttpClient from './http/http-client';\nimport { HttpHandler } from './http/http-handler';\nimport { HttpInterceptor, HttpInterceptors } from './http/http-interceptor';\nimport { HttpRequest } from './http/http-request';\nimport { HttpEvent, HttpResponse } from './http/http-response';\nimport { Vars } from './vars';\n\nconst cancelRequest: boolean = false;\n\nexport class CustomInterceptor implements HttpInterceptor {\n\tintercept(request: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {\n\t\tif (cancelRequest) {\n\t\t\treturn EMPTY;\n\t\t}\n\t\tconst clonedRequest = request.clone({\n\t\t\turl: request.url,\n\t\t});\n\t\t// console.log('CustomInterceptor.clonedRequest', clonedRequest);\n\t\treturn next.handle(clonedRequest);\n\t\treturn next.handle(request).pipe(\n\t\t\ttap(event => {\n\t\t\t\tif (event instanceof HttpResponse) {\n\t\t\t\t\tconsole.log('CustomInterceptor.status', event.status);\n\t\t\t\t\tconsole.log('CustomInterceptor.filter', request.params.get('filter'));\n\t\t\t\t}\n\t\t\t})\n\t\t);\n\t}\n}\n\nconst interceptor = new CustomInterceptor();\nHttpInterceptors.push(interceptor);\n\ninterface ITodoItem {\n\tid: number;\n\ttitle: string;\n\tcompleted: boolean;\n}\n\ninterface IGetTodos {\n\tgetTodos: ITodoItem[]\n}\n\ninterface IResponseData {\n\tdata: IGetTodos;\n}\n\nexport default class AppComponent extends Component {\n\titems: ITodoItem[] = [];\n\terror: any = null;\n\n\tonInit() {\n\t\t// console.log('AppComponent.onInit', this);\n\t\t/*\n\t\tconst payload = { query: `{ hello }` };\n\t\t*/\n\t\t/*\n\t\tconst payload = { query: `{ roll(dices: ${3}, sides: ${6}) }` };\n\t\t*/\n\t\t/*\n\t\tconst payload = {\n\t\t\tquery: `query ($dices: Int!, $sides: Int) {\n\t\t\troll(dices: $dices, sides: $sides)\n\t\t}`, variables: { dices: 3, sides: 6 }\n\t\t};\n\t\t*/\n\t\tconst payload = { query: `{ getTodos { id, title, completed } }` };\n\t\t/*\n\t\tHttpClient.post$<IResponseData>(`${Vars.host}${Vars.api}`, payload, {\n\t\t\tparams: { query: `{ getTodos { id, title, completed } }` },\n\t\t\treportProgress: true\n\t\t}).pipe(\n\t\t*/\n\n\t\tHttpClient.post$<IResponseData>(`${Vars.host}${Vars.api}`, payload).pipe(\n\t\t\tfirst(),\n\t\t).subscribe((response: IResponseData) => {\n\t\t\tthis.items = response.data.getTodos;\n\t\t\tthis.pushChanges();\n\t\t\t// console.log('AppComponent.getTodos', this.items);\n\t\t}, error => console.log);\n\n\t\t// HttpService.get$(`https://jsonplaceholder.typicode.com/users/1/todos`).pipe(\n\n\t\t/*\n\t\tHttpService.get$(`${Vars.host}/data/todos.json`).pipe(\n\t\t\tfirst(),\n\t\t).subscribe(response => {\n\t\t\t// console.log('AppComponent.items', response);\n\t\t\tthis.items = response.data;\n\t\t\tthis.pushChanges();\n\t\t});\n\t\t*/\n\n\t\terrors$.pipe(\n\t\t\ttakeUntil(this.unsubscribe$),\n\t\t).subscribe(error => {\n\t\t\tthis.error = error;\n\t\t\tthis.pushChanges();\n\t\t});\n\n\t}\n\n\tonClick(item: { title: string, completed: boolean }) {\n\t\titem.completed = !item.completed;\n\t\tthis.pushChanges();\n\t}\n\n\tstatic meta: IFactoryMeta = {\n\t\tselector: '[app-component]',\n\t};\n\n}\n","import { CoreModule, IModuleMeta, Module } from 'rxcomp';\nimport AppComponent from './app.component';\n\nexport default class AppModule extends Module {\n\n\tstatic meta: IModuleMeta = {\n\t\timports: [\n\t\t\tCoreModule,\n\t\t],\n\t\tdeclarations: [\n\t\t],\n\t\tbootstrap: AppComponent,\n\t};\n\n}\n","// import fetch from 'cross-fetch';\nimport 'cross-fetch/polyfill';\nimport { from, Observable } from 'rxjs';\nimport { filter, first, map, switchMap } from 'rxjs/operators';\nimport { IServerRequest, Server, ServerResponse } from '../../src/rxcomp-server';\nimport AppModule from './app.module';\nimport HttpClient from './http/http-client';\nimport { Vars } from './vars';\n\nexport function renderRequest$(request?: IServerRequest): Observable<ServerResponse> {\n\treturn Server.bootstrap$(AppModule, request).pipe(\n\t\tswitchMap((response: ServerResponse) => {\n\t\t\treturn HttpClient.pendingRequests$.pipe(\n\t\t\t\tfilter(count => count === 0),\n\t\t\t\tmap(() => {\n\t\t\t\t\tresponse.body = response.serialize();\n\t\t\t\t\treturn response;\n\t\t\t\t}),\n\t\t\t\tfirst(),\n\t\t\t);\n\t\t}),\n\t);\n\t/*\n\treturn from(new Promise((resolve, reject) => {\n\t\tif (!request?.template) {\n\t\t\treturn reject(new Error('ServerError: template not found!'));\n\t\t}\n\t\ttry {\n\t\t\tconst module = Server.bootstrap(AppModule, html);\n\t\t\tresolve(module);\n\t\t} catch (error) {\n\t\t\treject(error);\n\t\t}\n\t})).pipe(\n\t\tswitchMap(() => HttpClient.pendingRequests$),\n\t\tfilter(x => x === 0),\n\t\tmap(() => Server.serialize()),\n\t\tfirst(),\n\t);\n\t*/\n\t/*\n\tconst module = Server.bootstrap(AppModule, html);\n\tconsole.log(module);\n\t// return of(Server.serialize());\n\treturn HttpClient.pendingRequests$.pipe(\n\t\tfilter(x => x === 0),\n\t\tmap(x => Server.serialize()),\n\t\tfirst(),\n\t);\n\t*/\n}\n\n// !!! remove html only request;\nexport function renderServer(html: string, request?: IServerRequest): Observable<string> {\n\tif (request && request.host) {\n\t\tVars.host = request.host;\n\t}\n\treturn from(new Promise((resolve, reject) => {\n\t\tif (!request?.template) {\n\t\t\treturn reject(new Error('ServerError: template not found!'));\n\t\t}\n\t\ttry {\n\t\t\tconst module = Server.bootstrap(AppModule, html);\n\t\t\tresolve(module);\n\t\t} catch (error) {\n\t\t\treject(error);\n\t\t}\n\t})).pipe(\n\t\tswitchMap(() => HttpClient.pendingRequests$),\n\t\tfilter(x => x === 0),\n\t\tmap(() => Server.serialize()),\n\t\tfirst(),\n\t);\n\t/*\n\tconst module = Server.bootstrap(AppModule, html);\n\tconsole.log(module);\n\t// return of(Server.serialize());\n\treturn HttpClient.pendingRequests$.pipe(\n\t\tfilter(x => x === 0),\n\t\tmap(x => Server.serialize()),\n\t\tfirst(),\n\t);\n\t*/\n}\n"]}