{"version":3,"sources":["www/browser/src/main.browser.ts","../../www/browser/src/http/http-event.ts","../../www/browser/src/http/http-headers.ts","../../www/browser/src/http/http-error-response.ts","../../www/browser/src/http/http-response.ts","../../www/browser/src/http/http-fetch.handler.ts","../../www/browser/src/http/http-interceptor.ts","../../www/browser/src/http/http-params.ts","../../www/browser/src/http/http-request.ts","../../www/browser/src/http/http-client.ts","../../www/browser/src/vars.ts","../../www/browser/src/app.component.ts","../../www/browser/src/app.module.ts","../../www/browser/src/main.browser.ts"],"names":["rxcomp","rxjs","operators","_inheritsLoose","subClass","superClass","prototype","Object","create","constructor","__proto__","_getPrototypeOf","o","setPrototypeOf","getPrototypeOf","_setPrototypeOf","p","_isNativeReflectConstruct","Reflect","construct","sham","Proxy","Date","toString","call","e","_construct","Parent","args","Class","a","push","apply","instance","Function","bind","arguments","_wrapNativeSuper","_cache","Map","undefined","fn","indexOf","TypeError","has","get","set","Wrapper","this","value","enumerable","writable","configurable","HttpEventType","HttpHeaders","options","_this","headers_","headers","forEach","key","split","keys","values","append","line","index","slice","trim","_proto","join","clone","clone_","delete","callback","thisArg","_this2","v","k","serialize","HttpErrorResponse","_Error","message","status","statusText","ok","type","ResponseError","name","url","error","request","assign","Error","HttpResponse","Response","body","HttpFetchHandler","response_","handle","method","requestInfo","urlWithParams","requestInit","toInitRequest","from","fetch","then","response","getProgress","getResponse","pipe","catchError","errorResponse","httpErrorResponse","nextError$","next","of","finalize","clonedBody","isPlatformBrowser","reportProgress","reader","getReader","contentLength","Promise","resolve","reject","progress","percent","current","total","read","_ref2","onProgress","done","receivedLength","closed","length","_ref","responseType","json","catch","err","console","log","getResponseType","_this3","getReadableStream","ReadableStream","start","controller","_ref3","close","enqueue","HttpInterceptorHandler","interceptor","req","intercept","HttpInterceptors","fetchHandler","HttpInterceptingHandler","chain","interceptors","reduceRight","HttpUrlEncodingCodec","encodeKey","encodeParam_","encodeValue","decodeKey","decodeURIComponent","decodeValue","HttpParams","encoder","params_","params","Array","isArray","queryString","keyValue","parseRawParams_","_proto2","getAll","map","x","filter","encodeURIComponent","replace","HttpRequest","third","fourth","withCredentials","observe","isStaticFile","test","toUpperCase","methodHasBody","sep","serializeBody","isArrayBuffer","isBlob","isFormData","JSON","stringify","detectContentTypeHeader","mode","credentials","cache","redirect","toFetchRequest__","Request","ArrayBuffer","Blob","FormData","HttpClient","incrementPendingRequest","pendingRequests$","getValue","decrementPendingRequest","request$","first","events$","concatMap","handler","throwError","getError","event","delete$","get$","head$","jsonp$","callbackParam","options$","patch$","optionsWithBody_","post$","put$","statusCode","statusMessage","BehaviorSubject","Vars","CustomInterceptor","clonedRequest","AppComponent","_Component","items","onInit","methodUrl","query","subscribe","data","getTodos","pushChanges","errors$","takeUntil","unsubscribe$","onClick","item","completed","Component","selector","AppModule","_Module","Module","imports","CoreModule","declarations","bootstrap","Browser"],"mappings":"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","file":"docs\\js\\main.min.js","sourcesContent":[null,"export enum HttpEventType {\r\n\tSent,\r\n\tUploadProgress,\r\n\tResponseHeader,\r\n\tDownloadProgress,\r\n\tResponse,\r\n\tUser,\r\n\tResponseError,\r\n}\r\n\r\nexport interface HttpProgressEvent {\r\n\ttype: HttpEventType.DownloadProgress | HttpEventType.UploadProgress;\r\n\tloaded: number;\r\n\ttotal?: number;\r\n}\r\n\r\nexport interface HttpDownloadProgressEvent extends HttpProgressEvent {\r\n\ttype: HttpEventType.DownloadProgress;\r\n\tpartialText?: string;\r\n}\r\n\r\nexport interface HttpUploadProgressEvent extends HttpProgressEvent {\r\n\ttype: HttpEventType.UploadProgress;\r\n}\r\n\r\nexport interface HttpSentEvent {\r\n\ttype: HttpEventType.Sent;\r\n}\r\n\r\nexport interface HttpUserEvent<T> {\r\n\ttype: HttpEventType.User;\r\n}\r\n","\r\nexport type IHttpHeaders = string | { [name: string]: string | string[] };\r\n\r\nexport class HttpHeaders implements Headers {\r\n\tprivate headers_: Map<string, string[]> = new Map<string, string[]>();\r\n\r\n\tconstructor(options?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined) {\r\n\t\tconst headers = this.headers_;\r\n\t\tif (options instanceof HttpHeaders) {\r\n\t\t\toptions.headers_.forEach((value, key) => {\r\n\t\t\t\theaders.set(key, value);\r\n\t\t\t});\r\n\t\t} else if (typeof (options as Headers)?.forEach === 'function') {\r\n\t\t\t(options as Headers).forEach((value, key) => {\r\n\t\t\t\theaders.set(key, value.split(', '));\r\n\t\t\t});\r\n\t\t} else if (typeof options === 'object') {\r\n\t\t\tObject.keys(options).forEach(key => {\r\n\t\t\t\tlet values: string | string[] = (options as any)[key];\r\n\t\t\t\tif (typeof values === 'string') {\r\n\t\t\t\t\tvalues = [values];\r\n\t\t\t\t}\r\n\t\t\t\tif (headers.has(key)) {\r\n\t\t\t\t\tvalues.forEach(value => this.append(key, value));\r\n\t\t\t\t} else {\r\n\t\t\t\t\theaders.set(key, values);\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t} else if (typeof options === 'string') {\r\n\t\t\toptions.split('\\n').forEach(line => {\r\n\t\t\t\tconst index = line.indexOf(':');\r\n\t\t\t\tif (index > 0) {\r\n\t\t\t\t\tconst key = line.slice(0, index);;\r\n\t\t\t\t\tconst value = line.slice(index + 1).trim();\r\n\t\t\t\t\tif (headers.has(key)) {\r\n\t\t\t\t\t\tthis.append(key, value);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\theaders.set(key, [value]);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t}\r\n\t\tif (!headers.has('Accept')) {\r\n\t\t\theaders.set('Accept', ['application/json', 'text/plain', '*/*']);\r\n\t\t}\r\n\t\tif (!headers.has('Content-Type')) {\r\n\t\t\theaders.set('Content-Type', ['application/json']);\r\n\t\t}\r\n\t}\r\n\r\n\thas(key: string): boolean {\r\n\t\treturn this.headers_.has(key);\r\n\t}\r\n\r\n\tget(key: string): string | null {\r\n\t\tconst values = this.headers_.get(key);\r\n\t\treturn values ? values.join(', ') : null;\r\n\t}\r\n\r\n\tset(key: string, value: string): HttpHeaders {\r\n\t\tconst clone = this.clone_();\r\n\t\tclone.headers_.set(key, value.split(', '));\r\n\t\treturn clone;\r\n\t}\r\n\r\n\tappend(key: string, value: string): HttpHeaders {\r\n\t\tconst clone = this.clone_();\r\n\t\tconst values: string[] = clone.headers_.has(key) ? clone.headers_.get(key) || [] : [];\r\n\t\tvalues.push(value);\r\n\t\tclone.headers_.set(key, values);\r\n\t\treturn clone;\r\n\t}\r\n\r\n\tdelete(key: string): HttpHeaders {\r\n\t\tconst clone = this.clone_();\r\n\t\tclone.headers_.delete(key);\r\n\t\treturn clone;\r\n\t}\r\n\r\n\tforEach(callback: (value: string, key: string, parent: Headers) => void, thisArg?: any): void {\r\n\t\tthis.headers_.forEach((v, k) => {\r\n\t\t\tcallback(v.join(', '), k, this);\r\n\t\t});\r\n\t}\r\n\r\n\tserialize(): Headers | string[][] | Record<string, string> | undefined {\r\n\t\tconst headers: string[][] = [];\r\n\t\tthis.forEach((value, key) => {\r\n\t\t\theaders.push([key, value]);\r\n\t\t});\r\n\t\treturn headers;\r\n\t}\r\n\r\n\tprivate clone_(): HttpHeaders {\r\n\t\tconst clone = new HttpHeaders();\r\n\t\tthis.headers_.forEach((value, key) => {\r\n\t\t\tclone.headers_.set(key, value);\r\n\t\t});\r\n\t\treturn clone;\r\n\t}\r\n\r\n}\r\n\r\n/*\r\nexport class HttpHeaders implements Headers {\r\n\r\n\tprivate headers: Map<string, string[]> = new Map<string, string[]>();;\r\n\tprivate normalizedNames: Map<string, string> = new Map();\r\n\r\n\tconstructor(headers?: IHttpHeaders) {\r\n\t\tif (typeof headers === 'string') {\r\n\t\t\theaders.split('\\n').forEach(line => {\r\n\t\t\t\tconst index = line.indexOf(':');\r\n\t\t\t\tif (index > 0) {\r\n\t\t\t\t\tconst name = line.slice(0, index);\r\n\t\t\t\t\tconst key = name.toLowerCase();\r\n\t\t\t\t\tconst value = line.slice(index + 1).trim();\r\n\t\t\t\t\tif (!this.normalizedNames.has(key)) {\r\n\t\t\t\t\t\tthis.normalizedNames.set(key, name);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (this.headers.has(key)) {\r\n\t\t\t\t\t\tthis.headers.get(key)!.push(value);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tthis.headers.set(key, [value]);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t} else if (typeof headers === 'object') {\r\n\t\t\tObject.keys(headers).forEach(name => {\r\n\t\t\t\tlet values: string | string[] = headers[name];\r\n\t\t\t\tconst key = name.toLowerCase();\r\n\t\t\t\tif (typeof values === 'string') {\r\n\t\t\t\t\tvalues = [values];\r\n\t\t\t\t}\r\n\t\t\t\tif (values.length > 0) {\r\n\t\t\t\t\tthis.headers.set(key, values);\r\n\t\t\t\t\tif (!this.normalizedNames.has(key)) {\r\n\t\t\t\t\t\tthis.normalizedNames.set(key, name);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t}\r\n\t}\r\n\r\n\tappend(name: string, value: string): void {\r\n\t\tthis.applyUpdate({ name, value, operation: 'append' });\r\n\t}\r\n\r\n\tdelete(name: string): void {\r\n\t\tthis.applyUpdate({ name, operation: 'delete' });\r\n\t}\r\n\r\n\tget(name: string): string | null {\r\n\t\tconst values = this.headers.get(name.toLowerCase());\r\n\t\treturn values && values.length > 0 ? values[0] : null;\r\n\t}\r\n\r\n\thas(name: string): boolean {\r\n\t\t// this.init();\r\n\t\treturn this.headers.has(name.toLowerCase());\r\n\t}\r\n\r\n\tset(name: string, value: string | string[]): void {\r\n\t\tthis.applyUpdate({ name, value, operation: 'set' });\r\n\t}\r\n\r\n\t// forEach(callback: (name: string, values: string[]) => void):void {\r\n\t// \tthis.init();\r\n\t//\tArray.from(this.normalizedNames.keys()).forEach(key => callback(this.normalizedNames.get(key)!, this.headers.get(key)!));\r\n\t// }\r\n\r\n\tforEach(callback: (value: string, key: string, parent: Headers) => void, thisArg?: any): void {\r\n\t\tArray.from(this.normalizedNames.keys()).forEach(key => {\r\n\t\t\tconst value = this.headers.get(key)!;\r\n\t\t\tcallback((Array.isArray(value) ? value.join(',') : value), this.normalizedNames.get(key)!, this);\r\n\t\t});\r\n\t}\r\n\r\n\tserialize(): Headers | string[][] | Record<string, string> | undefined {\r\n\t\tconst headers: string[][] = [];\r\n\t\tObject.keys(this.headers.keys()).forEach(key => {\r\n\t\t\tconst value = this.headers.get(key);\r\n\t\t\tif (value) {\r\n\t\t\t\theaders.push([key, ...value]);\r\n\t\t\t}\r\n\t\t});\r\n\t\treturn headers;\r\n\t}\r\n\r\n\tprivate clone(update: any): HttpHeaders {\r\n\t\tconst headers: IHttpHeaders = {};\r\n\t\tObject.keys(this.headers.keys()).forEach(key => {\r\n\t\t\tconst value = this.headers.get(key);\r\n\t\t\tif (value) {\r\n\t\t\t\theaders[key] = value;\r\n\t\t\t}\r\n\t\t});\r\n\t\tthis.applyUpdate(update);\r\n\t\treturn new HttpHeaders(headers);\r\n\t}\r\n\r\n\tprivate applyUpdate(update: any): void {\r\n\t\tconst key = update.name.toLowerCase();\r\n\t\tswitch (update.operation) {\r\n\t\t\tcase 'appen':\r\n\t\t\tcase 'set':\r\n\t\t\t\tlet value = update.value!;\r\n\t\t\t\tif (typeof value === 'string') {\r\n\t\t\t\t\tvalue = [value];\r\n\t\t\t\t}\r\n\t\t\t\tif (value.length === 0) {\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t\tif (!this.normalizedNames.has(key)) {\r\n\t\t\t\t\tthis.normalizedNames.set(key, update.name);\r\n\t\t\t\t}\r\n\t\t\t\tconst base = (update.op === 'append' ? this.headers.get(key) : undefined) || [];\r\n\t\t\t\tbase.push(...value);\r\n\t\t\t\tthis.headers.set(key, base);\r\n\t\t\t\tbreak;\r\n\t\t\tcase 'delete':\r\n\t\t\t\tconst toDelete = update.value as string | undefined;\r\n\t\t\t\tif (!toDelete) {\r\n\t\t\t\t\tthis.headers.delete(key);\r\n\t\t\t\t\tthis.normalizedNames.delete(key);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tlet existing = this.headers.get(key);\r\n\t\t\t\t\tif (!existing) {\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\t}\r\n\t\t\t\t\texisting = existing.filter(value => toDelete.indexOf(value) === -1);\r\n\t\t\t\t\tif (existing.length === 0) {\r\n\t\t\t\t\t\tthis.headers.delete(key);\r\n\t\t\t\t\t\tthis.normalizedNames.delete(key);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tthis.headers.set(key, existing);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\r\n}\r\n*/\r\n\r\n/*\r\nexport class HttpHeaders {\r\n\r\n\tprivate headers!: Map<string, string[]>;\r\n\tprivate normalizedNames: Map<string, string> = new Map();\r\n\tprivate lazyInit!: HttpHeaders | Function | null;\r\n\tprivate lazyUpdate: Update[] | null = null;\r\n\r\n\tconstructor(headers?: string | { [name: string]: string | string[] }) {\r\n\t\tif (!headers) {\r\n\t\t\tthis.headers = new Map<string, string[]>();\r\n\t\t} else if (typeof headers === 'string') {\r\n\t\t\tthis.lazyInit = () => {\r\n\t\t\t\tthis.headers = new Map<string, string[]>();\r\n\t\t\t\theaders.split('\\n').forEach(line => {\r\n\t\t\t\t\tconst index = line.indexOf(':');\r\n\t\t\t\t\tif (index > 0) {\r\n\t\t\t\t\t\tconst name = line.slice(0, index);\r\n\t\t\t\t\t\tconst key = name.toLowerCase();\r\n\t\t\t\t\t\tconst value = line.slice(index + 1).trim();\r\n\t\t\t\t\t\tthis.maybeSetNormalizedName(name, key);\r\n\t\t\t\t\t\tif (this.headers.has(key)) {\r\n\t\t\t\t\t\t\tthis.headers.get(key)!.push(value);\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tthis.headers.set(key, [value]);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\t\t\t};\r\n\t\t} else {\r\n\t\t\tthis.lazyInit = () => {\r\n\t\t\t\tthis.headers = new Map<string, string[]>();\r\n\t\t\t\tObject.keys(headers).forEach(name => {\r\n\t\t\t\t\tlet values: string | string[] = headers[name];\r\n\t\t\t\t\tconst key = name.toLowerCase();\r\n\t\t\t\t\tif (typeof values === 'string') {\r\n\t\t\t\t\t\tvalues = [values];\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (values.length > 0) {\r\n\t\t\t\t\t\tthis.headers.set(key, values);\r\n\t\t\t\t\t\tthis.maybeSetNormalizedName(name, key);\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\t\t\t};\r\n\t\t}\r\n\t}\r\n\r\n\thas(name: string): boolean {\r\n\t\tthis.init();\r\n\t\treturn this.headers.has(name.toLowerCase());\r\n\t}\r\n\r\n\tget(name: string): string | null {\r\n\t\tthis.init();\r\n\t\tconst values = this.headers.get(name.toLowerCase());\r\n\t\treturn values && values.length > 0 ? values[0] : null;\r\n\t}\r\n\r\n\tkeys(): string[] {\r\n\t\tthis.init();\r\n\t\treturn Array.from(this.normalizedNames.values());\r\n\t}\r\n\r\n\tgetAll(name: string): string[] | null {\r\n\t\tthis.init();\r\n\t\treturn this.headers.get(name.toLowerCase()) || null;\r\n\t}\r\n\r\n\tappend(name: string, value: string | string[]): HttpHeaders {\r\n\t\treturn this.clone({ name, value, operation: 'a' });\r\n\t}\r\n\r\n\tset(name: string, value: string | string[]): HttpHeaders {\r\n\t\treturn this.clone({ name, value, operation: 's' });\r\n\t}\r\n\r\n\tdelete(name: string, value?: string | string[]): HttpHeaders {\r\n\t\treturn this.clone({ name, value, operation: 'd' });\r\n\t}\r\n\r\n\tprivate maybeSetNormalizedName(name: string, key: string): void {\r\n\t\tif (!this.normalizedNames.has(key)) {\r\n\t\t\tthis.normalizedNames.set(key, name);\r\n\t\t}\r\n\t}\r\n\r\n\tprivate init(): void {\r\n\t\tif (!!this.lazyInit) {\r\n\t\t\tif (this.lazyInit instanceof HttpHeaders) {\r\n\t\t\t\tthis.copyFrom(this.lazyInit);\r\n\t\t\t} else {\r\n\t\t\t\tthis.lazyInit();\r\n\t\t\t}\r\n\t\t\tthis.lazyInit = null;\r\n\t\t\tif (!!this.lazyUpdate) {\r\n\t\t\t\tthis.lazyUpdate.forEach(update => this.applyUpdate(update));\r\n\t\t\t\tthis.lazyUpdate = null;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tprivate copyFrom(other: HttpHeaders) {\r\n\t\tother.init();\r\n\t\tArray.from(other.headers.keys()).forEach(key => {\r\n\t\t\tthis.headers.set(key, other.headers.get(key)!);\r\n\t\t\tthis.normalizedNames.set(key, other.normalizedNames.get(key)!);\r\n\t\t});\r\n\t}\r\n\r\n\tprivate clone(update: Update): HttpHeaders {\r\n\t\tconst clone = new HttpHeaders();\r\n\t\tclone.lazyInit =\r\n\t\t\t(!!this.lazyInit && this.lazyInit instanceof HttpHeaders) ? this.lazyInit : this;\r\n\t\tclone.lazyUpdate = (this.lazyUpdate || []).concat([update]);\r\n\t\treturn clone;\r\n\t}\r\n\r\n\tprivate applyUpdate(update: Update): void {\r\n\t\tconst key = update.name.toLowerCase();\r\n\t\tswitch (update.operation) {\r\n\t\t\tcase 'a':\r\n\t\t\tcase 's':\r\n\t\t\t\tlet value = update.value!;\r\n\t\t\t\tif (typeof value === 'string') {\r\n\t\t\t\t\tvalue = [value];\r\n\t\t\t\t}\r\n\t\t\t\tif (value.length === 0) {\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t\tthis.maybeSetNormalizedName(update.name, key);\r\n\t\t\t\tconst base = (update.op === 'a' ? this.headers.get(key) : undefined) || [];\r\n\t\t\t\tbase.push(...value);\r\n\t\t\t\tthis.headers.set(key, base);\r\n\t\t\t\tbreak;\r\n\t\t\tcase 'd':\r\n\t\t\t\tconst toDelete = update.value as string | undefined;\r\n\t\t\t\tif (!toDelete) {\r\n\t\t\t\t\tthis.headers.delete(key);\r\n\t\t\t\t\tthis.normalizedNames.delete(key);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tlet existing = this.headers.get(key);\r\n\t\t\t\t\tif (!existing) {\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\t}\r\n\t\t\t\t\texisting = existing.filter(value => toDelete.indexOf(value) === -1);\r\n\t\t\t\t\tif (existing.length === 0) {\r\n\t\t\t\t\t\tthis.headers.delete(key);\r\n\t\t\t\t\t\tthis.normalizedNames.delete(key);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tthis.headers.set(key, existing);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\r\n\tforEach(fn: (name: string, values: string[]) => void) {\r\n\t\tthis.init();\r\n\t\tArray.from(this.normalizedNames.keys()).forEach(key => fn(this.normalizedNames.get(key)!, this.headers.get(key)!));\r\n\t}\r\n\r\n}\r\n*/\r\n","\r\n/*\r\nexport default class HttpErrorResponse extends Error {\r\n\tstatusCode?: number;\r\n\tstatusMessage?: string;\r\n}\r\n*/\r\n\r\nimport { HttpEventType } from './http-event';\r\nimport { HttpHeaders } from './http-headers';\r\nimport { HttpRequest } from './http-request';\r\nimport { IHttpHeaderResponse } from './http-response';\r\n\r\nexport interface IHttpJsonParseError {\r\n\terror: Error;\r\n\ttext: string;\r\n}\r\n\r\nexport interface IHttpErrorResponse<T> extends IHttpHeaderResponse<T> {\r\n\terror?: any | undefined;\r\n\tmessage?: string;\r\n\tname?: string;\r\n\trequest?: HttpRequest<T> | null;\r\n}\r\n\r\nexport class HttpErrorResponse<T> extends Error implements IHttpErrorResponse<T> {\r\n\treadonly headers!: HttpHeaders;\r\n\treadonly status: number = 0;\r\n\treadonly statusText: string = 'Unknown Error';\r\n\treadonly url: string | undefined;\r\n\treadonly ok: boolean = false;\r\n\treadonly type: HttpEventType.ResponseError = HttpEventType.ResponseError;\r\n\treadonly error: any | undefined;\r\n\treadonly message: string = 'Unknown Error';\r\n\treadonly name: string = 'HttpErrorResponse';\r\n\treadonly request!: HttpRequest<T> | null;\r\n\tconstructor(options?: IHttpErrorResponse<T>) {\r\n\t\tsuper(options?.message || 'Unknown Error');\r\n\t\tif (options) {\r\n\t\t\tthis.headers = new HttpHeaders(options.headers);\r\n\t\t\tthis.status = options.status || this.status;\r\n\t\t\tthis.statusText = options.statusText || this.statusText;\r\n\t\t\tthis.url = options.url || this.url;\r\n\t\t\tthis.error = options.error || this.error;\r\n\t\t\tthis.name = options.name || this.name;\r\n\t\t\tthis.request = options.request || null;\r\n\t\t}\r\n\t}\r\n\tclone<T>(options?: IHttpErrorResponse<T>): HttpErrorResponse<T> {\r\n\t\toptions = Object.assign({\r\n\t\t\theaders: this.headers,\r\n\t\t\tstatus: this.status,\r\n\t\t\tstatusText: this.statusText,\r\n\t\t\turl: this.url,\r\n\t\t\terror: this.error,\r\n\t\t\tmessage: this.message,\r\n\t\t\tname: this.name,\r\n\t\t\trequest: this.request,\r\n\t\t}, options || {});\r\n\t\tconst clone = new HttpErrorResponse<T>(options);\r\n\t\treturn clone;\r\n\t}\r\n}\r\n\r\n/*\r\nexport class HttpErrorResponse<T> extends HttpResponseBase implements Error {\r\n\treadonly name = 'HttpErrorResponse';\r\n\treadonly message: string;\r\n\treadonly error: any | null;\r\n\treadonly ok = false;\r\n\tconstructor(errorResponse: IHttpErrorResponse, response: HttpResponse<T> | null = null) {\r\n\t\tsuper(errorResponse, 0, 'Unknown Error');\r\n\t\tif (Error.captureStackTrace) {\r\n\t\t\tError.captureStackTrace(this, HttpErrorResponse);\r\n\t\t}\r\n\t\tif (this.status >= 200 && this.status < 300) {\r\n\t\t\tthis.message = `Http failure during parsing for ${errorResponse.url || '(unknown url)'}`;\r\n\t\t} else {\r\n\t\t\tthis.message = `Http failure response for ${errorResponse.url || '(unknown url)'}: ${errorResponse.status} ${errorResponse.statusText}`;\r\n\t\t}\r\n\t\tthis.error = errorResponse.error || null;\r\n\t}\r\n}\r\n*/\r\n","import { HttpEventType, HttpProgressEvent, HttpSentEvent, HttpUserEvent } from './http-event';\r\nimport { HttpHeaders } from './http-headers';\r\nimport { HttpBodyType } from './http-request';\r\n\r\nexport type HttpEvent<T> = HttpSentEvent | HttpHeaderResponse<T> | HttpResponse<T> | HttpProgressEvent | HttpUserEvent<T>;\r\n\r\nexport interface IHttpHeaderResponse<T> {\r\n\theaders?: HttpHeaders,\r\n\tstatus?: number,\r\n\tstatusText?: string,\r\n\turl?: string,\r\n\tok?: boolean;\r\n\ttype?: HttpEventType;\r\n}\r\n\r\nexport interface IHttpResponse<T> extends IHttpHeaderResponse<T> {\r\n\tbody?: HttpBodyType;\r\n}\r\n\r\nexport class HttpHeaderResponse<T> implements IHttpHeaderResponse<T> {\r\n\treadonly headers!: HttpHeaders;\r\n\treadonly status: number = 200;\r\n\treadonly statusText: string = 'OK';\r\n\treadonly url: string | undefined;\r\n\treadonly ok: boolean;\r\n\treadonly type: HttpEventType.ResponseHeader = HttpEventType.ResponseHeader;\r\n\tconstructor(options?: IHttpHeaderResponse<T>) {\r\n\t\tif (options) {\r\n\t\t\tthis.headers = new HttpHeaders(options.headers);\r\n\t\t\tthis.status = options.status || this.status;\r\n\t\t\tthis.statusText = options.statusText || this.statusText;\r\n\t\t\tthis.url = options.url || this.url;\r\n\t\t}\r\n\t\tthis.ok = this.status >= 200 && this.status < 300;\r\n\t}\r\n\tclone<T>(options?: IHttpHeaderResponse<T>): HttpHeaderResponse<T> {\r\n\t\toptions = Object.assign({\r\n\t\t\theaders: this.headers,\r\n\t\t\tstatus: this.status,\r\n\t\t\tstatusText: this.statusText,\r\n\t\t\turl: this.url,\r\n\t\t\tok: this.ok,\r\n\t\t\ttype: this.type,\r\n\t\t}, options || {});\r\n\t\tconst clone = new HttpHeaderResponse<T>(options);\r\n\t\treturn clone;\r\n\t}\r\n}\r\n\r\nexport class HttpResponse<T> implements IHttpResponse<T> {\r\n\treadonly headers!: HttpHeaders;\r\n\treadonly status: number = 200;\r\n\treadonly statusText: string = 'OK';\r\n\treadonly url: string | undefined;\r\n\treadonly ok: boolean;\r\n\treadonly type: HttpEventType.Response = HttpEventType.Response;\r\n\treadonly body: HttpBodyType = null;\r\n\tconstructor(options?: IHttpResponse<T>) {\r\n\t\tif (options) {\r\n\t\t\tthis.headers = new HttpHeaders(options.headers);\r\n\t\t\tthis.status = options.status || this.status;\r\n\t\t\tthis.statusText = options.statusText || this.statusText;\r\n\t\t\tthis.url = options.url || this.url;\r\n\t\t\tthis.body = options.body || this.body;\r\n\t\t}\r\n\t\tthis.ok = this.status >= 200 && this.status < 300;\r\n\t}\r\n\tclone<T>(options?: IHttpResponse<T>): HttpResponse<T> {\r\n\t\toptions = Object.assign({\r\n\t\t\theaders: this.headers,\r\n\t\t\tstatus: this.status,\r\n\t\t\tstatusText: this.statusText,\r\n\t\t\turl: this.url,\r\n\t\t\tok: this.ok,\r\n\t\t\ttype: this.type,\r\n\t\t\tbody: this.body,\r\n\t\t}, options || {});\r\n\t\tconst clone = new HttpResponse<T>(options);\r\n\t\treturn clone;\r\n\t}\r\n}\r\n\r\nexport abstract class HttpResponseBase<T> {\r\n\treadonly headers: HttpHeaders;\r\n\treadonly status: number = 200;\r\n\treadonly statusText: string = 'OK';\r\n\treadonly url: string | undefined;\r\n\treadonly ok: boolean;\r\n\treadonly type!: HttpEventType.Response | HttpEventType.ResponseHeader;\r\n\tconstructor(\r\n\t\toptions: IHttpHeaderResponse<T>,\r\n\t\tdefaultStatus: number = 200,\r\n\t\tdefaultStatusText: string = 'OK'\r\n\t) {\r\n\t\tthis.headers = options.headers || new HttpHeaders();\r\n\t\tthis.status = options.status !== undefined ? options.status : defaultStatus;\r\n\t\tthis.statusText = options.statusText || defaultStatusText;\r\n\t\tthis.url = options.url || undefined;\r\n\t\tthis.ok = this.status >= 200 && this.status < 300;\r\n\t}\r\n}\r\n\r\n/*\r\n// !!!\r\nexport default class HttpResponse {\r\n\tdata?: any;\r\n\turl: string = '';\r\n\tstatus: number = 0;\r\n\tstatusText: string = '';\r\n\tok: boolean = false;\r\n\tredirected: boolean = false;\r\n\tget static() {\r\n\t\treturn this.url!.indexOf('.json') === this.url!.length - 5;\r\n\t}\r\n\tconstructor(response: Response) {\r\n\t\tthis.data = null;\r\n\t\tif (response) {\r\n\t\t\tthis.url = response.url;\r\n\t\t\tthis.status = response.status;\r\n\t\t\tthis.statusText = response.statusText;\r\n\t\t\tthis.ok = response.ok;\r\n\t\t\tthis.redirected = response.redirected;\r\n\t\t}\r\n\t}\r\n}\r\n*/\r\n","import { isPlatformBrowser, nextError$ } from 'rxcomp';\r\nimport { from, Observable, of } from 'rxjs';\r\nimport { catchError, finalize } from 'rxjs/operators';\r\nimport { HttpErrorResponse, IHttpErrorResponse } from './http-error-response';\r\nimport { HttpHandler } from './http-handler';\r\nimport { HttpRequest } from './http-request';\r\nimport { HttpEvent, HttpResponse, IHttpResponse } from './http-response';\r\n\r\nexport class HttpFetchHandler implements HttpHandler {\r\n\r\n\tprivate response_: HttpResponse<any> | null = null;\r\n\r\n\thandle<T>(request: HttpRequest<any>): Observable<HttpEvent<T>> {\r\n\t\tif (!request.method) {\r\n\t\t\tthrow new Error(`missing method`);\r\n\t\t}\r\n\t\tconst requestInfo: RequestInfo = request.urlWithParams;\r\n\t\tconst requestInit: RequestInit = request.toInitRequest();\r\n\t\t// const fetchRequest: Request = request.toFetchRequest__();\r\n\t\t// console.log('fetchRequest', fetchRequest);\r\n\t\t// fetchRequest.headers.forEach((value, key) => console.log('HttpFetchHandler.handle', key, value));\r\n\t\t// request = request.clone({ headers: fetchRequest.headers });\r\n\t\t// console.log('HttpFetchHandler.handle', 'requestInfo', requestInfo, 'requestInit', requestInit);\r\n\t\treturn from(\r\n\t\t\tfetch(requestInfo, requestInit)\r\n\t\t\t\t// fetch(fetchRequest)\r\n\t\t\t\t.then((response: Response) => this.getProgress<T>(response, request))\r\n\t\t\t\t.then((response: Response | HttpResponse<T>) => this.getResponse<T>(response, request))\r\n\t\t).pipe(\r\n\t\t\tcatchError((error: Error) => {\r\n\t\t\t\tconst errorResponse: IHttpErrorResponse<T> = { error };\r\n\t\t\t\tif (this.response_) {\r\n\t\t\t\t\terrorResponse.headers = this.response_.headers;\r\n\t\t\t\t\terrorResponse.status = this.response_.status;\r\n\t\t\t\t\terrorResponse.statusText = this.response_.statusText;\r\n\t\t\t\t\terrorResponse.url = this.response_.url;\r\n\t\t\t\t\terrorResponse.request = request;\r\n\t\t\t\t}\r\n\t\t\t\tconst httpErrorResponse = new HttpErrorResponse<T>(errorResponse);\r\n\t\t\t\t// console.log('httpErrorResponse', httpErrorResponse);\r\n\t\t\t\tnextError$.next(httpErrorResponse);\r\n\t\t\t\treturn of(this.response_) as Observable<any>;\r\n\t\t\t\t// return throwError(httpErrorResponse);\r\n\t\t\t}),\r\n\t\t\tfinalize(() => {\r\n\t\t\t\tthis.response_ = null;\r\n\t\t\t})\r\n\t\t);\r\n\t}\r\n\r\n\t/*\r\n\tonProgress(value: Uint8Array, done: boolean, request, reader, progress) {\r\n\t\tconsole.log(\"value:\", value);\r\n\t\tif (value || done) {\r\n\t\t\tconsole.log(\"upload complete, request.bodyUsed:\", request.bodyUsed);\r\n\t\t\tprogress.value = progress.max;\r\n\t\t\treturn reader.closed.then(() => fileUpload);\r\n\t\t};\r\n\t\tconsole.log(\"upload progress:\", value);\r\n\t\tif (progress.value < file.size) {\r\n\t\t\tprogress.value += 1;\r\n\t\t}\r\n\t\treturn reader.read().then(({ value, done }) => this.onProgress(value, done, request, reader, progress));\r\n\t};\r\n\r\n\tgetProgress_(request) {\r\n\t\tconst uploadProgress = new ReadableStream({\r\n\t\t\tstart(controller) {\r\n\t\t\t\tconsole.log(\"starting upload, request.bodyUsed:\", request.bodyUsed);\r\n\t\t\t\tcontroller.enqueue(request.bodyUsed);\r\n\t\t\t},\r\n\t\t\tpull(controller) {\r\n\t\t\t\tif (request.bodyUsed) {\r\n\t\t\t\t\tcontroller.close();\r\n\t\t\t\t}\r\n\t\t\t\tcontroller.enqueue(request.bodyUsed);\r\n\t\t\t\tconsole.log(\"pull, request.bodyUsed:\", request.bodyUsed);\r\n\t\t\t},\r\n\t\t\tcancel(reason) {\r\n\t\t\t\tconsole.log(reason);\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\tconst [fileUpload, reader] = [\r\n\t\t\tupload(request).catch(e => {\r\n\t\t\t\treader.cancel();\r\n\t\t\t\tconsole.log(e);\r\n\t\t\t\tthrow e\r\n\t\t\t}), uploadProgress.getReader()\r\n\t\t];\r\n\t}\r\n\t*/\r\n\r\n\tgetProgress<T>(response: Response, request: HttpRequest<any>): Promise<Response | HttpResponse<T>> {\r\n\t\t// console.log('HttpFetchHandler.setProgress', request.reportProgress, response.body);\r\n\t\tconst clonedBody = response.clone().body;\r\n\t\tif (isPlatformBrowser && request.reportProgress && clonedBody) {\r\n\t\t\tconst reader: ReadableStreamDefaultReader<Uint8Array> = clonedBody.getReader();\r\n\t\t\tconst contentLength = response.headers && response.headers.has('Content-Length') ? +(response.headers.get('Content-Length') || 0) : 0;\r\n\t\t\treturn new Promise((resolve, reject) => {\r\n\t\t\t\t/*\r\n\t\t\t\tlet receivedLength = 0; // received that many bytes at the moment\r\n\t\t\t\tconst chunks: Uint8Array[] = []; // array of received binary chunks (comprises the body)\r\n\t\t\t\tconst getChunk = () => {\r\n\t\t\t\t\treturn reader.read().then(({ done, value }) => {\r\n\t\t\t\t\t\tif (!done) {\r\n\t\t\t\t\t\t\tif (value) {\r\n\t\t\t\t\t\t\t\tchunks.push(value);\r\n\t\t\t\t\t\t\t\treceivedLength += value.length || 0;\r\n\t\t\t\t\t\t\t\tconsole.log(`HttpFetchHandler.setProgress ${(receivedLength / contentLength * 100).toFixed(2)}% ${receivedLength} of ${contentLength}`);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tgetChunk();\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\treader.cancel();\r\n\t\t\t\t\t\t\tresolve(response);\r\n\t\t\t\t\t\t\tif (false) {\r\n\t\t\t\t\t\t\t\t// Step 4: concatenate chunks into single Uint8Array\r\n\t\t\t\t\t\t\t\tconst chunksAll = new Uint8Array(receivedLength); // (4.1)\r\n\t\t\t\t\t\t\t\tlet position = 0;\r\n\t\t\t\t\t\t\t\tfor (let chunk of chunks) {\r\n\t\t\t\t\t\t\t\t\tchunksAll.set(chunk, position); // (4.2)\r\n\t\t\t\t\t\t\t\t\tposition += chunk.length;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t// Step 5: decode into a string\r\n\t\t\t\t\t\t\t\tconst result = new TextDecoder(\"utf-8\").decode(chunksAll);\r\n\t\t\t\t\t\t\t\t// We're done!\r\n\t\t\t\t\t\t\t\tconst data = JSON.parse(result);\r\n\t\t\t\t\t\t\t\tconsole.log('HttpFetchHandler.setProgress data', data);\r\n\t\t\t\t\t\t\t\tresolve(response);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}).catch(error => {\r\n\t\t\t\t\t\treader.cancel();\r\n\t\t\t\t\t\treject(error);\r\n\t\t\t\t\t});\r\n\t\t\t\t};\r\n\t\t\t\tgetChunk();\r\n\t\t\t\t*/\r\n\t\t\t\tconst progress = { progress: 0, percent: 0, current: 0, total: 0 };\r\n\t\t\t\tconst onProgress = (value: Uint8Array | undefined, done: boolean): Promise<any> => {\r\n\t\t\t\t\tlet receivedLength = progress.current;\r\n\t\t\t\t\tif (!done) {\r\n\t\t\t\t\t\tif (value) {\r\n\t\t\t\t\t\t\treceivedLength += value.length || 0;\r\n\t\t\t\t\t\t\tprogress.total = contentLength;\r\n\t\t\t\t\t\t\tprogress.current = receivedLength;\r\n\t\t\t\t\t\t\tprogress.progress = receivedLength / contentLength;\r\n\t\t\t\t\t\t\tprogress.percent = progress.progress * 100;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t// console.log('progress', progress);\r\n\t\t\t\t\t\treturn reader.read().then(({ value, done }) => onProgress(value, done));\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tprogress.total = contentLength;\r\n\t\t\t\t\t\tprogress.current = contentLength;\r\n\t\t\t\t\t\tprogress.progress = 1;\r\n\t\t\t\t\t\tprogress.percent = 100;\r\n\t\t\t\t\t\t// console.log('progress', progress);\r\n\t\t\t\t\t\treturn reader.closed.then(() => response.clone());\r\n\t\t\t\t\t}\r\n\t\t\t\t};\r\n\t\t\t\treader.read()\r\n\t\t\t\t\t.then(({ value, done }) => onProgress(value, done))\r\n\t\t\t\t\t.then(response => {\r\n\t\t\t\t\t\tthis.response_ = new HttpResponse<T>(response as unknown as IHttpResponse<T>);\r\n\t\t\t\t\t\tif (typeof (response as any)[request.responseType] === 'function') {\r\n\t\t\t\t\t\t\treturn (response as any)[request.responseType]().then((json: any) => {\r\n\t\t\t\t\t\t\t\tthis.response_ = new HttpResponse<T>(Object.assign(this.response_, { body: json }) as IHttpResponse<T>);\r\n\t\t\t\t\t\t\t\tif (response.ok) {\r\n\t\t\t\t\t\t\t\t\treturn resolve(this.response_);\r\n\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\treturn reject(this.response_);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\treturn reject(this.response_);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t})\r\n\t\t\t\t\t.catch(err => console.log(\"upload error:\", err));\r\n\t\t\t});\r\n\t\t} else {\r\n\t\t\treturn Promise.resolve(response);\r\n\t\t}\r\n\t}\r\n\r\n\tgetResponse<T>(response: Response | HttpResponse<T>, request: HttpRequest<any>): Promise<HttpResponse<T>> {\r\n\t\tthis.response_ = new HttpResponse<T>(response as IHttpResponse<T>);\r\n\t\tif (isPlatformBrowser && request.reportProgress && response.body) {\r\n\t\t\treturn Promise.resolve(this.response_);\r\n\t\t} else {\r\n\t\t\treturn this.getResponseType(response as Response, request);\r\n\t\t}\r\n\t}\r\n\r\n\tgetResponseType<T>(response: Response, request: HttpRequest<any>): Promise<HttpResponse<T>> {\r\n\t\treturn new Promise((resolve, reject) => {\r\n\t\t\tthis.response_ = new HttpResponse<T>(response as unknown as IHttpResponse<T>);\r\n\t\t\tif (typeof (response as any)[request.responseType] === 'function') {\r\n\t\t\t\treturn (response as any)[request.responseType]().then((json: any) => {\r\n\t\t\t\t\tthis.response_ = new HttpResponse<T>(Object.assign(this.response_, { body: json }) as IHttpResponse<T>);\r\n\t\t\t\t\tif (response.ok) {\r\n\t\t\t\t\t\treturn resolve(this.response_);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\treturn reject(this.response_);\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\t\t\t} else {\r\n\t\t\t\treturn reject(this.response_);\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n\tgetReadableStream<T>(response: Response, request: HttpRequest<any>): ReadableStream {\r\n\t\tconst reader = response.body!.getReader();\r\n\t\tconst readableStream = new ReadableStream({\r\n\t\t\tstart(controller) {\r\n\t\t\t\t// console.log(\"starting upload, request.bodyUsed:\", request.bodyUsed);\r\n\t\t\t\t// controller.enqueue(request.bodyUsed);\r\n\t\t\t\t// The following function handles each data chunk\r\n\t\t\t\tconst push = function () {\r\n\t\t\t\t\t// \"done\" is a Boolean and value a \"Uint8Array\"\r\n\t\t\t\t\treader.read().then(({ done, value }) => {\r\n\t\t\t\t\t\t// Is there no more data to read?\r\n\t\t\t\t\t\tif (done) {\r\n\t\t\t\t\t\t\t// Tell the browser that we have finished sending data\r\n\t\t\t\t\t\t\tcontroller.close();\r\n\t\t\t\t\t\t\treturn;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t// Get the data and send it to the browser via the controller\r\n\t\t\t\t\t\tcontroller.enqueue(value);\r\n\t\t\t\t\t\tpush();\r\n\t\t\t\t\t});\r\n\t\t\t\t};\r\n\t\t\t\tpush();\r\n\t\t\t},\r\n\t\t\t/*\r\n\t\t\tpull(controller) {\r\n\t\t\t\tif (request.bodyUsed) {\r\n\t\t\t\t\tcontroller.close();\r\n\t\t\t\t}\r\n\t\t\t\tcontroller.enqueue(request.bodyUsed);\r\n\t\t\t\tconsole.log(\"pull, request.bodyUsed:\", request.bodyUsed);\r\n\t\t\t},\r\n\t\t\tcancel(reason) {\r\n\t\t\t\tconsole.log(reason);\r\n\t\t\t}\r\n\t\t\t*/\r\n\t\t});\r\n\t\treturn readableStream;\r\n\t}\r\n\r\n}\r\n","import { Observable } from 'rxjs';\r\nimport { HttpFetchHandler } from './http-fetch.handler';\r\nimport { HttpHandler } from './http-handler';\r\nimport { HttpRequest } from './http-request';\r\nimport { HttpEvent } from './http-response';\r\nimport { HttpXhrHandler } from './http-xhr.handler';\r\n\r\nexport interface HttpInterceptor {\r\n\tintercept(req: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>>;\r\n}\r\n\r\nexport class HttpInterceptorHandler implements HttpHandler {\r\n\tconstructor(private next: HttpHandler, private interceptor: HttpInterceptor) { }\r\n\thandle(req: HttpRequest<any>): Observable<HttpEvent<any>> {\r\n\t\treturn this.interceptor.intercept(req, this.next);\r\n\t}\r\n}\r\n\r\nexport const HttpInterceptors: HttpInterceptor[] = [];\r\n\r\nexport class NoopInterceptor implements HttpInterceptor {\r\n\tintercept(req: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {\r\n\t\treturn next.handle(req);\r\n\t}\r\n}\r\n\r\nexport const fetchHandler: HttpHandler = new HttpFetchHandler();\r\nexport const xhrHandler: HttpHandler = new HttpXhrHandler();\r\n\r\nexport class HttpInterceptingHandler implements HttpHandler {\r\n\tprivate chain: HttpHandler | null = null;\r\n\thandle(req: HttpRequest<any>): Observable<HttpEvent<any>> {\r\n\t\tif (this.chain === null) {\r\n\t\t\tconst interceptors = HttpInterceptors;\r\n\t\t\tthis.chain = interceptors.reduceRight((next, interceptor) => new HttpInterceptorHandler(next, interceptor), fetchHandler);\r\n\t\t}\r\n\t\treturn this.chain.handle(req);\r\n\t}\r\n}\r\n\r\nexport function interceptingHandler(handler: HttpHandler, interceptors: HttpInterceptor[] | null = []): HttpHandler {\r\n\tif (!interceptors) {\r\n\t\treturn handler;\r\n\t}\r\n\treturn interceptors.reduceRight((next, interceptor) => new HttpInterceptorHandler(next, interceptor), handler);\r\n}\r\n\r\nexport function jsonpCallbackContext(): Object {\r\n\tif (typeof window === 'object') {\r\n\t\treturn window;\r\n\t}\r\n\treturn {};\r\n}\r\n","\r\nexport interface IHttpParamEncoder {\r\n\tencodeKey(key: string): string;\r\n\tencodeValue(value: string): string;\r\n\tdecodeKey(key: string): string;\r\n\tdecodeValue(value: string): string;\r\n}\r\n\r\nexport class HttpUrlEncodingCodec implements IHttpParamEncoder {\r\n\tencodeKey(key: string): string {\r\n\t\treturn encodeParam_(key);\r\n\t}\r\n\tencodeValue(value: string): string {\r\n\t\treturn encodeParam_(value);\r\n\t}\r\n\tdecodeKey(key: string): string {\r\n\t\treturn decodeURIComponent(key);\r\n\t}\r\n\tdecodeValue(value: string) {\r\n\t\treturn decodeURIComponent(value);\r\n\t}\r\n}\r\n\r\nexport class HttpParams {\r\n\tprivate params_: Map<string, string[]> = new Map<string, string[]>();\r\n\tprivate encoder: IHttpParamEncoder;\r\n\r\n\tconstructor(options?: HttpParams | { [key: string]: any } | string | undefined, encoder: IHttpParamEncoder = new HttpUrlEncodingCodec()) {\r\n\t\tthis.encoder = encoder;\r\n\t\tconst params = this.params_;\r\n\t\tif (options instanceof HttpParams) {\r\n\t\t\toptions.params_.forEach((value, key) => {\r\n\t\t\t\tparams.set(key, value);\r\n\t\t\t});\r\n\t\t} else if (typeof options === 'object') {\r\n\t\t\tObject.keys(options).forEach(key => {\r\n\t\t\t\tconst value = options[key];\r\n\t\t\t\tparams.set(key, Array.isArray(value) ? value : [value]);\r\n\t\t\t});\r\n\t\t} else if (typeof options === 'string') {\r\n\t\t\tparseRawParams_(params, options, this.encoder);\r\n\t\t}\r\n\t\t// ?updates=null&cloneFrom=null&encoder=%5Bobject%20Object%5D&params_=%5Bobject%20Map%5D\r\n\t}\r\n\r\n\tkeys(): string[] {\r\n\t\treturn Array.from(this.params_.keys());\r\n\t}\r\n\r\n\thas(key: string): boolean {\r\n\t\treturn this.params_.has(key);\r\n\t}\r\n\r\n\tget(key: string): string | null {\r\n\t\tconst value = this.params_.get(key);\r\n\t\treturn value ? value[0] : null;\r\n\t}\r\n\r\n\tgetAll(key: string): string[] | null {\r\n\t\treturn this.params_.get(key) || null;\r\n\t}\r\n\r\n\tset(key: string, value: string): HttpParams {\r\n\t\tconst clone = this.clone_();\r\n\t\tclone.params_.set(key, [value]);\r\n\t\treturn clone;\r\n\t}\r\n\r\n\tappend(key: string, value: string): HttpParams {\r\n\t\tconst clone = this.clone_();\r\n\t\tif (clone.has(key)) {\r\n\t\t\tconst values = clone.params_.get(key) || [];\r\n\t\t\tvalues.push(value);\r\n\t\t\tclone.params_.set(key, values);\r\n\t\t} else {\r\n\t\t\tclone.params_.set(key, [value]);\r\n\t\t}\r\n\t\treturn clone;\r\n\t}\r\n\r\n\tdelete(key: string): HttpParams {\r\n\t\tconst clone = this.clone_();\r\n\t\tclone.params_.delete(key);\r\n\t\treturn clone;\r\n\t}\r\n\r\n\ttoString(): string {\r\n\t\treturn this.keys().map((key: string) => {\r\n\t\t\tconst values = this.params_.get(key);\r\n\t\t\treturn this.encoder.encodeKey(key) + (values ? '=' + values.map(x => this.encoder.encodeValue(x)).join('&') : '');\r\n\t\t}).filter(keyValue => keyValue !== '').join('&');\r\n\t}\r\n\r\n\tprivate clone_(): HttpParams {\r\n\t\tconst clone = new HttpParams(undefined, this.encoder);\r\n\t\tthis.params_.forEach((value, key) => {\r\n\t\t\tclone.params_.set(key, value);\r\n\t\t});\r\n\t\treturn clone;\r\n\t}\r\n}\r\n\r\nfunction parseRawParams_(params: Map<string, string[]>, queryString: string, encoder: IHttpParamEncoder): Map<string, string[]> {\r\n\tif (queryString.length > 0) {\r\n\t\tconst keyValueParams: string[] = queryString.split('&');\r\n\t\tkeyValueParams.forEach((keyValue: string) => {\r\n\t\t\tconst index = keyValue.indexOf('=');\r\n\t\t\tconst [key, value]: string[] = index == -1 ? [encoder.decodeKey(keyValue), ''] : [encoder.decodeKey(keyValue.slice(0, index)), encoder.decodeValue(keyValue.slice(index + 1))];\r\n\t\t\tconst values = params.get(key) || [];\r\n\t\t\tvalues.push(value);\r\n\t\t\tparams.set(key, values);\r\n\t\t});\r\n\t}\r\n\treturn params;\r\n}\r\n\r\nfunction encodeParam_(v: string): string {\r\n\treturn encodeURIComponent(v)\r\n\t\t.replace(/%40/gi, '@')\r\n\t\t.replace(/%3A/gi, ':')\r\n\t\t.replace(/%24/gi, '$')\r\n\t\t.replace(/%2C/gi, ',')\r\n\t\t.replace(/%3B/gi, ';')\r\n\t\t.replace(/%2B/gi, '+')\r\n\t\t.replace(/%3D/gi, '=')\r\n\t\t.replace(/%3F/gi, '?')\r\n\t\t.replace(/%2F/gi, '/');\r\n}\r\n","import { HttpHeaders } from './http-headers';\r\nimport { HttpParams } from './http-params';\r\n\r\nexport type HttpMethodType = 'GET' | 'POST' | 'PUT' | 'PATCH' | 'DELETE' | 'OPTIONS' | 'HEAD' | 'JSONP';\r\nexport type HttpMethodBodyType = 'POST' | 'PUT' | 'PATCH';\r\nexport type HttpMethodNoBodyType = 'GET' | 'DELETE' | 'OPTIONS' | 'HEAD' | 'JSONP';\r\nexport type HttpResponseType = 'arraybuffer' | 'blob' | 'json' | 'text';\r\nexport type HttpBodyType<T> = T | string | Blob | ArrayBufferView | ArrayBuffer | FormData | URLSearchParams | ReadableStream<Uint8Array> | null | undefined;\r\nexport type HttpObserveType = 'body' | 'events' | 'response';\r\n\r\nexport interface IHttpRequestInit<T> {\r\n\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined;\r\n\treportProgress?: boolean;\r\n\tparams?: HttpParams | { [key: string]: any } | string | undefined;\r\n\tresponseType?: HttpResponseType;\r\n\twithCredentials?: boolean;\r\n\tobserve?: HttpObserveType;\r\n\tbody?: HttpBodyType<T>;\r\n}\r\n\r\nexport interface IHttpRequest<T> extends IHttpRequestInit<T> {\r\n\tmethod?: HttpMethodType,\r\n\turl?: string,\r\n}\r\n\r\nexport class HttpRequest<T> {\r\n\treadonly body: HttpBodyType<T>;\r\n\treadonly headers!: HttpHeaders;\r\n\treadonly reportProgress: boolean = false;\r\n\treadonly withCredentials: boolean = false;\r\n\treadonly observe: HttpObserveType = 'body';\r\n\treadonly responseType: HttpResponseType = 'json';\r\n\treadonly method: HttpMethodType;\r\n\treadonly params!: HttpParams;\r\n\treadonly urlWithParams: string;\r\n\tconstructor(method: HttpMethodNoBodyType, url: string, options?: IHttpRequestInit<T>);\r\n\tconstructor(method: HttpMethodBodyType, url: string, body: HttpBodyType<T>, options?: IHttpRequestInit<T>);\r\n\tconstructor(method: HttpMethodType, url: string, body: HttpBodyType<T>, options?: IHttpRequestInit<T>);\r\n\tconstructor(method: HttpMethodType, readonly url: string, third?: HttpBodyType<T> | IHttpRequestInit<T> | null, fourth?: IHttpRequestInit<T>) {\r\n\t\t// !!! remove, rethink\r\n\t\tconst isStaticFile: boolean = /\\.(json|xml|txt)(\\?.*)?$/.test(url);\r\n\t\tthis.method = isStaticFile ? 'GET' : method.toUpperCase() as HttpMethodType;\r\n\t\tlet options: IHttpRequestInit<T> | undefined;\r\n\t\tif (methodHasBody(this.method) || !!fourth) {\r\n\t\t\tthis.body = (third !== undefined) ? third as HttpBodyType<T> : null;\r\n\t\t\toptions = fourth;\r\n\t\t} else {\r\n\t\t\toptions = third as IHttpRequestInit<T>;\r\n\t\t}\r\n\t\tif (options) {\r\n\t\t\tthis.reportProgress = !!options.reportProgress;\r\n\t\t\tthis.withCredentials = !!options.withCredentials;\r\n\t\t\tthis.observe = options.observe || this.observe;\r\n\t\t\tif (options.responseType) {\r\n\t\t\t\tthis.responseType = options.responseType;\r\n\t\t\t}\r\n\t\t\tif (options.headers) {\r\n\t\t\t\tthis.headers = new HttpHeaders(options.headers);\r\n\t\t\t}\r\n\t\t\tif (options.params) {\r\n\t\t\t\tthis.params = new HttpParams(options.params);\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (!this.headers) {\r\n\t\t\tthis.headers = new HttpHeaders();\r\n\t\t}\r\n\t\tif (!this.params) {\r\n\t\t\tthis.params = new HttpParams();\r\n\t\t}\r\n\t\tconst params = this.params.toString();\r\n\t\tconst index = url.indexOf('?');\r\n\t\tconst sep: string = index === -1 ? '?' : (index < url.length - 1 ? '&' : '');\r\n\t\tthis.urlWithParams = url + (params.length ? sep + params : params);\r\n\t}\r\n\tserializeBody(): ArrayBuffer | Blob | FormData | string | null {\r\n\t\tif (this.body === null) {\r\n\t\t\treturn null;\r\n\t\t}\r\n\t\tif (isArrayBuffer(this.body) || isBlob(this.body) || isFormData(this.body) ||\r\n\t\t\ttypeof this.body === 'string') {\r\n\t\t\treturn this.body;\r\n\t\t}\r\n\t\tif (this.body instanceof HttpParams) {\r\n\t\t\treturn (<any>this.body).toString();\r\n\t\t}\r\n\t\tif (typeof this.body === 'object' || typeof this.body === 'boolean' || Array.isArray(this.body)) {\r\n\t\t\treturn JSON.stringify(this.body);\r\n\t\t}\r\n\t\treturn (this.body as any).toString();\r\n\t}\r\n\tdetectContentTypeHeader(): string | null {\r\n\t\tif (this.body === null) {\r\n\t\t\treturn null;\r\n\t\t}\r\n\t\tif (isFormData(this.body)) {\r\n\t\t\treturn null;\r\n\t\t}\r\n\t\tif (isBlob(this.body)) {\r\n\t\t\treturn this.body.type || null;\r\n\t\t}\r\n\t\tif (isArrayBuffer(this.body)) {\r\n\t\t\treturn null;\r\n\t\t}\r\n\t\tif (typeof this.body === 'string') {\r\n\t\t\treturn 'text/plain';\r\n\t\t}\r\n\t\tif (this.body instanceof HttpParams) {\r\n\t\t\treturn 'application/x-www-form-urlencoded;charset=UTF-8';\r\n\t\t}\r\n\t\tif (typeof this.body === 'object' || typeof this.body === 'number' ||\r\n\t\t\tArray.isArray(this.body)) {\r\n\t\t\treturn 'application/json';\r\n\t\t}\r\n\t\treturn null;\r\n\t}\r\n\ttoInitRequest(): RequestInit {\r\n\t\treturn {\r\n\t\t\tmethod: this.method,\r\n\t\t\theaders: this.headers.serialize(),\r\n\t\t\tbody: this.serializeBody(),\r\n\t\t\tmode: 'same-origin', // 'cors' | 'navigate' | 'no-cors' | 'same-origin',\r\n\t\t\tcredentials: 'same-origin',\r\n\t\t\tcache: 'default', // 'default' | 'force-cache' | 'no-cache' | 'no-store' | 'only-if-cached' | 'reload',\r\n\t\t\tredirect: 'error', // 'error' | 'follow' | 'manual';\r\n\t\t\t// referrer: '',\r\n\t\t\t// integrity: '',\r\n\t\t\t// keepalive: false,\r\n\t\t\t// referrerPolicy: ''; // '' | 'no-referrer' | 'no-referrer-when-downgrade' | 'origin' | 'origin-when-cross-origin' | 'same-origin' | 'strict-origin' | 'strict-origin-when-cross-origin' | 'unsafe-url',\r\n\t\t\t// signal: null,\r\n\t\t\t// window,\r\n\t\t\t// method: The request method, e.g., GET, POST. The default is GET.\r\n\t\t\t// headers: Any headers you want to add to your request, contained within a Headers object or an object literal with ByteString values.\r\n\t\t\t// body: Any body that you want to add to your request: this can be a Blob, BufferSource, FormData, URLSearchParams, USVString, or ReadableStream object. Note that a request using the GET or HEAD method cannot have a body.\r\n\t\t\t// mode: The mode you want to use for the request, e.g., cors, no-cors, same-origin, or navigate. The default is cors.\r\n\t\t\t// credentials: The request credentials you want to use for the request: omit, same-origin, or include. The default is same-origin.\r\n\t\t\t// cache: The cache mode you want to use for the request.\r\n\t\t\t// redirect: The redirect mode to use: follow, error, or manual. The default is follow.\r\n\t\t\t// referrer: A USVString specifying no-referrer, client, or a URL. The default is about:client.\r\n\t\t\t// integrity: Contains the subresource integrity value of the request (e.g., sha256-BpfBw7ivV8q2jLiT13fxDYAe2tJllusRSZ273h2nFSE=).\r\n\t\t}\r\n\t}\r\n\ttoFetchRequest__(): Request {\r\n\t\treturn new Request(this.urlWithParams, this.toInitRequest());\r\n\t\t/*\r\n\t\tRequest.cache Read only\r\n\t\tContains the cache mode of the request (e.g., default, reload, no-cache).\r\n\t\tRequest.context Read only\r\n\t\tContains the context of the request (e.g., audio, image, iframe, etc.)\r\n\t\tRequest.credentials Read only\r\n\t\tContains the credentials of the request (e.g., omit, same-origin, include). The default is same-origin.\r\n\t\tRequest.destination Read only\r\n\t\tReturns a string from the RequestDestination enum describing the request's destination. This is a string indicating the type of content being requested.\r\n\t\tRequest.headers Read only\r\n\t\tContains the associated Headers object of the request.\r\n\t\tRequest.integrity Read only\r\n\t\tContains the subresource integrity value of the request (e.g., sha256-BpfBw7ivV8q2jLiT13fxDYAe2tJllusRSZ273h2nFSE=).\r\n\t\tRequest.method Read only\r\n\t\tContains the request's method (GET, POST, etc.)\r\n\t\tRequest.mode Read only\r\n\t\tContains the mode of the request (e.g., cors, no-cors, same-origin, navigate.)\r\n\t\tRequest.redirect Read only\r\n\t\tContains the mode for how redirects are handled. It may be one of follow, error, or manual.\r\n\t\tRequest.referrer Read only\r\n\t\tContains the referrer of the request (e.g., client).\r\n\t\tRequest.referrerPolicy Read only\r\n\t\tContains the referrer policy of the request (e.g., no-referrer).\r\n\t\tRequest.url Read only\r\n\t\tContains the URL of the request.\r\n\t\tRequest implements Body, so it also inherits the following properties:\r\n\t\tbody Read only\r\n\t\tA simple getter used to expose a ReadableStream of the body contents.\r\n\t\tbodyUsed Read only\r\n\t\tStores a Boolean that declares whether the body has been used in a response yet.\r\n\t\t*/\r\n\t}\r\n\tclone<T>(options?: IHttpRequest<T>): HttpRequest<T> {\r\n\t\toptions = Object.assign({\r\n\t\t\theaders: this.headers,\r\n\t\t\treportProgress: this.reportProgress,\r\n\t\t\tparams: this.params,\r\n\t\t\tresponseType: this.responseType,\r\n\t\t\twithCredentials: this.withCredentials,\r\n\t\t\tobserve: this.observe,\r\n\t\t\tbody: this.body,\r\n\t\t\turl: this.url,\r\n\t\t\tmethod: this.method,\r\n\t\t}, options || {}) as IHttpRequestInit<T>;\r\n\t\tconst clone = new HttpRequest<T>(this.method as HttpMethodBodyType, this.url, this.body as HttpBodyType<T>, options);\r\n\t\treturn clone;\r\n\t}\r\n}\r\n\r\nfunction methodHasBody(method: string): boolean {\r\n\tswitch (method) {\r\n\t\tcase 'DELETE':\r\n\t\tcase 'GET':\r\n\t\tcase 'HEAD':\r\n\t\tcase 'OPTIONS':\r\n\t\tcase 'JSONP':\r\n\t\t\treturn false;\r\n\t\tdefault:\r\n\t\t\treturn true;\r\n\t}\r\n}\r\n\r\nfunction isArrayBuffer(value: any): value is ArrayBuffer {\r\n\treturn typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer;\r\n}\r\n\r\nfunction isBlob(value: any): value is Blob {\r\n\treturn typeof Blob !== 'undefined' && value instanceof Blob;\r\n}\r\n\r\nfunction isFormData(value: any): value is FormData {\r\n\treturn typeof FormData !== 'undefined' && value instanceof FormData;\r\n}\r\n","import { BehaviorSubject, Observable, of, throwError } from 'rxjs';\r\nimport { catchError, concatMap, filter, finalize, map } from 'rxjs/operators';\r\nimport { HttpErrorResponse, IHttpErrorResponse } from './http-error-response';\r\nimport { HttpHeaders } from './http-headers';\r\nimport { HttpInterceptingHandler } from './http-interceptor';\r\nimport { HttpParams } from './http-params';\r\nimport { HttpBodyType, HttpMethodType, HttpRequest, IHttpRequestInit } from './http-request';\r\nimport { HttpEvent, HttpResponse } from './http-response';\r\n\r\nexport default class HttpClient {\r\n\r\n\tstatic pendingRequests$: BehaviorSubject<number> = new BehaviorSubject<number>(0);\r\n\r\n\tstatic incrementPendingRequest() {\r\n\t\tHttpClient.pendingRequests$.next(HttpClient.pendingRequests$.getValue() + 1);\r\n\t}\r\n\r\n\tstatic decrementPendingRequest() {\r\n\t\tHttpClient.pendingRequests$.next(HttpClient.pendingRequests$.getValue() - 1);\r\n\t}\r\n\r\n\t// static handler: HttpHandler = new HttpFetchHandler();\r\n\tstatic handler: HttpInterceptingHandler = new HttpInterceptingHandler();\r\n\r\n\tstatic request$<T>(first: HttpMethodType | HttpRequest<T>, url?: string, options: IHttpRequestInit<T> = {}): Observable<HttpEvent<any> | HttpResponse<T> | HttpBodyType<T>> {\r\n\t\tlet request: HttpRequest<T>;\r\n\t\tif (first instanceof HttpRequest) {\r\n\t\t\trequest = first;\r\n\t\t} else {\r\n\t\t\tlet headers: HttpHeaders | undefined = undefined;\r\n\t\t\tif (options.headers instanceof HttpHeaders) {\r\n\t\t\t\theaders = options.headers;\r\n\t\t\t} else {\r\n\t\t\t\theaders = new HttpHeaders(options.headers);\r\n\t\t\t}\r\n\t\t\tlet params: HttpParams | undefined = undefined;\r\n\t\t\tif (options.params) {\r\n\t\t\t\tparams = new HttpParams(options.params);\r\n\t\t\t}\r\n\t\t\trequest = new HttpRequest(first, url!, (options.body !== undefined ? options.body : null), {\r\n\t\t\t\theaders,\r\n\t\t\t\tparams,\r\n\t\t\t\treportProgress: options.reportProgress,\r\n\t\t\t\tresponseType: options.responseType || 'json',\r\n\t\t\t\twithCredentials: options.withCredentials,\r\n\t\t\t});\r\n\t\t}\r\n\t\t// console.log('HttpClient.request$', request);\r\n\t\tHttpClient.incrementPendingRequest();\r\n\t\tconst events$: Observable<HttpEvent<any>> = of(request).pipe(\r\n\t\t\tconcatMap((request: HttpRequest<T>) => this.handler.handle(request)),\r\n\t\t\t// tap((response: HttpEvent<any>) => console.log('HttpClient.response', response)),\r\n\t\t\tfinalize(() => HttpClient.decrementPendingRequest())\r\n\t\t);\r\n\t\tif (first instanceof HttpRequest || options.observe === 'events') {\r\n\t\t\treturn events$.pipe(\r\n\t\t\t\tcatchError(error => {\r\n\t\t\t\t\tconsole.log('error', error);\r\n\t\t\t\t\treturn throwError(this.getError(error, null, request));\r\n\t\t\t\t}),\r\n\t\t\t);\r\n\t\t}\r\n\t\tconst response$: Observable<HttpResponse<T>> = <Observable<HttpResponse<T>>>events$.pipe(\r\n\t\t\tfilter((event: HttpEvent<any>) => event instanceof HttpResponse),\r\n\t\t);\r\n\t\tlet response_: HttpResponse<T>;\r\n\t\tconst observe$: Observable<HttpResponse<T> | HttpBodyType<T>> = response$.pipe(\r\n\t\t\tmap((response: HttpResponse<T>) => {\r\n\t\t\t\tresponse_ = response;\r\n\t\t\t\tswitch (options.observe || 'body') {\r\n\t\t\t\t\tcase 'body':\r\n\t\t\t\t\t\tswitch (request.responseType) {\r\n\t\t\t\t\t\t\tcase 'arraybuffer':\r\n\t\t\t\t\t\t\t\tif (response.body !== null && !(response.body instanceof ArrayBuffer)) {\r\n\t\t\t\t\t\t\t\t\tthrow new Error('Response is not an ArrayBuffer.');\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\treturn response.body;\r\n\t\t\t\t\t\t\tcase 'blob':\r\n\t\t\t\t\t\t\t\tif (response.body !== null && !(response.body instanceof Blob)) {\r\n\t\t\t\t\t\t\t\t\tthrow new Error('Response is not a Blob.');\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\treturn response.body;\r\n\t\t\t\t\t\t\tcase 'text':\r\n\t\t\t\t\t\t\t\tif (response.body !== null && typeof response.body !== 'string') {\r\n\t\t\t\t\t\t\t\t\tthrow new Error('Response is not a string.');\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\treturn response.body;\r\n\t\t\t\t\t\t\tcase 'json':\r\n\t\t\t\t\t\t\tdefault:\r\n\t\t\t\t\t\t\t\treturn response.body;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\tcase 'response':\r\n\t\t\t\t\t\treturn response;\r\n\t\t\t\t\tdefault:\r\n\t\t\t\t\t\tthrow new Error(`Unreachable: unhandled observe type ${options.observe}}`);\r\n\t\t\t\t}\r\n\t\t\t}),\r\n\t\t\tcatchError(error => {\r\n\t\t\t\tconsole.log('error', error);\r\n\t\t\t\treturn throwError(this.getError(error, response_, request));\r\n\t\t\t}),\r\n\t\t)\r\n\t\treturn observe$;\r\n\t\tswitch (options.observe || 'body') {\r\n\t\t\tcase 'body':\r\n\t\t\t\tswitch (request.responseType) {\r\n\t\t\t\t\tcase 'arraybuffer':\r\n\t\t\t\t\t\treturn response$.pipe(map((response: HttpResponse<T>) => {\r\n\t\t\t\t\t\t\tif (response.body !== null && !(response.body instanceof ArrayBuffer)) {\r\n\t\t\t\t\t\t\t\tthrow new Error('Response is not an ArrayBuffer.');\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\treturn response.body;\r\n\t\t\t\t\t\t}));\r\n\t\t\t\t\tcase 'blob':\r\n\t\t\t\t\t\treturn response$.pipe(map((response: HttpResponse<T>) => {\r\n\t\t\t\t\t\t\tif (response.body !== null && !(response.body instanceof Blob)) {\r\n\t\t\t\t\t\t\t\tthrow new Error('Response is not a Blob.');\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\treturn response.body;\r\n\t\t\t\t\t\t}));\r\n\t\t\t\t\tcase 'text':\r\n\t\t\t\t\t\treturn response$.pipe(map((response: HttpResponse<T>) => {\r\n\t\t\t\t\t\t\tif (response.body !== null && typeof response.body !== 'string') {\r\n\t\t\t\t\t\t\t\tthrow new Error('Response is not a string.');\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\treturn response.body;\r\n\t\t\t\t\t\t}));\r\n\t\t\t\t\tcase 'json':\r\n\t\t\t\t\tdefault:\r\n\t\t\t\t\t\treturn response$.pipe(map((response: HttpResponse<T>) => response.body));\r\n\t\t\t\t}\r\n\t\t\tcase 'response':\r\n\t\t\t\treturn response$;\r\n\t\t\tdefault:\r\n\t\t\t\tthrow new Error(`Unreachable: unhandled observe type ${options.observe}}`);\r\n\t\t}\r\n\t}\r\n\r\n\tstatic delete$<T>(url: string, options?: IHttpRequestInit<T>): Observable<T>;\r\n\tstatic delete$<T>(url: string, options: IHttpRequestInit<T> = {}): Observable<HttpEvent<any> | HttpResponse<T> | HttpBodyType<T>> {\r\n\t\treturn this.request$<T>('DELETE', url, options);\r\n\t}\r\n\r\n\tstatic get$<T>(url: string, options?: IHttpRequestInit<T>): Observable<T>;\r\n\tstatic get$<T>(url: string, options: IHttpRequestInit<T> = {}): Observable<HttpEvent<any> | HttpResponse<T> | HttpBodyType<T>> {\r\n\t\treturn this.request$<T>('GET', url, options);\r\n\t}\r\n\r\n\tstatic head$<T>(url: string, options?: IHttpRequestInit<T>): Observable<T>;\r\n\tstatic head$<T>(url: string, options: IHttpRequestInit<T> = {}): Observable<HttpEvent<any> | HttpResponse<T> | HttpBodyType<T>> {\r\n\t\treturn this.request$<T>('HEAD', url, options);\r\n\t}\r\n\r\n\tstatic jsonp$<T>(url: string, callbackParam: string): Observable<T>;\r\n\tstatic jsonp$<T>(url: string, callbackParam: string): Observable<HttpEvent<any> | HttpResponse<T> | HttpBodyType<T>> {\r\n\t\treturn this.request$<T>('JSONP', url, {\r\n\t\t\tparams: new HttpParams().append(callbackParam, 'JSONP_CALLBACK'),\r\n\t\t\tobserve: 'body',\r\n\t\t\tresponseType: 'json',\r\n\t\t});\r\n\t}\r\n\r\n\tstatic options$<T>(url: string, options?: IHttpRequestInit<T>): Observable<T>;\r\n\tstatic options$<T>(url: string, options: IHttpRequestInit<T> = {}): Observable<HttpEvent<any> | HttpResponse<T> | HttpBodyType<T>> {\r\n\t\treturn this.request$<T>('OPTIONS', url, options);\r\n\t}\r\n\r\n\tstatic patch$<T>(url: string, body: any | null, options?: IHttpRequestInit<T>): Observable<T>;\r\n\tstatic patch$<T>(url: string, body: any | null, options: IHttpRequestInit<T> = {}): Observable<HttpEvent<any> | HttpResponse<T> | HttpBodyType<T>> {\r\n\t\treturn this.request$<T>('PATCH', url, optionsWithBody_<T>(options, body));\r\n\t}\r\n\r\n\tstatic post$<T>(url: string, body: any | null, options?: IHttpRequestInit<T>): Observable<T>;\r\n\tstatic post$<T>(url: string, body: any | null, options: IHttpRequestInit<T> = {}): Observable<HttpEvent<any> | HttpResponse<T> | HttpBodyType<T>> {\r\n\t\treturn this.request$<T>('POST', url, optionsWithBody_<T>(options, body));\r\n\t}\r\n\r\n\tstatic put$<T>(url: string, body: any | null, options?: IHttpRequestInit<T>): Observable<T>;\r\n\tstatic put$<T>(url: string, body: any | null, options: IHttpRequestInit<T> = {}): Observable<HttpEvent<any> | HttpResponse<T> | HttpBodyType<T>> {\r\n\t\treturn this.request$<T>('PUT', url, optionsWithBody_<T>(options, body));\r\n\t}\r\n\r\n\tstatic getError<T>(error: any, response: HttpResponse<T> | null, request: HttpRequest<T> | null): HttpErrorResponse<T> {\r\n\t\tif (!error.status) {\r\n\t\t\terror.statusCode = response?.status || 0;\r\n\t\t}\r\n\t\tif (!error.statusMessage) {\r\n\t\t\terror.statusMessage = response?.statusText || 'Unknown Error';\r\n\t\t}\r\n\t\tconst options: IHttpErrorResponse<T> = {\r\n\t\t\terror,\r\n\t\t\tstatus: error.status,\r\n\t\t\tstatusText: error.statusText,\r\n\t\t\tmessage: error.message,\r\n\t\t\trequest,\r\n\t\t};\r\n\t\tif (response) {\r\n\t\t\toptions.headers = response.headers;\r\n\t\t\toptions.status = options.status || response.status;\r\n\t\t\toptions.statusText = options.statusText || response.statusText;\r\n\t\t\toptions.url = response.url;\r\n\t\t}\r\n\t\treturn new HttpErrorResponse<T>(options);\r\n\t}\r\n\r\n}\r\n\r\nfunction optionsWithBody_<T>(options: IHttpRequestInit<T>, body: T | null): IHttpRequestInit<T> {\r\n\treturn Object.assign({}, options, { body });\r\n}\r\n\r\n/*\r\n\r\nexport class HttpClient {\r\n\r\n\tconstructor(private handler: HttpHandler) { }\r\n\r\n\trequest<R>(request: HttpRequest<any>): Observable<HttpEvent<R>>;\r\n\trequest(method: string, url: string, options: {\r\n\t\tbody?: any,\r\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined,\r\n\t\tobserve?: 'body',\r\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\r\n\t\treportProgress?: boolean, responseType: 'arraybuffer',\r\n\t\twithCredentials?: boolean,\r\n\t}): Observable<ArrayBuffer>;\r\n\trequest(method: string, url: string, options: {\r\n\t\tbody?: any,\r\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined,\r\n\t\tobserve?: 'body',\r\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\r\n\t\treportProgress?: boolean, responseType: 'blob',\r\n\t\twithCredentials?: boolean,\r\n\t}): Observable<Blob>;\r\n\trequest(method: string, url: string, options: {\r\n\t\tbody?: any,\r\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined,\r\n\t\tobserve?: 'body',\r\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\r\n\t\treportProgress?: boolean, responseType: 'text',\r\n\t\twithCredentials?: boolean,\r\n\t}): Observable<string>;\r\n\trequest(method: string, url: string, options: {\r\n\t\tbody?: any,\r\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined,\r\n\t\tparams?: HttpParams | { [param: string]: string | string[] }, observe: 'events',\r\n\t\treportProgress?: boolean, responseType: 'arraybuffer',\r\n\t\twithCredentials?: boolean,\r\n\t}): Observable<HttpEvent<ArrayBuffer>>;\r\n\trequest(method: string, url: string, options: {\r\n\t\tbody?: any,\r\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined, observe: 'events',\r\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\r\n\t\treportProgress?: boolean, responseType: 'blob',\r\n\t\twithCredentials?: boolean,\r\n\t}): Observable<HttpEvent<Blob>>;\r\n\trequest(method: string, url: string, options: {\r\n\t\tbody?: any,\r\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined, observe: 'events',\r\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\r\n\t\treportProgress?: boolean, responseType: 'text',\r\n\t\twithCredentials?: boolean,\r\n\t}): Observable<HttpEvent<string>>;\r\n\trequest(method: string, url: string, options: {\r\n\t\tbody?: any,\r\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined,\r\n\t\treportProgress?: boolean, observe: 'events',\r\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\r\n\t\tresponseType?: 'json',\r\n\t\twithCredentials?: boolean,\r\n\t}): Observable<HttpEvent<any>>;\r\n\trequest<R>(method: string, url: string, options: {\r\n\t\tbody?: any,\r\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined,\r\n\t\treportProgress?: boolean, observe: 'events',\r\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\r\n\t\tresponseType?: 'json',\r\n\t\twithCredentials?: boolean,\r\n\t}): Observable<HttpEvent<R>>;\r\n\trequest(method: string, url: string, options: {\r\n\t\tbody?: any,\r\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined, observe: 'response',\r\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\r\n\t\treportProgress?: boolean, responseType: 'arraybuffer',\r\n\t\twithCredentials?: boolean,\r\n\t}): Observable<HttpResponse<ArrayBuffer>>;\r\n\trequest(method: string, url: string, options: {\r\n\t\tbody?: any,\r\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined, observe: 'response',\r\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\r\n\t\treportProgress?: boolean, responseType: 'blob',\r\n\t\twithCredentials?: boolean,\r\n\t}): Observable<HttpResponse<Blob>>;\r\n\trequest(method: string, url: string, options: {\r\n\t\tbody?: any,\r\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined, observe: 'response',\r\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\r\n\t\treportProgress?: boolean, responseType: 'text',\r\n\t\twithCredentials?: boolean,\r\n\t}): Observable<HttpResponse<string>>;\r\n\trequest(method: string, url: string, options: {\r\n\t\tbody?: any,\r\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined,\r\n\t\treportProgress?: boolean, observe: 'response',\r\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\r\n\t\tresponseType?: 'json',\r\n\t\twithCredentials?: boolean,\r\n\t}): Observable<HttpResponse<Object>>;\r\n\trequest<R>(method: string, url: string, options: {\r\n\t\tbody?: any,\r\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined,\r\n\t\treportProgress?: boolean, observe: 'response',\r\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\r\n\t\tresponseType?: 'json',\r\n\t\twithCredentials?: boolean,\r\n\t}): Observable<HttpResponse<R>>;\r\n\trequest(method: string, url: string, options?: {\r\n\t\tbody?: any,\r\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined,\r\n\t\tobserve?: 'body',\r\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\r\n\t\tresponseType?: 'json',\r\n\t\treportProgress?: boolean,\r\n\t\twithCredentials?: boolean,\r\n\t}): Observable<Object>;\r\n\trequest<R>(method: string, url: string, options?: {\r\n\t\tbody?: any,\r\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined,\r\n\t\tobserve?: 'body',\r\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\r\n\t\tresponseType?: 'json',\r\n\t\treportProgress?: boolean,\r\n\t\twithCredentials?: boolean,\r\n\t}): Observable<R>;\r\n\trequest(method: string, url: string, options?: {\r\n\t\tbody?: any,\r\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined,\r\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\r\n\t\tobserve?: HttpObserve,\r\n\t\treportProgress?: boolean,\r\n\t\tresponseType?: 'arraybuffer' | 'blob' | 'json' | 'text',\r\n\t\twithCredentials?: boolean,\r\n\t}): Observable<any>;\r\n\trequest(first: string | HttpRequest<any>, url?: string, options: {\r\n\t\tbody?: any,\r\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined,\r\n\t\tobserve?: HttpObserveType,\r\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\r\n\t\treportProgress?: boolean,\r\n\t\tresponseType?: 'arraybuffer' | 'blob' | 'json' | 'text',\r\n\t\twithCredentials?: boolean,\r\n\t} = {}): Observable<any> {\r\n\t\tlet request: HttpRequest<any>;\r\n\t\tif (first instanceof HttpRequest) {\r\n\t\t\trequest = first;\r\n\t\t} else {\r\n\t\t\tlet headers: HttpHeaders | undefined = undefined;\r\n\t\t\tif (options.headers instanceof HttpHeaders) {\r\n\t\t\t\theaders = options.headers;\r\n\t\t\t} else {\r\n\t\t\t\theaders = new HttpHeaders(options.headers);\r\n\t\t\t}\r\n\t\t\tlet params: HttpParams | undefined = undefined;\r\n\t\t\tif (!!options.params) {\r\n\t\t\t\tif (options.params instanceof HttpParams) {\r\n\t\t\t\t\tparams = options.params;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tparams = new HttpParams({ fromObject: options.params } as HttpParamsOptions);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\trequest = new HttpRequest(first, url!, (options.body !== undefined ? options.body : null), {\r\n\t\t\t\theaders,\r\n\t\t\t\tparams,\r\n\t\t\t\treportProgress: options.reportProgress,\r\n\t\t\t\tresponseType: options.responseType || 'json',\r\n\t\t\t\twithCredentials: options.withCredentials,\r\n\t\t\t});\r\n\t\t}\r\n\t\tconst events$: Observable<HttpEvent<any>> = of(request).pipe(concatMap((request: HttpRequest<any>) => this.handler.handle(request)));\r\n\t\tif (first instanceof HttpRequest || options.observe === 'events') {\r\n\t\t\treturn events$;\r\n\t\t}\r\n\t\tconst response$: Observable<HttpResponse<any>> = <Observable<HttpResponse<any>>>events$.pipe(\r\n\t\t\tfilter((event: HttpEvent<any>) => event instanceof HttpResponse),\r\n\t\t);\r\n\t\tswitch (options.observe || 'body') {\r\n\t\t\tcase 'body':\r\n\t\t\t\tswitch (request.responseType) {\r\n\t\t\t\t\tcase 'arraybuffer':\r\n\t\t\t\t\t\treturn response$.pipe(map((res: HttpResponse<any>) => {\r\n\t\t\t\t\t\t\tif (res.body !== null && !(res.body instanceof ArrayBuffer)) {\r\n\t\t\t\t\t\t\t\tthrow new Error('Response is not an ArrayBuffer.');\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\treturn res.body;\r\n\t\t\t\t\t\t}));\r\n\t\t\t\t\tcase 'blob':\r\n\t\t\t\t\t\treturn response$.pipe(map((res: HttpResponse<any>) => {\r\n\t\t\t\t\t\t\tif (res.body !== null && !(res.body instanceof Blob)) {\r\n\t\t\t\t\t\t\t\tthrow new Error('Response is not a Blob.');\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\treturn res.body;\r\n\t\t\t\t\t\t}));\r\n\t\t\t\t\tcase 'text':\r\n\t\t\t\t\t\treturn response$.pipe(map((res: HttpResponse<any>) => {\r\n\t\t\t\t\t\t\tif (res.body !== null && typeof res.body !== 'string') {\r\n\t\t\t\t\t\t\t\tthrow new Error('Response is not a string.');\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\treturn res.body;\r\n\t\t\t\t\t\t}));\r\n\t\t\t\t\tcase 'json':\r\n\t\t\t\t\tdefault:\r\n\t\t\t\t\t\treturn response$.pipe(map((res: HttpResponse<any>) => res.body));\r\n\t\t\t\t}\r\n\t\t\tcase 'response':\r\n\t\t\t\treturn response$;\r\n\t\t\tdefault:\r\n\t\t\t\tthrow new Error(`Unreachable: unhandled observe type ${options.observe}}`);\r\n\t\t}\r\n\t}\r\n\r\n\tdelete(url: string, options: {\r\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined,\r\n\t\tobserve?: 'body',\r\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\r\n\t\treportProgress?: boolean, responseType: 'arraybuffer',\r\n\t\twithCredentials?: boolean,\r\n\t}): Observable<ArrayBuffer>;\r\n\tdelete(url: string, options: {\r\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined,\r\n\t\tobserve?: 'body',\r\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\r\n\t\treportProgress?: boolean, responseType: 'blob',\r\n\t\twithCredentials?: boolean,\r\n\t}): Observable<Blob>;\r\n\tdelete(url: string, options: {\r\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined,\r\n\t\tobserve?: 'body',\r\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\r\n\t\treportProgress?: boolean, responseType: 'text',\r\n\t\twithCredentials?: boolean,\r\n\t}): Observable<string>;\r\n\r\n\r\n\tdelete(url: string, options: {\r\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined, observe: 'events',\r\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\r\n\t\treportProgress?: boolean, responseType: 'arraybuffer',\r\n\t\twithCredentials?: boolean,\r\n\t}): Observable<HttpEvent<ArrayBuffer>>;\r\n\r\n\r\n\tdelete(url: string, options: {\r\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined, observe: 'events',\r\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\r\n\t\treportProgress?: boolean, responseType: 'blob',\r\n\t\twithCredentials?: boolean,\r\n\t}): Observable<HttpEvent<Blob>>;\r\n\r\n\tdelete(url: string, options: {\r\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined, observe: 'events',\r\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\r\n\t\treportProgress?: boolean, responseType: 'text',\r\n\t\twithCredentials?: boolean,\r\n\t}): Observable<HttpEvent<string>>;\r\n\r\n\tdelete(url: string, options: {\r\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined, observe: 'events',\r\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\r\n\t\treportProgress?: boolean,\r\n\t\tresponseType?: 'json',\r\n\t\twithCredentials?: boolean,\r\n\t}): Observable<HttpEvent<Object>>;\r\n\r\n\r\n\tdelete<T>(url: string, options: {\r\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined, observe: 'events',\r\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\r\n\t\treportProgress?: boolean,\r\n\t\tresponseType?: 'json',\r\n\t\twithCredentials?: boolean,\r\n\t}): Observable<HttpEvent<T>>;\r\n\r\n\r\n\tdelete(url: string, options: {\r\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined, observe: 'response',\r\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\r\n\t\treportProgress?: boolean, responseType: 'arraybuffer',\r\n\t\twithCredentials?: boolean,\r\n\t}): Observable<HttpResponse<ArrayBuffer>>;\r\n\r\n\r\n\tdelete(url: string, options: {\r\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined, observe: 'response',\r\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\r\n\t\treportProgress?: boolean, responseType: 'blob',\r\n\t\twithCredentials?: boolean,\r\n\t}): Observable<HttpResponse<Blob>>;\r\n\r\n\r\n\tdelete(url: string, options: {\r\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined, observe: 'response',\r\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\r\n\t\treportProgress?: boolean, responseType: 'text',\r\n\t\twithCredentials?: boolean,\r\n\t}): Observable<HttpResponse<string>>;\r\n\r\n\r\n\tdelete(url: string, options: {\r\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined, observe: 'response',\r\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\r\n\t\treportProgress?: boolean,\r\n\t\tresponseType?: 'json',\r\n\t\twithCredentials?: boolean,\r\n\t}): Observable<HttpResponse<Object>>;\r\n\r\n\r\n\tdelete<T>(url: string, options: {\r\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined, observe: 'response',\r\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\r\n\t\treportProgress?: boolean,\r\n\t\tresponseType?: 'json',\r\n\t\twithCredentials?: boolean,\r\n\t}): Observable<HttpResponse<T>>;\r\n\r\n\r\n\tdelete(url: string, options?: {\r\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined,\r\n\t\tobserve?: 'body',\r\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\r\n\t\treportProgress?: boolean,\r\n\t\tresponseType?: 'json',\r\n\t\twithCredentials?: boolean,\r\n\t}): Observable<Object>;\r\n\r\n\r\n\tdelete<T>(url: string, options?: {\r\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined,\r\n\t\tobserve?: 'body',\r\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\r\n\t\treportProgress?: boolean,\r\n\t\tresponseType?: 'json',\r\n\t\twithCredentials?: boolean,\r\n\t}): Observable<T>;\r\n\r\n\r\n\tdelete(url: string, options: {\r\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined,\r\n\t\tobserve?: HttpObserveType,\r\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\r\n\t\treportProgress?: boolean,\r\n\t\tresponseType?: 'arraybuffer' | 'blob' | 'json' | 'text',\r\n\t\twithCredentials?: boolean,\r\n\t} = {}): Observable<any> {\r\n\t\treturn this.request<any>('DELETE', url, options as any);\r\n\t}\r\n\r\n\r\n\r\n\tget(url: string, options: {\r\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined,\r\n\t\tobserve?: 'body',\r\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\r\n\t\treportProgress?: boolean, responseType: 'arraybuffer',\r\n\t\twithCredentials?: boolean,\r\n\t}): Observable<ArrayBuffer>;\r\n\r\n\r\n\tget(url: string, options: {\r\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined,\r\n\t\tobserve?: 'body',\r\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\r\n\t\treportProgress?: boolean, responseType: 'blob',\r\n\t\twithCredentials?: boolean,\r\n\t}): Observable<Blob>;\r\n\r\n\r\n\tget(url: string, options: {\r\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined,\r\n\t\tobserve?: 'body',\r\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\r\n\t\treportProgress?: boolean, responseType: 'text',\r\n\t\twithCredentials?: boolean,\r\n\t}): Observable<string>;\r\n\r\n\r\n\tget(url: string, options: {\r\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined, observe: 'events',\r\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\r\n\t\treportProgress?: boolean, responseType: 'arraybuffer',\r\n\t\twithCredentials?: boolean,\r\n\t}): Observable<HttpEvent<ArrayBuffer>>;\r\n\r\n\r\n\tget(url: string, options: {\r\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined, observe: 'events',\r\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\r\n\t\treportProgress?: boolean, responseType: 'blob',\r\n\t\twithCredentials?: boolean,\r\n\t}): Observable<HttpEvent<Blob>>;\r\n\r\n\r\n\tget(url: string, options: {\r\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined, observe: 'events',\r\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\r\n\t\treportProgress?: boolean, responseType: 'text',\r\n\t\twithCredentials?: boolean,\r\n\t}): Observable<HttpEvent<string>>;\r\n\r\n\r\n\tget(url: string, options: {\r\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined, observe: 'events',\r\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\r\n\t\treportProgress?: boolean,\r\n\t\tresponseType?: 'json',\r\n\t\twithCredentials?: boolean,\r\n\t}): Observable<HttpEvent<Object>>;\r\n\r\n\r\n\tget<T>(url: string, options: {\r\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined, observe: 'events',\r\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\r\n\t\treportProgress?: boolean,\r\n\t\tresponseType?: 'json',\r\n\t\twithCredentials?: boolean,\r\n\t}): Observable<HttpEvent<T>>;\r\n\r\n\r\n\tget(url: string, options: {\r\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined, observe: 'response',\r\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\r\n\t\treportProgress?: boolean, responseType: 'arraybuffer',\r\n\t\twithCredentials?: boolean,\r\n\t}): Observable<HttpResponse<ArrayBuffer>>;\r\n\r\n\r\n\tget(url: string, options: {\r\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined, observe: 'response',\r\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\r\n\t\treportProgress?: boolean, responseType: 'blob',\r\n\t\twithCredentials?: boolean,\r\n\t}): Observable<HttpResponse<Blob>>;\r\n\r\n\r\n\tget(url: string, options: {\r\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined, observe: 'response',\r\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\r\n\t\treportProgress?: boolean, responseType: 'text',\r\n\t\twithCredentials?: boolean,\r\n\t}): Observable<HttpResponse<string>>;\r\n\r\n\r\n\tget(url: string, options: {\r\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined, observe: 'response',\r\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\r\n\t\treportProgress?: boolean,\r\n\t\tresponseType?: 'json',\r\n\t\twithCredentials?: boolean,\r\n\t}): Observable<HttpResponse<Object>>;\r\n\r\n\r\n\tget<T>(url: string, options: {\r\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined, observe: 'response',\r\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\r\n\t\treportProgress?: boolean,\r\n\t\tresponseType?: 'json',\r\n\t\twithCredentials?: boolean,\r\n\t}): Observable<HttpResponse<T>>;\r\n\r\n\r\n\tget(url: string, options?: {\r\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined,\r\n\t\tobserve?: 'body',\r\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\r\n\t\treportProgress?: boolean,\r\n\t\tresponseType?: 'json',\r\n\t\twithCredentials?: boolean,\r\n\t}): Observable<Object>;\r\n\r\n\r\n\tget<T>(url: string, options?: {\r\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined,\r\n\t\tobserve?: 'body',\r\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\r\n\t\treportProgress?: boolean,\r\n\t\tresponseType?: 'json',\r\n\t\twithCredentials?: boolean,\r\n\t}): Observable<T>;\r\n\r\n\r\n\tget(url: string, options: {\r\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined,\r\n\t\tobserve?: HttpObserveType,\r\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\r\n\t\treportProgress?: boolean,\r\n\t\tresponseType?: 'arraybuffer' | 'blob' | 'json' | 'text',\r\n\t\twithCredentials?: boolean,\r\n\t} = {}): Observable<any> {\r\n\t\treturn this.request<any>('GET', url, options as any);\r\n\t}\r\n\r\n\r\n\r\n\thead(url: string, options: {\r\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined,\r\n\t\tobserve?: 'body',\r\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\r\n\t\treportProgress?: boolean, responseType: 'arraybuffer',\r\n\t\twithCredentials?: boolean,\r\n\t}): Observable<ArrayBuffer>;\r\n\r\n\r\n\r\n\thead(url: string, options: {\r\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined,\r\n\t\tobserve?: 'body',\r\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\r\n\t\treportProgress?: boolean, responseType: 'blob',\r\n\t\twithCredentials?: boolean,\r\n\t}): Observable<Blob>;\r\n\r\n\r\n\thead(url: string, options: {\r\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined,\r\n\t\tobserve?: 'body',\r\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\r\n\t\treportProgress?: boolean, responseType: 'text',\r\n\t\twithCredentials?: boolean,\r\n\t}): Observable<string>;\r\n\r\n\r\n\thead(url: string, options: {\r\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined, observe: 'events',\r\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\r\n\t\treportProgress?: boolean, responseType: 'arraybuffer',\r\n\t\twithCredentials?: boolean,\r\n\t}): Observable<HttpEvent<ArrayBuffer>>;\r\n\r\n\r\n\thead(url: string, options: {\r\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined, observe: 'events',\r\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\r\n\t\treportProgress?: boolean, responseType: 'blob',\r\n\t\twithCredentials?: boolean,\r\n\t}): Observable<HttpEvent<Blob>>;\r\n\r\n\r\n\thead(url: string, options: {\r\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined, observe: 'events',\r\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\r\n\t\treportProgress?: boolean, responseType: 'text',\r\n\t\twithCredentials?: boolean,\r\n\t}): Observable<HttpEvent<string>>;\r\n\r\n\r\n\thead(url: string, options: {\r\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined, observe: 'events',\r\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\r\n\t\treportProgress?: boolean,\r\n\t\tresponseType?: 'json',\r\n\t\twithCredentials?: boolean,\r\n\t}): Observable<HttpEvent<Object>>;\r\n\r\n\r\n\thead<T>(url: string, options: {\r\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined, observe: 'events',\r\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\r\n\t\treportProgress?: boolean,\r\n\t\tresponseType?: 'json',\r\n\t\twithCredentials?: boolean,\r\n\t}): Observable<HttpEvent<T>>;\r\n\r\n\r\n\thead(url: string, options: {\r\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined, observe: 'response',\r\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\r\n\t\treportProgress?: boolean, responseType: 'arraybuffer',\r\n\t\twithCredentials?: boolean,\r\n\t}): Observable<HttpResponse<ArrayBuffer>>;\r\n\r\n\r\n\thead(url: string, options: {\r\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined, observe: 'response',\r\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\r\n\t\treportProgress?: boolean, responseType: 'blob',\r\n\t\twithCredentials?: boolean,\r\n\t}): Observable<HttpResponse<Blob>>;\r\n\r\n\r\n\thead(url: string, options: {\r\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined, observe: 'response',\r\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\r\n\t\treportProgress?: boolean, responseType: 'text',\r\n\t\twithCredentials?: boolean,\r\n\t}): Observable<HttpResponse<string>>;\r\n\r\n\r\n\thead(url: string, options: {\r\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined, observe: 'response',\r\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\r\n\t\treportProgress?: boolean,\r\n\t\tresponseType?: 'json',\r\n\t\twithCredentials?: boolean,\r\n\t}): Observable<HttpResponse<Object>>;\r\n\r\n\r\n\thead<T>(url: string, options: {\r\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined, observe: 'response',\r\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\r\n\t\treportProgress?: boolean,\r\n\t\tresponseType?: 'json',\r\n\t\twithCredentials?: boolean,\r\n\t}): Observable<HttpResponse<T>>;\r\n\r\n\r\n\thead(url: string, options?: {\r\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined,\r\n\t\tobserve?: 'body',\r\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\r\n\t\treportProgress?: boolean,\r\n\t\tresponseType?: 'json',\r\n\t\twithCredentials?: boolean,\r\n\t}): Observable<Object>;\r\n\r\n\r\n\thead<T>(url: string, options?: {\r\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined,\r\n\t\tobserve?: 'body',\r\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\r\n\t\treportProgress?: boolean,\r\n\t\tresponseType?: 'json',\r\n\t\twithCredentials?: boolean,\r\n\t}): Observable<T>;\r\n\r\n\r\n\thead(url: string, options: {\r\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined,\r\n\t\tobserve?: HttpObserveType,\r\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\r\n\t\treportProgress?: boolean,\r\n\t\tresponseType?: 'arraybuffer' | 'blob' | 'json' | 'text',\r\n\t\twithCredentials?: boolean,\r\n\t} = {}): Observable<any> {\r\n\t\treturn this.request<any>('HEAD', url, options as any);\r\n\t}\r\n\r\n\r\n\tjsonp(url: string, callbackParam: string): Observable<Object>;\r\n\r\n\r\n\tjsonp<T>(url: string, callbackParam: string): Observable<T>;\r\n\r\n\r\n\tjsonp<T>(url: string, callbackParam: string): Observable<T> {\r\n\t\treturn this.request<any>('JSONP', url, {\r\n\t\t\tparams: new HttpParams().append(callbackParam, 'JSONP_CALLBACK'),\r\n\t\t\tobserve: 'body',\r\n\t\t\tresponseType: 'json',\r\n\t\t});\r\n\t}\r\n\r\n\r\n\toptions(url: string, options: {\r\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined,\r\n\t\tobserve?: 'body',\r\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\r\n\t\treportProgress?: boolean, responseType: 'arraybuffer',\r\n\t\twithCredentials?: boolean,\r\n\t}): Observable<ArrayBuffer>;\r\n\r\n\r\n\toptions(url: string, options: {\r\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined,\r\n\t\tobserve?: 'body',\r\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\r\n\t\treportProgress?: boolean, responseType: 'blob',\r\n\t\twithCredentials?: boolean,\r\n\t}): Observable<Blob>;\r\n\r\n\r\n\toptions(url: string, options: {\r\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined,\r\n\t\tobserve?: 'body',\r\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\r\n\t\treportProgress?: boolean, responseType: 'text',\r\n\t\twithCredentials?: boolean,\r\n\t}): Observable<string>;\r\n\r\n\r\n\toptions(url: string, options: {\r\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined, observe: 'events',\r\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\r\n\t\treportProgress?: boolean, responseType: 'arraybuffer',\r\n\t\twithCredentials?: boolean,\r\n\t}): Observable<HttpEvent<ArrayBuffer>>;\r\n\r\n\r\n\toptions(url: string, options: {\r\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined, observe: 'events',\r\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\r\n\t\treportProgress?: boolean, responseType: 'blob',\r\n\t\twithCredentials?: boolean,\r\n\t}): Observable<HttpEvent<Blob>>;\r\n\r\n\r\n\toptions(url: string, options: {\r\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined, observe: 'events',\r\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\r\n\t\treportProgress?: boolean, responseType: 'text',\r\n\t\twithCredentials?: boolean,\r\n\t}): Observable<HttpEvent<string>>;\r\n\r\n\r\n\toptions(url: string, options: {\r\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined, observe: 'events',\r\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\r\n\t\treportProgress?: boolean,\r\n\t\tresponseType?: 'json',\r\n\t\twithCredentials?: boolean,\r\n\t}): Observable<HttpEvent<Object>>;\r\n\r\n\r\n\toptions<T>(url: string, options: {\r\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined, observe: 'events',\r\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\r\n\t\treportProgress?: boolean,\r\n\t\tresponseType?: 'json',\r\n\t\twithCredentials?: boolean,\r\n\t}): Observable<HttpEvent<T>>;\r\n\r\n\r\n\toptions(url: string, options: {\r\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined, observe: 'response',\r\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\r\n\t\treportProgress?: boolean, responseType: 'arraybuffer',\r\n\t\twithCredentials?: boolean,\r\n\t}): Observable<HttpResponse<ArrayBuffer>>;\r\n\r\n\r\n\toptions(url: string, options: {\r\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined, observe: 'response',\r\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\r\n\t\treportProgress?: boolean, responseType: 'blob',\r\n\t\twithCredentials?: boolean,\r\n\t}): Observable<HttpResponse<Blob>>;\r\n\r\n\r\n\toptions(url: string, options: {\r\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined, observe: 'response',\r\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\r\n\t\treportProgress?: boolean, responseType: 'text',\r\n\t\twithCredentials?: boolean,\r\n\t}): Observable<HttpResponse<string>>;\r\n\r\n\r\n\toptions(url: string, options: {\r\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined, observe: 'response',\r\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\r\n\t\treportProgress?: boolean,\r\n\t\tresponseType?: 'json',\r\n\t\twithCredentials?: boolean,\r\n\t}): Observable<HttpResponse<Object>>;\r\n\r\n\r\n\toptions<T>(url: string, options: {\r\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined, observe: 'response',\r\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\r\n\t\treportProgress?: boolean,\r\n\t\tresponseType?: 'json',\r\n\t\twithCredentials?: boolean,\r\n\t}): Observable<HttpResponse<T>>;\r\n\r\n\r\n\toptions(url: string, options?: {\r\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined,\r\n\t\tobserve?: 'body',\r\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\r\n\t\treportProgress?: boolean,\r\n\t\tresponseType?: 'json',\r\n\t\twithCredentials?: boolean,\r\n\t}): Observable<Object>;\r\n\r\n\r\n\toptions<T>(url: string, options?: {\r\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined,\r\n\t\tobserve?: 'body',\r\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\r\n\t\treportProgress?: boolean,\r\n\t\tresponseType?: 'json',\r\n\t\twithCredentials?: boolean,\r\n\t}): Observable<T>;\r\n\r\n\r\n\toptions(url: string, options: {\r\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined,\r\n\t\tobserve?: HttpObserveType,\r\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\r\n\t\treportProgress?: boolean,\r\n\t\tresponseType?: 'arraybuffer' | 'blob' | 'json' | 'text',\r\n\t\twithCredentials?: boolean,\r\n\t} = {}): Observable<any> {\r\n\t\treturn this.request<any>('OPTIONS', url, options as any);\r\n\t}\r\n\r\n\r\n\tpatch$(url: string, body: any | null, options: {\r\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined,\r\n\t\tobserve?: 'body',\r\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\r\n\t\treportProgress?: boolean, responseType: 'arraybuffer',\r\n\t\twithCredentials?: boolean,\r\n\t}): Observable<ArrayBuffer>;\r\n\r\n\r\n\tpatch$(url: string, body: any | null, options: {\r\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined,\r\n\t\tobserve?: 'body',\r\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\r\n\t\treportProgress?: boolean, responseType: 'blob',\r\n\t\twithCredentials?: boolean,\r\n\t}): Observable<Blob>;\r\n\r\n\r\n\tpatch$(url: string, body: any | null, options: {\r\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined,\r\n\t\tobserve?: 'body',\r\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\r\n\t\treportProgress?: boolean, responseType: 'text',\r\n\t\twithCredentials?: boolean,\r\n\t}): Observable<string>;\r\n\r\n\r\n\r\n\tpatch$(url: string, body: any | null, options: {\r\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined, observe: 'events',\r\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\r\n\t\treportProgress?: boolean, responseType: 'arraybuffer',\r\n\t\twithCredentials?: boolean,\r\n\t}): Observable<HttpEvent<ArrayBuffer>>;\r\n\r\n\r\n\tpatch$(url: string, body: any | null, options: {\r\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined, observe: 'events',\r\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\r\n\t\treportProgress?: boolean, responseType: 'blob',\r\n\t\twithCredentials?: boolean,\r\n\t}): Observable<HttpEvent<Blob>>;\r\n\r\n\r\n\tpatch$(url: string, body: any | null, options: {\r\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined, observe: 'events',\r\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\r\n\t\treportProgress?: boolean, responseType: 'text',\r\n\t\twithCredentials?: boolean,\r\n\t}): Observable<HttpEvent<string>>;\r\n\r\n\r\n\tpatch$(url: string, body: any | null, options: {\r\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined, observe: 'events',\r\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\r\n\t\treportProgress?: boolean,\r\n\t\tresponseType?: 'json',\r\n\t\twithCredentials?: boolean,\r\n\t}): Observable<HttpEvent<Object>>;\r\n\r\n\r\n\tpatch<T>(url: string, body: any | null, options: {\r\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined, observe: 'events',\r\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\r\n\t\treportProgress?: boolean,\r\n\t\tresponseType?: 'json',\r\n\t\twithCredentials?: boolean,\r\n\t}): Observable<HttpEvent<T>>;\r\n\r\n\r\n\tpatch$(url: string, body: any | null, options: {\r\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined, observe: 'response',\r\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\r\n\t\treportProgress?: boolean, responseType: 'arraybuffer',\r\n\t\twithCredentials?: boolean,\r\n\t}): Observable<HttpResponse<ArrayBuffer>>;\r\n\r\n\r\n\tpatch$(url: string, body: any | null, options: {\r\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined, observe: 'response',\r\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\r\n\t\treportProgress?: boolean, responseType: 'blob',\r\n\t\twithCredentials?: boolean,\r\n\t}): Observable<HttpResponse<Blob>>;\r\n\r\n\r\n\tpatch$(url: string, body: any | null, options: {\r\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined, observe: 'response',\r\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\r\n\t\treportProgress?: boolean, responseType: 'text',\r\n\t\twithCredentials?: boolean,\r\n\t}): Observable<HttpResponse<string>>;\r\n\r\n\r\n\tpatch$(url: string, body: any | null, options: {\r\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined, observe: 'response',\r\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\r\n\t\treportProgress?: boolean,\r\n\t\tresponseType?: 'json',\r\n\t\twithCredentials?: boolean,\r\n\t}): Observable<HttpResponse<Object>>;\r\n\r\n\r\n\tpatch<T>(url: string, body: any | null, options: {\r\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined, observe: 'response',\r\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\r\n\t\treportProgress?: boolean,\r\n\t\tresponseType?: 'json',\r\n\t\twithCredentials?: boolean,\r\n\t}): Observable<HttpResponse<T>>;\r\n\r\n\r\n\tpatch$(url: string, body: any | null, options?: {\r\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined,\r\n\t\tobserve?: 'body',\r\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\r\n\t\treportProgress?: boolean,\r\n\t\tresponseType?: 'json',\r\n\t\twithCredentials?: boolean,\r\n\t}): Observable<Object>;\r\n\r\n\r\n\tpatch<T>(url: string, body: any | null, options?: {\r\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined,\r\n\t\tobserve?: 'body',\r\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\r\n\t\treportProgress?: boolean,\r\n\t\tresponseType?: 'json',\r\n\t\twithCredentials?: boolean,\r\n\t}): Observable<T>;\r\n\r\n\r\n\tpatch$(url: string, body: any | null, options: {\r\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined,\r\n\t\tobserve?: HttpObserveType,\r\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\r\n\t\treportProgress?: boolean,\r\n\t\tresponseType?: 'arraybuffer' | 'blob' | 'json' | 'text',\r\n\t\twithCredentials?: boolean,\r\n\t} = {}): Observable<any> {\r\n\t\treturn this.request<any>('PATCH', url, optionsWithBody_<T>(options, body));\r\n\t}\r\n\r\n\r\n\tpost$(url: string, body: any | null, options: {\r\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined,\r\n\t\tobserve?: 'body',\r\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\r\n\t\treportProgress?: boolean, responseType: 'arraybuffer',\r\n\t\twithCredentials?: boolean,\r\n\t}): Observable<ArrayBuffer>;\r\n\r\n\r\n\tpost$(url: string, body: any | null, options: {\r\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined,\r\n\t\tobserve?: 'body',\r\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\r\n\t\treportProgress?: boolean, responseType: 'blob',\r\n\t\twithCredentials?: boolean,\r\n\t}): Observable<Blob>;\r\n\r\n\r\n\tpost$(url: string, body: any | null, options: {\r\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined,\r\n\t\tobserve?: 'body',\r\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\r\n\t\treportProgress?: boolean, responseType: 'text',\r\n\t\twithCredentials?: boolean,\r\n\t}): Observable<string>;\r\n\r\n\r\n\tpost$(url: string, body: any | null, options: {\r\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined, observe: 'events',\r\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\r\n\t\treportProgress?: boolean, responseType: 'arraybuffer',\r\n\t\twithCredentials?: boolean,\r\n\t}): Observable<HttpEvent<ArrayBuffer>>;\r\n\r\n\r\n\tpost$(url: string, body: any | null, options: {\r\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined, observe: 'events',\r\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\r\n\t\treportProgress?: boolean, responseType: 'blob',\r\n\t\twithCredentials?: boolean,\r\n\t}): Observable<HttpEvent<Blob>>;\r\n\r\n\r\n\tpost$(url: string, body: any | null, options: {\r\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined, observe: 'events',\r\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\r\n\t\treportProgress?: boolean, responseType: 'text',\r\n\t\twithCredentials?: boolean,\r\n\t}): Observable<HttpEvent<string>>;\r\n\r\n\r\n\tpost$(url: string, body: any | null, options: {\r\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined, observe: 'events',\r\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\r\n\t\treportProgress?: boolean,\r\n\t\tresponseType?: 'json',\r\n\t\twithCredentials?: boolean,\r\n\t}): Observable<HttpEvent<Object>>;\r\n\r\n\r\n\tpost<T>(url: string, body: any | null, options: {\r\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined, observe: 'events',\r\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\r\n\t\treportProgress?: boolean,\r\n\t\tresponseType?: 'json',\r\n\t\twithCredentials?: boolean,\r\n\t}): Observable<HttpEvent<T>>;\r\n\r\n\r\n\tpost$(url: string, body: any | null, options: {\r\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined, observe: 'response',\r\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\r\n\t\treportProgress?: boolean, responseType: 'arraybuffer',\r\n\t\twithCredentials?: boolean,\r\n\t}): Observable<HttpResponse<ArrayBuffer>>;\r\n\r\n\r\n\tpost$(url: string, body: any | null, options: {\r\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined, observe: 'response',\r\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\r\n\t\treportProgress?: boolean, responseType: 'blob',\r\n\t\twithCredentials?: boolean,\r\n\t}): Observable<HttpResponse<Blob>>;\r\n\r\n\r\n\tpost$(url: string, body: any | null, options: {\r\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined, observe: 'response',\r\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\r\n\t\treportProgress?: boolean, responseType: 'text',\r\n\t\twithCredentials?: boolean,\r\n\t}): Observable<HttpResponse<string>>;\r\n\r\n\r\n\tpost$(url: string, body: any | null, options: {\r\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined, observe: 'response',\r\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\r\n\t\treportProgress?: boolean,\r\n\t\tresponseType?: 'json',\r\n\t\twithCredentials?: boolean,\r\n\t}): Observable<HttpResponse<Object>>;\r\n\r\n\r\n\tpost<T>(url: string, body: any | null, options: {\r\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined, observe: 'response',\r\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\r\n\t\treportProgress?: boolean,\r\n\t\tresponseType?: 'json',\r\n\t\twithCredentials?: boolean,\r\n\t}): Observable<HttpResponse<T>>;\r\n\r\n\r\n\tpost$(url: string, body: any | null, options?: {\r\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined,\r\n\t\tobserve?: 'body',\r\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\r\n\t\treportProgress?: boolean,\r\n\t\tresponseType?: 'json',\r\n\t\twithCredentials?: boolean,\r\n\t}): Observable<Object>;\r\n\r\n\r\n\tpost<T>(url: string, body: any | null, options?: {\r\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined,\r\n\t\tobserve?: 'body',\r\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\r\n\t\treportProgress?: boolean,\r\n\t\tresponseType?: 'json',\r\n\t\twithCredentials?: boolean,\r\n\t}): Observable<T>;\r\n\r\n\r\n\tpost$(url: string, body: any | null, options: {\r\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined,\r\n\t\tobserve?: HttpObserveType,\r\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\r\n\t\treportProgress?: boolean,\r\n\t\tresponseType?: 'arraybuffer' | 'blob' | 'json' | 'text',\r\n\t\twithCredentials?: boolean,\r\n\t} = {}): Observable<any> {\r\n\t\treturn this.request<any>('POST', url, optionsWithBody_<T>(options, body));\r\n\t}\r\n\r\n\r\n\tput(url: string, body: any | null, options: {\r\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined,\r\n\t\tobserve?: 'body',\r\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\r\n\t\treportProgress?: boolean, responseType: 'arraybuffer',\r\n\t\twithCredentials?: boolean,\r\n\t}): Observable<ArrayBuffer>;\r\n\r\n\r\n\tput(url: string, body: any | null, options: {\r\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined,\r\n\t\tobserve?: 'body',\r\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\r\n\t\treportProgress?: boolean, responseType: 'blob',\r\n\t\twithCredentials?: boolean,\r\n\t}): Observable<Blob>;\r\n\r\n\r\n\tput(url: string, body: any | null, options: {\r\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined,\r\n\t\tobserve?: 'body',\r\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\r\n\t\treportProgress?: boolean, responseType: 'text',\r\n\t\twithCredentials?: boolean,\r\n\t}): Observable<string>;\r\n\r\n\r\n\tput(url: string, body: any | null, options: {\r\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined, observe: 'events',\r\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\r\n\t\treportProgress?: boolean, responseType: 'arraybuffer',\r\n\t\twithCredentials?: boolean,\r\n\t}): Observable<HttpEvent<ArrayBuffer>>;\r\n\r\n\r\n\tput(url: string, body: any | null, options: {\r\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined, observe: 'events',\r\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\r\n\t\treportProgress?: boolean, responseType: 'blob',\r\n\t\twithCredentials?: boolean,\r\n\t}): Observable<HttpEvent<Blob>>;\r\n\r\n\r\n\tput(url: string, body: any | null, options: {\r\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined, observe: 'events',\r\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\r\n\t\treportProgress?: boolean, responseType: 'text',\r\n\t\twithCredentials?: boolean,\r\n\t}): Observable<HttpEvent<string>>;\r\n\r\n\r\n\tput(url: string, body: any | null, options: {\r\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined, observe: 'events',\r\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\r\n\t\treportProgress?: boolean,\r\n\t\tresponseType?: 'json',\r\n\t\twithCredentials?: boolean,\r\n\t}): Observable<HttpEvent<Object>>;\r\n\r\n\r\n\tput<T>(url: string, body: any | null, options: {\r\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined, observe: 'events',\r\n\t\tresponseType?: 'json',\r\n\t\twithCredentials?: boolean,\r\n\t}): Observable<HttpEvent<T>>;\r\n\r\n\r\n\tput(url: string, body: any | null, options: {\r\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined, observe: 'response',\r\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\r\n\t\treportProgress?: boolean, responseType: 'arraybuffer',\r\n\t\twithCredentials?: boolean,\r\n\t}): Observable<HttpResponse<ArrayBuffer>>;\r\n\r\n\r\n\tput(url: string, body: any | null, options: {\r\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined, observe: 'response',\r\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\r\n\t\treportProgress?: boolean, responseType: 'blob',\r\n\t\twithCredentials?: boolean,\r\n\t}): Observable<HttpResponse<Blob>>;\r\n\r\n\r\n\tput(url: string, body: any | null, options: {\r\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined, observe: 'response',\r\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\r\n\t\treportProgress?: boolean, responseType: 'text',\r\n\t\twithCredentials?: boolean,\r\n\t}): Observable<HttpResponse<string>>;\r\n\r\n\r\n\tput(url: string, body: any | null, options: {\r\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined, observe: 'response',\r\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\r\n\t\treportProgress?: boolean,\r\n\t\tresponseType?: 'json',\r\n\t\twithCredentials?: boolean,\r\n\t}): Observable<HttpResponse<Object>>;\r\n\r\n\r\n\tput<T>(url: string, body: any | null, options: {\r\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined, observe: 'response',\r\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\r\n\t\treportProgress?: boolean,\r\n\t\tresponseType?: 'json',\r\n\t\twithCredentials?: boolean,\r\n\t}): Observable<HttpResponse<T>>;\r\n\r\n\r\n\tput(url: string, body: any | null, options?: {\r\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined,\r\n\t\tobserve?: 'body',\r\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\r\n\t\treportProgress?: boolean,\r\n\t\tresponseType?: 'json',\r\n\t\twithCredentials?: boolean,\r\n\t}): Observable<Object>;\r\n\r\n\r\n\tput<T>(url: string, body: any | null, options?: {\r\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined,\r\n\t\tobserve?: 'body',\r\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\r\n\t\treportProgress?: boolean,\r\n\t\tresponseType?: 'json',\r\n\t\twithCredentials?: boolean,\r\n\t}): Observable<T>;\r\n\r\n\r\n\tput(url: string, body: any | null, options: {\r\n\t\theaders?: HttpHeaders | Headers | { [key: string]: string | string[] } | string | undefined,\r\n\t\tobserve?: HttpObserveType,\r\n\t\tparams?: HttpParams | { [param: string]: string | string[] },\r\n\t\treportProgress?: boolean,\r\n\t\tresponseType?: 'arraybuffer' | 'blob' | 'json' | 'text',\r\n\t\twithCredentials?: boolean,\r\n\t} = {}): Observable<any> {\r\n\t\treturn this.request<any>('PUT', url, optionsWithBody_<T>(options, body));\r\n\t}\r\n}\r\n\r\n*/\r\n","import { IServerVars } from \"../../../src/rxcomp-server\";\r\n\r\nexport const Vars: IServerVars = {\r\n\tname: 'rxcomp-server',\r\n\thost: '',\r\n\tresource: '/',\r\n\tapi: '/api',\r\n\tstatic: false,\r\n\tdevelopment: false,\r\n\tproduction: true,\r\n};\r\n\r\n/*\r\nexport const STATIC = window.location.port === '40333' || window.location.host === 'actarian.github.io';\r\nexport const DEVELOPMENT = ['localhost', '127.0.0.1', '0.0.0.0'].indexOf(window.location.host.split(':')[0]) !== -1;\r\nexport const PRODUCTION = !DEVELOPMENT;\r\nexport const ENV = {\r\n\tNAME: 'ws-events',\r\n\tSTATIC,\r\n\tDEVELOPMENT,\r\n\tPRODUCTION,\r\n\tRESOURCE: '/Modules/Events/Client/docs/',\r\n\tSTATIC_RESOURCE: './',\r\n\tAPI: '/api',\r\n\tSTATIC_API: (DEVELOPMENT && !STATIC) ? '/Modules/Events/Client/docs/api' : './api',\r\n};\r\nexport function getApiUrl(url, useStatic) {\r\n\tconst base = (useStatic || STATIC) ? ENV.STATIC_API : ENV.API;\r\n\tconst json = (useStatic || STATIC) ? '.json' : '';\r\n\treturn `${base}${url}${json}`;\r\n}\r\nexport function getResourceRoot() {\r\n\treturn STATIC ? ENV.STATIC_RESOURCE : ENV.RESOURCE;\r\n}\r\nexport function getSlug(url) {\r\n\tif (!url) {\r\n\t\treturn url;\r\n\t}\r\n\tif (url.indexOf(`/${ENV.NAME}`) !== 0) {\r\n\t\treturn url;\r\n\t}\r\n\tif (STATIC) {\r\n\t\tconsole.log(url);\r\n\t\treturn url;\r\n\t}\r\n\turl = url.replace(`/${ENV.NAME}`, '');\r\n\turl = url.replace('.html', '');\r\n\treturn `/it/it${url}`;\r\n}\r\n*/\r\n","import { Component, errors$, IFactoryMeta } from 'rxcomp';\r\nimport { EMPTY, Observable } from 'rxjs';\r\nimport { first, takeUntil, tap } from 'rxjs/operators';\r\nimport HttpClient from './http/http-client';\r\nimport { HttpHandler } from './http/http-handler';\r\nimport { HttpInterceptor, HttpInterceptors } from './http/http-interceptor';\r\nimport { HttpRequest } from './http/http-request';\r\nimport { HttpEvent, HttpResponse } from './http/http-response';\r\nimport { Vars } from './vars';\r\n\r\nconst cancelRequest: boolean = false;\r\n\r\nexport class CustomInterceptor implements HttpInterceptor {\r\n\tintercept(request: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {\r\n\t\tif (cancelRequest) {\r\n\t\t\treturn EMPTY;\r\n\t\t}\r\n\t\tconst clonedRequest = request.clone({\r\n\t\t\turl: request.url,\r\n\t\t});\r\n\t\t// console.log('CustomInterceptor.clonedRequest', clonedRequest);\r\n\t\treturn next.handle(clonedRequest);\r\n\t\treturn next.handle(request).pipe(\r\n\t\t\ttap(event => {\r\n\t\t\t\tif (event instanceof HttpResponse) {\r\n\t\t\t\t\tconsole.log('CustomInterceptor.status', event.status);\r\n\t\t\t\t\tconsole.log('CustomInterceptor.filter', request.params.get('filter'));\r\n\t\t\t\t}\r\n\t\t\t})\r\n\t\t);\r\n\t}\r\n}\r\n\r\nconst interceptor = new CustomInterceptor();\r\nHttpInterceptors.push(interceptor);\r\n\r\ninterface ITodoItem {\r\n\tid: number;\r\n\ttitle: string;\r\n\tcompleted: boolean;\r\n}\r\n\r\ninterface IGetTodos {\r\n\tgetTodos: ITodoItem[]\r\n}\r\n\r\ninterface IResponseData {\r\n\tdata: IGetTodos;\r\n}\r\n\r\nexport default class AppComponent extends Component {\r\n\titems: ITodoItem[] = [];\r\n\terror: any = null;\r\n\r\n\tonInit() {\r\n\t\t// console.log('AppComponent.onInit', this);\r\n\t\t/*\r\n\t\tconst payload = { query: `{ hello }` };\r\n\t\t*/\r\n\t\t/*\r\n\t\tconst payload = { query: `{ roll(dices: ${3}, sides: ${6}) }` };\r\n\t\t*/\r\n\t\t/*\r\n\t\tconst payload = {\r\n\t\t\tquery: `query ($dices: Int!, $sides: Int) {\r\n\t\t\troll(dices: $dices, sides: $sides)\r\n\t\t}`, variables: { dices: 3, sides: 6 }\r\n\t\t};\r\n\t\t*/\r\n\t\tconst payload = { query: `{ getTodos { id, title, completed } }` };\r\n\t\t/*\r\n\t\tHttpClient.post$<IResponseData>(`${Vars.host}${Vars.api}`, payload, {\r\n\t\t\tparams: { query: `{ getTodos { id, title, completed } }` },\r\n\t\t\treportProgress: true\r\n\t\t}).pipe(\r\n\t\t*/\r\n\r\n\t\tconst methodUrl: string = `${Vars.host}${Vars.api}`;\r\n\t\tconsole.log('methodUrl', methodUrl);\r\n\t\tHttpClient.post$<IResponseData>(methodUrl, payload).pipe(\r\n\t\t\tfirst(),\r\n\t\t).subscribe((response: IResponseData) => {\r\n\t\t\tthis.items = response.data.getTodos;\r\n\t\t\tthis.pushChanges();\r\n\t\t\t// console.log('AppComponent.getTodos', this.items);\r\n\t\t}, error => console.log);\r\n\r\n\t\t// HttpService.get$(`https://jsonplaceholder.typicode.com/users/1/todos`).pipe(\r\n\r\n\t\t/*\r\n\t\tHttpService.get$(`${Vars.host}/data/todos.json`).pipe(\r\n\t\t\tfirst(),\r\n\t\t).subscribe(response => {\r\n\t\t\t// console.log('AppComponent.items', response);\r\n\t\t\tthis.items = response.data;\r\n\t\t\tthis.pushChanges();\r\n\t\t});\r\n\t\t*/\r\n\r\n\t\terrors$.pipe(\r\n\t\t\ttakeUntil(this.unsubscribe$),\r\n\t\t).subscribe(error => {\r\n\t\t\tthis.error = error;\r\n\t\t\tthis.pushChanges();\r\n\t\t});\r\n\r\n\t}\r\n\r\n\tonClick(item: { title: string, completed: boolean }) {\r\n\t\titem.completed = !item.completed;\r\n\t\tthis.pushChanges();\r\n\t}\r\n\r\n\tstatic meta: IFactoryMeta = {\r\n\t\tselector: '[app-component]',\r\n\t};\r\n\r\n}\r\n","import { CoreModule, IModuleMeta, Module } from 'rxcomp';\r\nimport AppComponent from './app.component';\r\n\r\nexport default class AppModule extends Module {\r\n\r\n\tstatic meta: IModuleMeta = {\r\n\t\timports: [\r\n\t\t\tCoreModule,\r\n\t\t],\r\n\t\tdeclarations: [\r\n\t\t],\r\n\t\tbootstrap: AppComponent,\r\n\t};\r\n\r\n}\r\n","import { Browser } from 'rxcomp';\r\nimport AppModule from './app.module';\r\n\r\nBrowser.bootstrap(AppModule);\r\n"]}